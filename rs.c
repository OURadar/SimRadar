//
//  rs.c
//  Radar Simulation Framework
//
//  Created by Boon Leng Cheong.
//  Copyright (c) 2015-2016 Boon Leng Cheong. All rights reserved.
//

#include "rs.h"
#include "rs_priv.h"

// The block declaration is automatically generated by XCode
#if defined (_USE_GCL_)
#include "rs.cl.h"
#endif

#define RS_INDENT  "                  "

#pragma mark -

// These implementations are very inefficient on CPU; They are coded this way so comparison with the GPU kernel codes can be made easily.
cl_float4 complex_multiply(const cl_float4 a, const cl_float4 b) {
    return (cl_float4){{
        a.s0 * b.s0 - a.s1 * b.s1,
        a.s1 * b.s0 + a.s0 * b.s1,
        a.s2 * b.s2 - a.s3 * b.s3,
        a.s3 * b.s2 + a.s2 * b.s3
    }};
}

cl_float4 complex_divide(const cl_float4 a, const cl_float4 b) {
    float bm01 = b.s0 * b.s0 + b.s1 * b.s1;
    float bm23 = b.s2 * b.s2 + b.s3 * b.s3;
    return (cl_float4){{
        (a.s0 * b.s0 + a.s1 * b.s1) / bm01,
        (a.s1 * b.s0 - a.s0 * b.s1) / bm01,
        (a.s2 * b.s2 + a.s3 * b.s3) / bm23,
        (a.s3 * b.s2 - a.s2 * b.s3) / bm23
    }};
}

cl_double4 double_complex_multiply(const cl_double4 a, const cl_double4 b) {
    return (cl_double4){{
        a.s0 * b.s0 - a.s1 * b.s1,
        a.s1 * b.s0 + a.s0 * b.s1,
        a.s2 * b.s2 - a.s3 * b.s3,
        a.s3 * b.s2 + a.s2 * b.s3
    }};
}

cl_double4 double_complex_divide(const cl_double4 a, const cl_double4 b) {
    double bm01 = b.s0 * b.s0 + b.s1 * b.s1;
    double bm23 = b.s2 * b.s2 + b.s3 * b.s3;
    return (cl_double4){{
        (a.s0 * b.s0 + a.s1 * b.s1) / bm01,
        (a.s1 * b.s0 - a.s0 * b.s1) / bm01,
        (a.s2 * b.s2 + a.s3 * b.s3) / bm23,
        (a.s3 * b.s2 - a.s2 * b.s3) / bm23
    }};
}

#pragma mark -
#pragma mark Convenient Functions

char *commaint(long long num) {
    static int i = 7;
    static char buf[8][64];
    
    // Might need a semaphore to protect the following line
    i = i == 7 ? 0 : i + 1;
    
    int b = i;
    snprintf(buf[b], 48, "%lld", num);
    if (num >= 1000) {
        int c = (int)(strlen(buf[b]) - 1) / 3; // Number of commans
        int p = (int)(strlen(buf[b])) + c;     // End position
        int d = 1;                             // Count of digits
        buf[b][p] = '\0';
        while (p > 0) {
            p--;
            buf[b][p] = buf[b][p - c];
            if (d > 3) {
                d = 0;
                buf[b][p] = ',';
                c--;
            }
            d++;
        }
    }
    return buf[b];
}

char *commafloat(float num) {
    static int i = 7;
    static char buf[8][64];
    i = i == 7 ? 0 : i + 1;
    int b = i;
    snprintf(buf[b], 64, "%s.%02d", commaint(num), (int)(100 * (num - floorf(num))));
    return buf[b];
}

// Here is a nice reference: http://www.cplusplus.com/ref/ctime/time.html
char *now() {
    static char timestr[64];
    time_t utc;
    time(&utc);
    strftime(timestr, 63, "%H:%M:%S", localtime(&utc));
    return timestr;
}


char *nowlong() {
    static char timestr[64];
    time_t utc;
    time(&utc);
    strftime(timestr, 63, "%Y%m%d-%H%M%S", localtime(&utc));
    return timestr;
}


char *nowlongoffset(const int offset) {
    static char timestr[64];
    time_t utc;
    time(&utc);
    utc += offset;
    strftime(timestr, 63, "%Y%m%d-%H%M%S", localtime(&utc));
    return timestr;
}


void rsprint(const char *format, ...) {
    
    char str[RS_MAX_STR] = "";
    sprintf(str, "%s : RS : ", now());
    size_t len = strlen(str);
    va_list args;
    char *msg = str + len;
    
    va_start(args, format);
    vsnprintf(msg, RS_MAX_STR - len, format, args);
    len = strlen(str);
    va_end(args);
    
    len = MIN(len, RS_MAX_STR - 2);
    if (str[len-1] != '\n') {
        str[len] = '\n';
        str[len+1] = '\0';
    }
    if (!strncmp(msg, "Error", 5)) {
        fprintf(stderr, "\033[1;31m%s\033[0m", str);
    } else if (!strncmp(msg, "WARNING", 7)) {
        fprintf(stderr, "%s : RS : \033[1;33m%s\033[0m", now(), msg);
    } else if (!strncmp(msg, "INFO", 4)) {
        printf("%s : RS : \033[4m%s\033[24m", now(), msg);
    } else {
        printf("%s", str);
    }
}


void pfn_prog_notify(cl_program program, void *user_data) {
    if (user_data != NULL) {
        fprintf(stderr, "%s : RS : Program %p returned %p (via pfn_prog_notify)\n", now(), program, user_data);
    }
}


void pfn_notify(const char *errinfo, const void *private_info, size_t cb, void *user_data) {
    fprintf(stderr, "%s : RS : %s (via pfn_notify)\n", now(), errinfo);
}


// CL_DEVICE_TYPE_GPU
void get_device_info(cl_device_type device_type, cl_uint *num_devices, cl_device_id *devices, cl_uint *num_cus, cl_uint *vendors, cl_int detail_level) {
    
    int i = 0, j = 0;
    cl_uint num_platforms = 0;
    cl_uint platform_num_devices = 0;
    
    *num_devices = 0;
    
    cl_platform_id platforms[RS_MAX_GPU_PLATFORM];
    
    char buf_char[RS_MAX_STR];
    cl_uint buf_uint;
    cl_ulong buf_ulong;
    
    CL_CHECK(clGetPlatformIDs(RS_MAX_GPU_PLATFORM, platforms, &num_platforms));
    
    if (detail_level)
    printf("* Number of OpenCL platforms: %d\n", num_platforms);
    
    for (; i < num_platforms; i++) {
        
        CL_CHECK(clGetDeviceIDs(platforms[i], device_type, RS_MAX_GPU_DEVICE - *num_devices, &devices[*num_devices], &platform_num_devices));
        
        *num_devices += platform_num_devices;
        if (*num_devices >= RS_MAX_GPU_DEVICE) {
            fprintf(stderr, "%s : RS : Sweet. A lot of devices found. Upgrade! Upgrade!\n", now());
            *num_devices = RS_MAX_GPU_DEVICE;
            return;
        }
        
        if (detail_level) {
            printf("  > PLATFORM %d:\n", i);
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, RS_MAX_STR, buf_char, NULL));
            printf("    * NAME = %s\n", buf_char);
            if (detail_level > 1) {
                CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, RS_MAX_STR, buf_char, NULL));
                printf("    * VENDOR = %s\n", buf_char);
            }
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_PROFILE, RS_MAX_STR, buf_char, NULL));
            printf("    * PROFILE = %s\n", buf_char);
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, RS_MAX_STR, buf_char, NULL));
            printf("    * VERSION = %s\n", buf_char);
            if (detail_level > 2) {
                CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, RS_MAX_STR, buf_char, NULL));
                if (strlen(buf_char)) {
                    char *b = buf_char;
                    while (1) {
                        char *e = strchr(b, ' ');
                        if (e) {
                            *e = '\0';
                        }
                        if (b == buf_char) {
                            printf("    * EXTENSIONS = %s\n", b);
                        } else {
                            printf("                   %s\n", b);
                        }
                        if (e) {
                            b = e + 1;
                        } else {
                            break;
                        }
                    }
                }
            }
            printf("    * Number of OpenCL devices = %d\n", *num_devices);
            
#define FMT "%-35s"
#define FMT2 "%-14s"
            
            for (j = 0; j < platform_num_devices; j++) {
                printf("      > DEVICE %d:\n", j);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_NAME, RS_MAX_STR, buf_char, NULL));
                printf("        - " FMT " = %s\n", "CL_DEVICE_NAME", buf_char);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VENDOR, RS_MAX_STR, buf_char, NULL));
                if (strcasestr(buf_char, "intel")) {
                    vendors[j] = RS_GPU_VENDOR_INTEL;
                } else if (strcasestr(buf_char, "nvidia")) {
                    vendors[j] = RS_GPU_VENDOR_NVIDIA;
                } else if (strcasestr(buf_char, "amd")) {
                    vendors[j] = RS_GPU_VENDOR_AMD;
                } else {
                    vendors[j] = RS_GPU_VENDOR_UNKNOWN;
                }
                printf("        - " FMT " = %s (%d)\n", "CL_DEVICE_VENDOR", buf_char, vendors[j]);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
                printf("        - " FMT " = %s B\n", "CL_DEVICE_GLOBAL_MEM_SIZE", commaint(buf_ulong));
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
                printf("        - " FMT " = %s B\n", "CL_DEVICE_MAX_MEM_ALLOC_SIZE", commaint(buf_ulong));
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
                printf("        - " FMT " = %u\n", "CL_DEVICE_MAX_COMPUTE_UNITS", (unsigned int)num_cus[j]);
                if (detail_level > 1) {
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, RS_MAX_STR, buf_char, NULL));
                    printf("        - " FMT " = %s\n", "CL_DEVICE_VERSION", buf_char);
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, RS_MAX_STR, buf_char, NULL));
                    printf("        - " FMT " = %s\n", "CL_DRIVER_VERSION", buf_char);
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(buf_uint), &buf_uint, NULL));
                    printf("        - " FMT " = %s MHz\n", "CL_DEVICE_MAX_CLOCK_FREQUENCY", commaint(buf_uint));
                    if (detail_level > 2) {
                        size_t work_sizes[3];
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(work_sizes), &work_sizes, NULL);
                        printf("        - " FMT " = %zu / %zu / %zu\n", "CL_DEVICE_MAX_WORK_ITEM_SIZES", work_sizes[0], work_sizes[1], work_sizes[2]);
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), work_sizes, NULL);
                        printf("        - " FMT " = %zu\n", "CL_DEVICE_MAX_WORK_GROUP_SIZE", work_sizes[0]);
                        clGetDeviceInfo(devices[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
                        printf("        - " FMT " = %s B\n", "CL_DEVICE_LOCAL_MEM_SIZE", commaint(buf_ulong));
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
                        printf("        - " FMT " = %s B\n\n", "CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE", commaint(buf_ulong));
                        
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
                        printf("        - " FMT "   " FMT2 " %7s\n", "CL_DEVICE_IMAGE <dim>", "2D_MAX_WIDTH", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
                        printf("          " FMT "   " FMT2 " %7s\n", "", "2D_MAX_HEIGHT", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
                        printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_WIDTH", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
                        printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_HEIGHT", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_DEPTH, sizeof(size_t), work_sizes, NULL);
                        printf("          " FMT "   " FMT2 " %7s\n\n", "", "3D_MAX_DEPTH", commaint(work_sizes[0]));
                    }
                }
            } // for (; j < platform_num_devices; j++)
        } else {
            for (; j < platform_num_devices; j++)
            CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
        }
    } // for (; i < num_platforms; i++)
}


cl_uint read_kernel_source_from_files(char *src_ptr[], ...) {
    
    static char char_buf[RS_MAX_KERNEL_SRC] = "";
    
    cl_uint count = 0, len = 0;
    
    va_list files;
    
    va_start(files, src_ptr);
    char *filename = va_arg(files, char *);
    while (filename != NULL && strlen(filename) > 0) {
        
#ifdef DEBUG_KERNEL_READ
        rsprint("src '%s' (%d)\n", filename, (int)strlen(filename));
#endif
        
        // Read in the kernel source
        FILE *fid = fopen(filename, "r");
        if (fid == NULL) {
            fprintf(stderr, "%s : RS : Error opening kernel source %s.\n", now(), filename);
            break;
        }
        while (!feof(fid) && strlen(char_buf) < RS_MAX_KERNEL_SRC && count < RS_MAX_KERNEL_LINES) {
            src_ptr[count] = fgets(char_buf + len, RS_MAX_KERNEL_SRC - len, fid);
            if (src_ptr[count] != NULL) {
                len += strlen(src_ptr[count]) + 1;
                count++;
            }
        }
        fclose(fid);
        
        filename = va_arg(files, char *);
    }
    va_end(files);
    
    if (len >= RS_MAX_KERNEL_SRC * 8 / 10) {
        printf("%s : RS : \e[31mWARNING. Kernel source size = %s / %s (%.2f > 80%%)\e[0m\n",
               now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), (float)len / RS_MAX_KERNEL_SRC * 100.0f);
    }
    
    if (len >= RS_MAX_KERNEL_SRC || count >= RS_MAX_KERNEL_LINES) {
        fprintf(stderr, "%s : RS : Kernel source exceeds buffer size constraints.  (len = %s / %s, count = %s / %s)\n",
                now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), commaint(count), commaint(RS_MAX_KERNEL_LINES));
        return 0;
    }
    
#ifdef DEBUG_KERNEL_READ
    printf("%d lines\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d:%s", i, src_ptr[i]);
    }
#endif
    
    return count;
}


ReductionParams *make_reduction_params(cl_uint count, cl_uint user_max_groups, cl_uint user_max_work_items) {
    
    ReductionParams *params = (ReductionParams *)malloc(sizeof(ReductionParams));
    
    if (params == NULL) {
        rsprint("Error. Unable to allocate memory for ReductionParams.");
        return NULL;
    }
    
    // Copy these for housekeeping
    params->count = count;
    params->user_max_groups = user_max_groups;
    params->user_max_work_items = user_max_work_items;
    
    // Work items is only count / 2 for small counts
    int work_items = count > 2 * user_max_work_items ? user_max_work_items : count / 2;
    
    // Number of group of item-pairs
    int groups = count / (work_items * 2);
    if (groups > user_max_groups) {
        groups = user_max_groups;
    }
    
    cl_uint levels = 1;
    cl_uint numels = groups;
    
    // First pass to figure out how many levels
    while (numels > 1) {
        int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
        numels = numels / (work_items * 2);
        levels++;
    }
    
    params->pass_counts = levels;
    params->entry_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    params->group_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    params->work_item_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    
    params->entry_counts[0] = count;
    params->group_counts[0] = groups;
    params->work_item_counts[0] = work_items;
    
    int level = 1;
    
    numels = groups;
    while (numels > 1) {
        int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
        int groups = numels / (work_items * 2);
        if (groups > user_max_groups) {
            groups = user_max_groups;
        }
        
        params->entry_counts[level] = numels;
        params->group_counts[level] = groups;
        params->work_item_counts[level] = work_items;
        
        numels = numels / (work_items * 2);
        level++;
    }
    
    return params;
}


void free_reduction_params(ReductionParams *params) {
    free(params->entry_counts);
    free(params->group_counts);
    free(params->work_item_counts);
    free(params);
}


float read_table(const float *table, const float index_last, const float index) {
    float floor_index = floorf(index);
    float alpha = index - floor_index;
    if (index <= 0.0f) {
        //		printf("%.2f / %.2f --> i = %u  X0\n", index, index_last, 0);
        return table[0];
    } else if (floor_index >= index_last) {
        //		printf("%.2f / %.2f --> i = %u  XM\n", index, index_last, (unsigned int)index_last);
        return table[(unsigned int)index_last];
    }
    unsigned int i = (unsigned int)floor_index;
    //	printf("%.2f / %.2f --> i = %d, %d / %.2f, %.2f  alpha = %.2f  v = %.3f\n", index, index_last, i, i+1,
    //		   table[i], table[i + 1],
    //		   alpha,
    //		   table[i] + alpha * (table[i + 1] - table[i]);
    return table[i] + alpha * (table[i + 1] - table[i]);
}

float zdr(cl_float4 x) {
    return 10.0f * log10f((x.s0 * x.s0 + x.s1 * x.s1) / (x.s2 * x.s2 + x.s3 * x.s3));
}

#pragma mark -
#pragma mark Private Functions

void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, cl_context_properties sharegroup, const char verb) {
	
    C->dev = dev;
    C->verb = verb;
    C->mem_usage = 0;
    
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &C->num_cus, NULL);

    CL_CHECK(clGetDeviceInfo(C->dev, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(C->mem_size), &C->mem_size, NULL));

#if defined (_USE_GCL_)
    
    // A queue & semaphore for the CL work
    C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, C->dev);
    C->sem = dispatch_semaphore_create(0);
    
    if (C->sem == NULL) {
        fprintf(stderr, "%s : RS : Error creating semaphore for the CL worker.\n", now());
        return;
    }
    
    // Set all the surface to null
    int i;
    for (i = 0; i < RS_MAX_VEL_TABLES; i++) {
        C->surf_vel[i] = NULL;
    }
    for (i = 0; i < RS_MAX_ADM_TABLES; i++) {
        C->surf_adm_cd[i] = NULL;
        C->surf_adm_cm[i] = NULL;
    }
    for (i = 0; i < RS_MAX_RCS_TABLES; i++) {
        C->surf_rcs_real[i] = NULL;
        C->surf_rcs_imag[i] = NULL;
    }
    C->surf_rcs_ellipsoids = NULL;
    
#else
	
    cl_int ret;

    if (sharegroup) {
        
        rsprint("shareGroup = %p   verb = %d\n", sharegroup, verb);
        
    #if defined (__APPLE__)
        
        cl_context_properties prop[] = {
            CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE, (cl_context_properties)sharegroup,
            0
        };

    #else
        
        cl_context_properties prop[] = {
            0
        };
        
        rsprint("Error. I do not know how to share GL & CL on this platform.");
        
    #endif

        // Create a context from a CGL share group
        C->context = clCreateContext(prop, 1, &C->dev, &pfn_notify, NULL, &ret);
        C->sharegroup = sharegroup;
    } else {
        // Create an independent OpenCL context
        C->context = clCreateContext(NULL, 1, &C->dev, &pfn_notify, NULL, &ret);
    }

    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL context.  ret = %d\n", now(), ret);
        exit(EXIT_FAILURE);
    } else if (verb > 1) {
        rsprint("OpenCL context[%d] created (context @ %p, device_id @ %p).\n", (int)C->name, C->context, dev);
    }
    

    // Program
    C->prog = clCreateProgramWithSource(C->context, src_size, (const char **)src_ptr, NULL, &ret);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error. Unable to create OpenCL program.  ret = %d\n", now(), ret);
        clReleaseContext(C->context);
        exit(EXIT_FAILURE);
    }
    if (verb) {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", &pfn_prog_notify, NULL);
    } else {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", NULL, NULL);
    }

    if (ret != CL_SUCCESS) {
        char char_buf[RS_MAX_STR] = "";
        clGetProgramBuildInfo(C->prog, C->dev, CL_PROGRAM_BUILD_LOG, RS_MAX_STR, char_buf, NULL);
        fprintf(stderr, "%s : RS : Error. CL Compilation failed:\n%s", now(), char_buf);
        clReleaseProgram(C->prog);
        clReleaseContext(C->context);
        exit(EXIT_FAILURE);
    } else if (verb > 1) {
        rsprint("OpenCL program[%d] created (program @ %p).\n", (int)C->name, C->prog);
    }
	
#define CHECK_CL_CREATE_KERNEL                                                \
    if (ret != CL_SUCCESS) {                                                  \
        rsprint("Error. Could not create OpenCL kernel.  ret = %d\n", ret);   \
        clReleaseProgram(C->prog);                                            \
        clReleaseContext(C->context);                                         \
        return;                                                               \
    }

    // Tie all kernels to the program
    C->kern_io = clCreateKernel(C->prog, "io", &ret);                                             CHECK_CL_CREATE_KERNEL
    C->kern_dummy = clCreateKernel(C->prog, "dummy", &ret);                                       CHECK_CL_CREATE_KERNEL
    C->kern_db_rcs = clCreateKernel(C->prog, "db_rcs", &ret);                                     CHECK_CL_CREATE_KERNEL
    C->kern_bg_atts = clCreateKernel(C->prog, "bg_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_el_atts = clCreateKernel(C->prog, "el_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_db_atts = clCreateKernel(C->prog, "db_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_scat_clr = clCreateKernel(C->prog, "scat_clr", &ret);                                 CHECK_CL_CREATE_KERNEL
    C->kern_scat_sig_aux = clCreateKernel(C->prog, "scat_sig_aux", &ret);                         CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_1 = clCreateKernel(C->prog, "make_pulse_pass_1", &ret);               CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_group = clCreateKernel(C->prog, "make_pulse_pass_2_group", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_local = clCreateKernel(C->prog, "make_pulse_pass_2_range", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_range = clCreateKernel(C->prog, "make_pulse_pass_2_local", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
    
    if (verb > 1) {
        rsprint("Kernels for program[%d] created.\n", (int)C->name);
        if (verb > 2) {
            size_t pref_size;
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_db_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   db_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_el_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   el_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_1()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_group, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_group()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_local, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_local()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_range, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_range()\n", pref_size);
        }
    }

    // A queue for the CL work of each device
    C->que = clCreateCommandQueue(C->context, C->dev, 0, &ret);
    if (ret != CL_SUCCESS) {
        rsprint("Creating command queue[%d] failed  (ret = %d).\n", C->name, ret);
    }
    
#endif

}


void RS_worker_free(RSWorker *C) {
	
#if defined (_USE_GCL_)
	
	dispatch_release(C->sem);
	dispatch_release(C->que);
	
#else
	
    clReleaseCommandQueue(C->que);
    
    clReleaseKernel(C->kern_io);
    clReleaseKernel(C->kern_dummy);
    clReleaseKernel(C->kern_db_rcs);
    clReleaseKernel(C->kern_bg_atts);
    clReleaseKernel(C->kern_el_atts);
    clReleaseKernel(C->kern_db_atts);
    clReleaseKernel(C->kern_scat_clr);
    clReleaseKernel(C->kern_scat_sig_aux);
    clReleaseKernel(C->kern_make_pulse_pass_1);
    clReleaseKernel(C->kern_make_pulse_pass_2_group);
    clReleaseKernel(C->kern_make_pulse_pass_2_local);
    clReleaseKernel(C->kern_make_pulse_pass_2_range);
    
    clReleaseProgram(C->prog);
    
    clReleaseContext(C->context);
	
#endif

}


void RS_worker_malloc(RSHandle *H, const int worker_id, const size_t sub_num_scats, const size_t offset) {

    RSWorker *C = &H->worker[worker_id];
    
    if (C == NULL) {
        rsprint("Worker[%d] has not been initialized?\n", worker_id);
        return;
    }
    
    // Copy the necessary parameters from host to compute workers
    C->num_scats = sub_num_scats;
    C->debris_global_offset = offset;
    
    size_t group_size_multiple = RS_CL_GROUP_ITEMS;

#if !defined (_USE_GCL_)
    
    clGetKernelWorkGroupInfo(C->kern_dummy, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(group_size_multiple), &group_size_multiple, NULL);

#endif

    if (group_size_multiple > RS_CL_GROUP_ITEMS) {
        rsprint("Error. Potential memory leak. work_items(%d) > RS_CL_GROUP_ITEMS(%d).\n", now(), (int)group_size_multiple, RS_CL_GROUP_ITEMS);
        exit(EXIT_FAILURE);
    }
    
    size_t max_work_group_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    
    cl_ulong local_mem_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &local_mem_size, NULL);
    
    if (H->verb > 2) {
        rsprint("CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %zu", group_size_multiple);
        rsprint("CL_DEVICE_MAX_WORK_GROUP_SIZE = %zu", (int)max_work_group_size);
        rsprint("CL_DEVICE_LOCAL_MEM_SIZE = %zu", (size_t)local_mem_size);
    }
    
    C->make_pulse_params = RS_make_pulse_params((cl_uint)C->num_scats,
                                                (cl_uint)group_size_multiple,
                                                (cl_uint)max_work_group_size,
                                                (cl_uint)local_mem_size,
                                                H->params.range_start,
                                                H->params.range_delta,
                                                H->params.range_count);
    
    const unsigned long work_numel = C->make_pulse_params.global[0] * C->make_pulse_params.local[0] * H->params.range_count;
    
#if defined (_USE_GCL_)
	
    // printf("Creating cl_mem from vbo ... %d %d %d \n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);
    C->scat_pos = gcl_gl_create_ptr_from_buffer(C->vbo_scat_pos);
    if (C->scat_pos == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_pos.\n", now());
        C->scat_pos = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_clr = gcl_gl_create_ptr_from_buffer(C->vbo_scat_clr);
    if (C->scat_clr == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_clr.\n", now());
        C->scat_clr = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_ori = gcl_gl_create_ptr_from_buffer(C->vbo_scat_ori);
    if (C->scat_ori == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_ori.\n", now());
        C->scat_ori = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    
    C->scat_vel = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_tum = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_aux = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_rcs = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_sig = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->work = gcl_malloc(work_numel * sizeof(cl_float4), NULL, 0);
    C->pulse = gcl_malloc(H->params.range_count * sizeof(cl_float4), NULL, 0);
    
    C->scat_rnd = gcl_malloc(C->num_scats * sizeof(cl_int4), NULL, 0);
    
    C->mem_size += (8 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_uint4);

#else
	
#define CHECK_CL_CREATE_BUFFER                                       \
    if (ret != CL_SUCCESS) {                                         \
        rsprint("Error. clCreateBuffer() failed.  ret = %d\n", ret); \
        return;                                                      \
    }
    
    cl_int ret;
    
    //printf("shared_vbo: %d %d %d\n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);

    size_t numel = ((C->num_scats + group_size_multiple - 1) / group_size_multiple) * group_size_multiple;
    
    //printf("numel = %zu  num_scats = %zu\n", numel, C->num_scats);
    
    if (H->has_vbo_from_gl) {

#if defined (CL_VERSION_1_2)

        C->scat_pos = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_pos, &ret);
        C->scat_clr = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_clr, &ret);
        C->scat_ori = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_ori, &ret);
        if (C->scat_pos == NULL || C->scat_clr == NULL || C->scat_ori == NULL || ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error in clCreateFromGLBuffer().  ret = %d\n", now(), ret);
            C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);              CHECK_CL_CREATE_BUFFER
            C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);              CHECK_CL_CREATE_BUFFER
            C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);              CHECK_CL_CREATE_BUFFER
        }
        
#else
        
        rsprint("Error. This should not happen. Open CL 1.2 is needed.");
        
#endif
        
    } else {
        C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
        C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
        C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
    }

    C->scat_vel = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_tum = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
	C->scat_aux = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_rcs = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
	C->scat_sig = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_rnd = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_int4), NULL, &ret);                        CHECK_CL_CREATE_BUFFER
    C->work     = clCreateBuffer(C->context, CL_MEM_READ_WRITE, work_numel * sizeof(cl_float4), NULL, &ret);                 CHECK_CL_CREATE_BUFFER
	C->pulse    = clCreateBuffer(C->context, CL_MEM_READ_WRITE, H->params.range_count * sizeof(cl_float4), NULL, &ret);      CHECK_CL_CREATE_BUFFER
    
    // Set some components to zero
    cl_float4 *zeros = (cl_float4 *)malloc(numel * sizeof(cl_float4));
    memset(zeros, 0, numel * sizeof(cl_float4));
    clEnqueueWriteBuffer(C->que, C->scat_aux, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    clEnqueueWriteBuffer(C->que, C->scat_rcs, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    clEnqueueWriteBuffer(C->que, C->scat_sig, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    free(zeros);
    
    C->mem_usage += (8 * numel + work_numel + H->params.range_count) * sizeof(cl_float4) + numel * sizeof(cl_uint4);
    
	//
	// Set up kernel's input / output arguments
	//
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_io, 0, sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_io, 1, sizeof(cl_mem), &C->scat_aux);
    if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel io().\n", now());
		exit(EXIT_FAILURE);
	}
	
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_dummy, 0, sizeof(cl_mem), &C->scat_pos);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel dummy().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_rcs().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCS,                  sizeof(cl_mem),     &C->rcs_ellipsoid);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCSDescription,       sizeof(cl_float4),  &C->rcs_ellipsoid_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_bg_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentEllipsoidRCS,                  sizeof(cl_mem),     &C->rcs_ellipsoid);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentEllipsoidRCSDescription,       sizeof(cl_float4),  &C->rcs_ellipsoid_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_el_atts().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentTumble,                        sizeof(cl_mem),     &C->scat_tum);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentColor,             sizeof(cl_mem),   &C->scat_clr);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentPosition,          sizeof(cl_mem),   &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentAuxiliary,         sizeof(cl_mem),   &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentRadarCrossSection, sizeof(cl_mem),   &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode,          sizeof(cl_uint4), &H->draw_mode);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_clr().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSignal,                 sizeof(cl_mem),     &C->scat_sig);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentAuxiliary,              sizeof(cl_mem),     &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentPosition,               sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentRadarCrossSection,      sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTable,            sizeof(cl_mem),     &C->angular_weight);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTableDescription, sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription,  sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_sig_aux().\n", now());
        exit(EXIT_FAILURE);
    }
    
    if (C->verb > 1) {
		rsprint("Pass 1   global =%7s   local = %3zu x %2d = %6s B   groups = %4d   N = %9s\n",
			   commaint(C->make_pulse_params.global[0]),
			   C->make_pulse_params.local[0],
			   C->make_pulse_params.range_count,
			   commaint(C->make_pulse_params.local_mem_size[0]),
			   C->make_pulse_params.group_counts[0],
			   commaint(C->make_pulse_params.entry_counts[0]));
	}
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 0, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 1, sizeof(cl_mem),                         &C->scat_sig);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 2, sizeof(cl_mem),                         &C->scat_aux);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 3, C->make_pulse_params.local_mem_size[0], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 4, sizeof(cl_mem),                         &C->range_weight);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 5, sizeof(cl_float4),                      &C->range_weight_desc);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 6, sizeof(float),                          &C->make_pulse_params.range_start);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 7, sizeof(float),                          &C->make_pulse_params.range_delta);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 8, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 9, sizeof(unsigned int),                   &C->make_pulse_params.group_counts[0]);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 10, sizeof(unsigned int),                  &C->make_pulse_params.entry_counts[0]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_1().\n", now());
		exit(EXIT_FAILURE);
	}
	
	if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_local;
	} else if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_range;
	} else {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
	}
	
	if (C->verb > 1) {
		rsprint("Pass 2   global =%7s   local = %3zu x %2lu = %6s B   groups = %3d%s   N = %9s\n",
			   commaint(C->make_pulse_params.global[1]),
			   C->make_pulse_params.local[1],
			   C->make_pulse_params.local_mem_size[1] / C->make_pulse_params.local[1] / sizeof(cl_float4),
			   commaint(C->make_pulse_params.local_mem_size[1]),
			   C->make_pulse_params.group_counts[1],
			   C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE ? "R" :
			   (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL ? "L" : "U"),
			   commaint(C->make_pulse_params.entry_counts[1]));
	}
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 0, sizeof(cl_mem),                         &C->pulse);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 1, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 2, C->make_pulse_params.local_mem_size[1], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 3, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 4, sizeof(unsigned int),                   &C->make_pulse_params.entry_counts[1]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_2().\n", now());
		exit(EXIT_FAILURE);
	}
	
#endif
	
    if (C->mem_usage > C->mem_size / 4 * 3) {
        rsprint("WARNING: High GPU memory usage by worker[%d]: %s GB out of %s GB.", C->name, commafloat((float)C->mem_usage * 1.0e-9f), commafloat((float)C->mem_size * 1.0e-9f));
    }
    if (C->verb) {
        rsprint("worker[%d] memory usage = %s B\n", C->name, commaint(C->mem_usage));
    }
}

void RS_update_computed_properties(RSHandle *H) {
    H->params.prf = 1.0f / H->params.prt;
    H->params.va = 0.25f * H->params.lambda * H->params.prf;
    H->params.fn = 0.5 / H->params.prf;
    H->params.antenna_bw_rad = H->params.antenna_bw_deg / 180.0f * M_PI;
    H->params.dr = 0.5f * H->params.c * H->params.tau;
}

#pragma mark -
#pragma mark RS Convenient functions

cl_uint RS_gpu_count(void) {
    cl_uint          num_devs;
    cl_device_id     devs[RS_MAX_GPU_DEVICE];
    cl_uint          num_cus[RS_MAX_GPU_DEVICE];
    cl_uint          vendors[RS_MAX_GPU_DEVICE];
    get_device_info(CL_DEVICE_TYPE_GPU, &num_devs, devs, num_cus, vendors, 0);
    return num_devs;
}

#pragma mark -
#pragma mark RS Initialization and Deallocation


RSHandle *RS_init_with_path(const char *bundle_path, RSMethod method, cl_context_properties sharegroup, const char verb) {
	
    int i;
    
	RSHandle *H;
	
	// Allocate
	if (posix_memalign((void **)((uintptr_t)&H), RS_ALIGN_SIZE, sizeof(RSHandle))) {
		rsprint("Error. Unable to initialize RS Framework.");
		return NULL;
	}
	memset(H, 0, sizeof(RSHandle));
	
	// Default non-zero parameters
    H->sim_tic = 0;
	H->status = RSStatusDomainNull;
	H->params.c = 3.0e8f;
    H->params.tau = 0.2e-6f;
	H->params.body_per_cell = RS_BODY_PER_CELL;
	H->params.domain_pad_factor = RS_DOMAIN_PAD;
	H->num_workers = 1;
    H->num_body_types = 1;
	H->method = method;
    H->random_seed = 19760520;
	
	for (i = 0; i < RS_MAX_GPU_DEVICE; i++) {
		H->worker[i].name = i;
	}
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        H->debris_population[i] = 0;
    }
	
	if (H->method == RS_METHOD_GPU) {
		if (verb) {
			rsprint("Getting CL devices ...");
		}
		// Get and show some device info
		get_device_info(CL_DEVICE_TYPE_GPU, &H->num_devs, H->devs, H->num_cus, H->vendors, verb);
	} else if (H->method == RS_METHOD_CPU) {
		// Run this to get the num_cus to the same values.
		get_device_info(CL_DEVICE_TYPE_CPU, &H->num_devs, H->devs, H->num_cus, H->vendors, 0);
	}
    if (H->num_devs == 0 || H->num_cus[0] == 0) {
        rsprint("Error. No OpenCL devices found.");
        return NULL;
    }

    H->num_workers = H->num_devs;
    switch (H->vendors[0]) {
        case RS_GPU_VENDOR_AMD:
        case RS_GPU_VENDOR_INTEL:
            H->preferred_multiple = H->num_cus[0] * 16;
            break;
        case RS_GPU_VENDOR_NVIDIA:
            H->preferred_multiple = H->num_cus[0] * 64;
            break;
        default:
            H->preferred_multiple = H->num_cus[0] * 256;
            break;
    }

#if defined (GUI)
    // Force to one GPU at the moment. Seems like OpenGL context can be shared with only one OpenCL context
    H->num_workers = 1;
#endif

#if defined (_USE_GCL_)
    
    H->num_workers = 1;
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], 0, NULL, 0, verb);
    }

#else

    cl_uint count;
    char *src_ptr[RS_MAX_KERNEL_LINES];
    
    // Kernel source
    if (!strcmp(bundle_path, ".")) {
        count = read_kernel_source_from_files(src_ptr, "rs.cl", NULL);
    } else {
        #ifdef INCLUDE_TYPES_IN_KERNEL
        
        // This version combines special types along with the kernel functions
        char types_h_path[RS_MAX_STR];
        char kern_src_path[RS_MAX_STR];
        snprintf(types_h_path, RS_MAX_STR, "%s/rs_types.h", bundle_path);
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, types_h_path, kern_src_path, NULL);

        #else
        
        // This version does not depend on custom types
        char kern_src_path[RS_MAX_STR];
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, kern_src_path, NULL);
        
        #endif
    }
    
    if (count == 0) {
        rsprint("Empty kernel source.");
        return NULL;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], count, (const char **)src_ptr, sharegroup, verb);
    }
	
#endif
		
    // Temporary supress the verbose output for setting default values; or very verbosy for heavy debug version
    #ifdef DEBUG_HEAVY
        H->verb = 3;
    #else
        H->verb = 0;
    #endif

    // Initialize the ADM ingest
    H->A = ADM_init();
    if (H->A == NULL) {
        rsprint("%s : Error. ADM_init() failed.");
        return NULL;
    }
    
    // Initialize the RCS ingest
    H->R = RCS_init();
    if (H->R == NULL) {
        rsprint("%s : Error. RCS_init() failed.");
        return NULL;
    }

    // Set up some basic parameters to default values, H->verb is still 0 so no API message output
    RS_set_prt(H, RS_PARAMS_PRT);
    
    RS_set_lambda(H, RS_PARAMS_LAMBDA);
    
    RS_set_antenna_params(H, RS_PARAMS_BEAMWIDTH, 50.0f);

    RS_set_tx_params(H, RS_PARAMS_TAU, 50.0e3f);
    
    RS_set_beam_pos(H, 5.0f, 1.0f);
    
	RS_set_scan_box(H,
					15.0e3f, 20.0e3f, 250.0f,                   // Range
					-12.0f, 12.0f, 1.0f,                        // Azimuth
					0.0f, 8.0f, 1.0f);                          // Elevation
    
	//RS_set_angular_weight_to_double_cone(H, 2.0f / 180.0f * M_PI);

    H->verb = verb;
	
    // Initialize the LES ingest
    //RS_set_vel_data_to_config(H, LESConfigSuctionVorticesLarge);
    RS_set_vel_data_to_config(H, LESConfigSuctionVortices);

	return H;
}


RSHandle *RS_init_for_cpu_verbose(const char verb) {
	return RS_init_with_path(".", RS_METHOD_CPU, 0, verb);
}


RSHandle *RS_init_verbose(const char verb) {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, verb);
}


RSHandle *RS_init() {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, 0);
}


void RS_free_scat_memory(RSHandle *H) {
	int i;
	
	if (H->verb > 2) {
		rsprint("Freeing GPU memories ...");
	}
	
#if defined (_USE_GCL_)
	
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vbo_scat_pos == 0) {
			rsprint("Error. Unexpected conditions. VBOs were not shared.");
			return;
		}
		gcl_free(H->worker[i].scat_pos);
		gcl_free(H->worker[i].scat_clr);  // Only the GUI version has this
		gcl_free(H->worker[i].scat_vel);
		gcl_free(H->worker[i].scat_ori);
        gcl_free(H->worker[i].scat_tum);
		gcl_free(H->worker[i].scat_aux);
        gcl_free(H->worker[i].scat_rcs);
		gcl_free(H->worker[i].scat_sig);
		gcl_free(H->worker[i].work);
		gcl_free(H->worker[i].pulse);
		gcl_free(H->worker[i].scat_rnd);
    }
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].scat_pos);
        clReleaseMemObject(H->worker[i].scat_clr);
		clReleaseMemObject(H->worker[i].scat_vel);
		clReleaseMemObject(H->worker[i].scat_ori);
        clReleaseMemObject(H->worker[i].scat_tum);
		clReleaseMemObject(H->worker[i].scat_aux);
        clReleaseMemObject(H->worker[i].scat_rcs);
		clReleaseMemObject(H->worker[i].scat_sig);
		clReleaseMemObject(H->worker[i].work);
		clReleaseMemObject(H->worker[i].pulse);
		clReleaseMemObject(H->worker[i].scat_rnd);
	}
	
#endif
	
	if (H->verb > 2) {
		rsprint("Freeing CPU memories ...");
	}
	
	free(H->scat_pos);
	free(H->scat_vel);
	free(H->scat_ori);
    free(H->scat_tum);
	free(H->scat_aux);
    free(H->scat_rcs);
	free(H->scat_sig);
    free(H->scat_rnd);

	free(H->pulse);
	
	for (i = 0; i < H->num_workers; i++) {
		free(H->pulse_tmp[i]);
	}
}


void RS_free(RSHandle *H) {
	
    int i;
    
	char v = H->verb;
	
    LES_free(H->L);
    
    ADM_free(H->A);
    
    RCS_free(H->R);

	for (i = 0; i < H->num_workers; i++) {
		RS_worker_free(&H->worker[i]);
	}
	
	RS_free_scat_memory(H);
	
#if defined (_USE_GCL_)

	for (i = 0; i < H->num_workers; i++) {
        gcl_free(H->worker[i].angular_weight);
        gcl_free(H->worker[i].range_weight);
        
        gcl_release_image(H->worker[i].rcs_ellipsoid);
        
        for (int a = 0; a < H->adm_count; a++) {
            gcl_release_image(H->worker[i].adm_cd[a]);
            gcl_release_image(H->worker[i].adm_cm[a]);
        }
        
        for (int r = 0; r < H->rcs_count; r++) {
            gcl_release_image(H->worker[i].rcs_real[r]);
            gcl_release_image(H->worker[i].rcs_imag[r]);
        }
        
        for (int v = 0; v < H->vel_count; v++) {
            gcl_release_image(H->worker[i].vel[v]);
        }
	}
	
#else
	
    for (i = 0; i < H->num_workers; i++) {
        clReleaseMemObject(H->worker[i].angular_weight);
        clReleaseMemObject(H->worker[i].range_weight);
        
        for (int a = 0; a < H->adm_count; a++) {
            clReleaseMemObject(H->worker[i].adm_cd[a]);
            clReleaseMemObject(H->worker[i].adm_cm[a]);
        }
        
        for (int r = 0; r < H->rcs_count; r++) {
            clReleaseMemObject(H->worker[i].rcs_real[r]);
            clReleaseMemObject(H->worker[i].rcs_imag[r]);
        }
        
        for (int v = 0; v < H->vel_count; v++) {
            clReleaseMemObject(H->worker[i].vel[v]);
        }
    }
    
#endif
	
    free(H->anchor_pos);
    free(H->anchor_lines);

    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
        free(H->dsd_pop);
    }
    
    free(H);
    
    if (v) {
        rsprint("Resources released.");
    }
}


RSMakePulseParams RS_make_pulse_params(const cl_uint count,
                                       const cl_uint group_size_multiple,
                                       const cl_uint user_max_groups,
                                       const cl_uint max_local_mem_size,
									   const float range_start,
                                       const float range_delta,
                                       const unsigned int range_count) {
	RSMakePulseParams param;
    
	// Keep a copy for reference
	param.num_scats = count;
	param.user_max_groups = user_max_groups;
	param.user_max_work_items = group_size_multiple;
	param.range_start = range_start;
	param.range_delta = range_delta;
	param.range_count = MAX(1, range_count);
    
	// The 2nd pass kernel functions are only for work_items <= 1024.
	if (user_max_groups > 1024) {
		fprintf(stderr, "%s : RS : I'm not programmed to handle user_max_groups > 1024.\n", now());
		param.user_max_groups = 1024;
	}
	
	// Work items is at most count / 2
    unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : count / 2;
	//unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : (count + 1) / 2;
	
	// Number of group item-pairs
    //unsigned int group_count = count <= work_items * 2 ? 1 : count / (work_items * 2);
	unsigned int group_count = count <= work_items * 2 ? 1 : (count + work_items * 2 - 1) / (work_items * 2);
	if (group_count > param.user_max_groups) {
		group_count = param.user_max_groups;
	}
	
	//printf("count=%d  work_items=%d  group_count=%d/%d\n", count, work_items, group_count, param.user_max_groups);
	
	// 1st pass
	param.entry_counts[0] = count;
	param.group_counts[0] = group_count;
	param.global[0] = group_count * work_items;
	param.local[0] = work_items;
	param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
    while (param.local_mem_size[0] > max_local_mem_size) {
        #ifdef DEBUG
        rsprint("local memory size = %zu. Adjusting ...", (size_t)max_local_mem_size);
        #endif
        if (range_count % 2 == 0) {
            work_items /= 2;
            group_count *= 2;
            if (group_count > param.user_max_groups) {
                group_count = param.user_max_groups;
            }
            param.group_counts[0] = group_count;
            param.global[0] = group_count * work_items;
            param.local[0] = work_items;
            param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
        } else {
            rsprint("Error. Could not resolve local memory size limits.");
            exit(EXIT_FAILURE);
        }
    }
	
	// 2nd pass
	unsigned int work_count = group_count * param.range_count;
	
	param.entry_counts[1] = work_count;
    work_items = work_count / (param.range_count * 2);
    if (work_items < 1) {
        fprintf(stderr, "%s : RS : 2nd pass with CL work_items < 2?\n", now());
        work_items = 1;
    }

	if (param.local[0] % param.range_count == 0 && group_size_multiple >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_UNIVERSAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else if (group_count >= 2 * param.range_count && group_size_multiple >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_LOCAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_RANGE;
		param.group_counts[1] = 1;
		param.global[1] = param.range_count;
		param.local[1] = 1;
		param.local_mem_size[1] = sizeof(cl_float4);
		
	}
	if (param.entry_counts[1] > RS_MAX_GATES * work_items) {
		fprintf(stderr, "%s : RS : H->dev_work may not be large enough.\n", now());
	}
	return param;
}


#pragma mark -
#pragma mark Properties

void RS_set_concept(RSHandle *H, RSSimulationConcept c) {
    H->sim_concept = c;
}


void RS_set_prt(RSHandle *H, const RSfloat prt) {
	H->params.prt = prt;
    
    H->sim_desc.s[RSSimulationDescriptionPRT] = H->params.prt;
    
    RS_update_computed_properties(H);
}


void RS_set_lambda(RSHandle *H, const RSfloat lambda) {
    H->params.lambda = lambda;
    
    H->sim_desc.s[RSSimulationDescriptionWaveNumber] = 4.0f * M_PI / H->params.lambda;

    RS_update_computed_properties(H);
}


void RS_set_density(RSHandle *H, const RSfloat density) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Density cannot be changed.");
        return;
    }
	H->params.body_per_cell = density;
    
    RS_update_computed_properties(H);
}


void RS_set_antenna_params(RSHandle *H, RSfloat beamwidth_deg, RSfloat gain_dbi) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar antenna parameters cannot be changed.");
        return;
    }
	H->params.antenna_bw_deg = beamwidth_deg;
    H->params.antenna_gain_dbi = gain_dbi;

    RS_update_computed_properties(H);

    RS_set_angular_weight_to_standard(H, H->params.antenna_bw_rad);
}


void RS_set_tx_params(RSHandle *H, RSfloat pulsewidth, RSfloat tx_power_watt) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar parameters cannot be changed.");
        return;
    }
	H->params.tau = pulsewidth;
	H->params.tx_power_watt = tx_power_watt;

    RS_update_computed_properties(H);

    RS_set_range_weight_to_triangle(H, H->params.dr);
}


// This method also suggests number of scatterer to be used based on the scatterer / resolution volume rule.
void RS_set_scan_box(RSHandle *H,
					 RSfloat range_start, RSfloat range_end, RSfloat range_delta,
					 RSfloat azimuth_start, RSfloat azimuth_end, RSfloat azimuth_delta,
					 RSfloat elevation_start, RSfloat elevation_end, RSfloat elevation_delta) {
	
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Scan box cannot be changed.");
        return;
    }

    //	H->status &= !RSStatusDomainPopulated;
	H->params.range_start = range_start;
	H->params.range_end = range_end;
	H->params.range_delta = range_delta;
	H->params.azimuth_start_deg = azimuth_start;
	H->params.azimuth_end_deg = azimuth_end;
	H->params.azimuth_delta_deg = azimuth_delta;
	H->params.elevation_start_deg = elevation_start;
	H->params.elevation_end_deg = elevation_end;
	H->params.elevation_delta_deg = elevation_delta;
	
	const RSfloat r_lo = floor((H->params.range_start - H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat r_hi =  ceil((H->params.range_end   + H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat az_lo = floor((H->params.azimuth_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat az_hi =  ceil((H->params.azimuth_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat el_lo = MAX(0.0f, floor((H->params.elevation_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat el_hi = MIN(90.0f,  ceil((H->params.elevation_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat tiny = 1.0e-5f;
	
	int nr = 0;
	int naz = 0;
	int nel = 0;
	
	RSfloat r;
	RSfloat az;
	RSfloat el;
	
	int ii = 0;
	
	// Number of range gates
	r = floor(H->params.range_start / H->params.range_delta) * H->params.range_delta;
	while (r <= ceil(H->params.range_end / H->params.range_delta) * H->params.range_delta) {
		r += H->params.range_delta;
		nr++;
	}
	H->params.range_count = MIN(RS_MAX_GATES, nr);
	
	// Evaluate the number of scatterers needed
	az = az_lo;
	while (az <= az_hi + tiny) {
		az += H->params.azimuth_delta_deg;
		if (az >= 360.0f) {
			az -= 360.0f;
		}
		naz++;
	}
	el = el_lo;
	while (el <= el_hi) {
		el += H->params.elevation_delta_deg;
		nel++;
    }
    // Zero volume
    if (naz == 0 || nel == 0) {
        rsprint("NEL = %d and/or NAZ = %d resulted in a zero volumne.\n", naz, nel);
        return;
    }
	H->num_anchors  = 2 * naz * nel + 1;  // Save one for radar origin
	// printf("%s : RS : Number of anchors needed = %d  (naz = %d  nel = %d)\n", now(), (int)H->num_anchors, naz, nel);
	if (H->anchor_pos) {
		if (H->verb > 2) {
			rsprint("Freeing existing anchor memory.");
		}
		free(H->anchor_pos);
	}
	H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
	if (H->anchor_pos == NULL) {
		rsprint("Error. Unable to allocate memory for anchors.");
		return;
	}
	
	// Domain size
	RSfloat
	xmin = INFINITY, xmax = -INFINITY,
	ymin = INFINITY, ymax = -INFINITY,
    zmin = INFINITY, zmax = -INFINITY;
	el = el_lo / 180.0f * M_PI;
	while (el <= el_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
		az = az_lo / 180.0f * M_PI;
		while (az <= az_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
			H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_lo * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_hi * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			az += azimuth_delta / 180.0f * M_PI;
		}
		el += elevation_delta / 180.0f * M_PI;
	}
	
	// Radar origin at (0, 0, 0)
	H->anchor_pos[ii].x = 0.0f;
	H->anchor_pos[ii].y = 0.0f;
	H->anchor_pos[ii].z = 0.0f;
	H->anchor_pos[ii].w = 5.0f;
	
	//printf("H->num_anchors = %zu   ii = %d\n", H->num_anchors, ii);
	
	// Volume of a single resolution cell at the start of the domain (svol = smallest volume)
	r = H->params.range_start;
	RSfloat svol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5f);
	RSfloat nvol = ((xmax - xmin) * (ymax - ymin) * (zmax - zmin)) / svol;
	
    // The closing domain of the simulation
    H->sim_desc.s[RSSimulationDescriptionBoundSizeX] = xmax - xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeY] = ymax - ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeZ] = zmax - zmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginX] = xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginY] = ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginZ] = zmin;
	
	// Suggest a number of scatter bodies to use
	H->num_scats = (size_t)(H->params.body_per_cell * nvol);
	
	// Round to a GPU preferred number: make_pulse_pass_1 uses 2 x max_work_group_size stride
    size_t preferred_n = (H->num_scats / H->num_workers) * H->num_workers;
    if (H->num_scats > 50000) {
        size_t max_work_group_size;
        clGetDeviceInfo(H->worker[0].dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
        size_t mul = H->num_cus[0] * H->num_devs * max_work_group_size * 2;
        preferred_n = (size_t)(H->num_scats / mul) * mul;
        while (preferred_n < H->params.body_per_cell * 9 / 10) {
            preferred_n += mul;
        }
    }
    
    // Drop concentration scaling factor
    // OLD: Typical volume is about 2500 drops per m^2, each scatterer represents N drops (Radar Equation document example)
    // NEW: Based on the supplied DSD, the total number of drops has been derived and stored in H->dsd_nd_sum.
//    float concentration_scale = sqrtf((nvol * svol * H->dsd_nd_sum) / (float)preferred_n);
    
    sprintf(H->summary,
            "User domain @\n  R:[ %6.2f ~ %6.2f ] km\n  E:[ %6.2f ~ %6.2f ] deg\n  A:[ %+6.2f ~ %+6.2f ] deg\n",
            1.0e-3*H->params.range_start, 1e-3*H->params.range_end,
            H->params.elevation_start_deg, H->params.elevation_end_deg,
            H->params.azimuth_start_deg, H->params.azimuth_end_deg);
    sprintf(H->summary + strlen(H->summary),
            "Work domain @\n  R:[ %6.2f ~ %6.2f ] km  (%d gates)\n  E:[ %6.2f ~ %6.2f ] deg  (%d rays)\n  A:[ %+6.2f ~ %+6.2f ] deg  (%d rays)\n",
            1.0e-3*r_lo, 1.0e-3*r_hi, H->params.range_count,
            el_lo, el_hi, nel,
            az_lo, az_hi, naz);
    sprintf(H->summary + strlen(H->summary),
            "==\n  X:[ %7.2f ~ %7.2f ]  (%.2f) m\n  Y:[ %7.2f ~ %7.2f ]  (%.2f) m\n  Z:[ %7.2f ~ %7.2f ]  (%.2f) m\n",
            xmin, xmax, xmax - xmin,
            ymin, ymax, ymax - ymin,
            zmin, zmax, zmax - zmin);
    sprintf(H->summary + strlen(H->summary),
            "nvol = %s x volumes of %s m^3\n", commafloat(nvol), commafloat(svol));
    sprintf(H->summary + strlen(H->summary),
            "average density = %.2f particles / radar cell\n", (float)preferred_n / nvol);
    sprintf(H->summary + strlen(H->summary),
            "Concepts used: %s%s%s\n",
            H->sim_concept & RSSimulationConceptDraggedBackground ? "D" : "",
            H->sim_concept & RSSimulationConceptBoundedParticleVelocity ? "B" : "",
            H->sim_concept & RSSimulationConceptUniformDSDScaledRCS ? "U" : "");
    
    if (H->verb) {
        rsprint("User domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+6.2f ~ %+6.2f ] deg\n",
               1.0e-3*H->params.range_start, 1e-3*H->params.range_end,
               H->params.elevation_start_deg, H->params.elevation_end_deg,
               H->params.azimuth_start_deg, H->params.azimuth_end_deg);
        rsprint("Work domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+6.2f ~ %+6.2f ] deg\n",
               1.0e-3*r_lo, 1.0e-3*r_hi,
               el_lo, el_hi,
               az_lo, az_hi);
        rsprint("            @ R:[       %-3d     ]      E:[       %-3d     ]       A:[        %-3d      ]",
                H->params.range_count, nel, naz);
		rsprint("            @ X:[ %.2f ~ %.2f ] m   Y:[ %.2f ~ %.2f ] m   Z:[ %.2f ~ %.2f ] m\n",
			   xmin, xmax,
			   ymin, ymax,
               zmin, zmax);
        rsprint("              = ( %.2f m x %.2f m x %.2f m )\n",
               xmax - xmin, ymax - ymin, zmax - zmin);
        rsprint("nvol = %s x volumes of %s m^3\n", commafloat(nvol), commafloat(svol));
        rsprint("average density = %.2f particles / radar cell\n", (float)preferred_n / nvol);
        rsprint("Concepts used:\n");
        if (H->sim_concept == RSSimulationConceptNull) {
            printf(RS_INDENT "o No special concept\n");
        } else {
            if (H->sim_concept & RSSimulationConceptDraggedBackground) {
                printf(RS_INDENT "o D - Dragged Background\n");
            }
            if (H->sim_concept & RSSimulationConceptBoundedParticleVelocity) {
                printf(RS_INDENT "o B - Bounded Particle Velocity\n");
            }
            if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
                printf(RS_INDENT "o U - Uniform DSD with Scaled RCS\n");
            }
        }
		rsprint("Set to GPU preferred %s (%.2f bodies / resolution cell)", commaint(preferred_n), (float)preferred_n / nvol);
//        if (H->verb > 1) {
//            rsprint("Drop concentration scale to be used later = %s", commafloat(concentration_scale));
//        }
	}

    // Now, we actually set it to suggested debris count
	H->num_scats = preferred_n;

    // Store a copy of concentration scale in simulation description
//    H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale] = concentration_scale;

    // Anchor lines to show the volume of interest, which was set by the user. The number is well more than enough
	H->num_anchor_lines  = 8 * (naz + nel);
	
	if (H->anchor_lines) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor_line memory.\n", now());
		}
		free(H->anchor_lines);
	}
	H->anchor_lines = (cl_float4 *)malloc(H->num_anchor_lines * sizeof(cl_float4));
	if (H->anchor_lines == NULL) {
		rsprint("Error. Unable to allocate memory for anchor_lines.");
		return;
	}
	ii = 0;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	// printf("num_anchor_lines = %zu  ii = %d\n", H->num_anchor_lines, ii);
	
	H->num_anchor_lines = ii;
	
	return;
}


void RS_set_beam_pos(RSHandle *H, RSfloat az_deg, RSfloat el_deg) {
	// Compute the unit vector of the pointing direction
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = cosf(el_deg / 180.0f * M_PI) * sinf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = cosf(el_deg / 180.0f * M_PI) * cosf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = sinf(el_deg / 180.0f * M_PI);

    H->status |= RSStatusDebrisRCSNeedsUpdate;
    H->status |= RSStatusScattererSignalNeedsUpdate;
}


void RS_set_verbosity(RSHandle *H, const char verb) {
	H->verb = verb;
}


void RS_set_debris_count(RSHandle *H, const int debris_id, const size_t count) {
    
    int i;
    
    if (debris_id == 0) {
        printf("%s : RS : RS_set_debris_count() cannot have debris = 0.\n", now());
        return;
    }

    H->debris_population[debris_id] = count;

    // Always start with one as the background scatterers are always there
    H->num_body_types = 1;
    for (i = 1; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->debris_population[i] > 0) {
            H->num_body_types++;
        }
    }
    
    if (H->verb > 1) {
        rsprint("Total number of body types = %d", (int)H->num_body_types);
    }

    if (H->sim_tic > 0) {
        RS_update_debris_count(H);
        
#if defined (_USE_GCL_)
        
        RS_derive_ndranges(H);
        
#endif

    }
}


void RS_revise_debris_counts_to_gpu_preference(RSHandle *H) {
    
    int i;
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->debris_population[i]) {
            H->debris_population[i] = ((H->debris_population[i] + H->preferred_multiple - 1) / H->preferred_multiple) * H->preferred_multiple;
        }
    }
}


size_t RS_get_debris_count(RSHandle *H, const int debris_id) {
    return H->debris_population[debris_id];
}


size_t RS_get_worker_debris_count(RSHandle *H, const int debris_id, const int worker_id) {
    return H->worker[worker_id].debris_population[debris_id];
}


size_t RS_get_all_worker_debris_counts(RSHandle *H, const int debris_id, size_t counts[]) {
    
    int i;
    
    for (i = 0; i < H->num_workers; i++) {
        counts[i] = H->worker[i].debris_population[debris_id];
    }
    return H->debris_population[debris_id];
}


RSVolume RS_get_domain(RSHandle *H) {
    RSVolume v;
    v.size.x = H->sim_desc.s[RSSimulationDescriptionBoundSizeX];
    v.size.y = H->sim_desc.s[RSSimulationDescriptionBoundSizeY];
    v.size.z = H->sim_desc.s[RSSimulationDescriptionBoundSizeZ];
    v.origin.x = H->sim_desc.s[RSSimulationDescriptionBoundOriginX];
    v.origin.y = H->sim_desc.s[RSSimulationDescriptionBoundOriginY];
    v.origin.z = H->sim_desc.s[RSSimulationDescriptionBoundOriginZ];
    return v;
}


void RS_update_debris_count(RSHandle *H) {
    
    int i, k;
    
    size_t count = H->num_scats;
    
    if (H->num_workers == 0) {
        rsprint("RS : Expected. Number of workers = 0.");
        return;
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 1) {
        k--;
        count -= H->debris_population[k];
    }
    H->debris_population[0] = count;

    if (H->verb) {
        rsprint("RS : Population details:");
        for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->debris_population[k] == 0) {
                break;
            }
            //printf("                 o Global debris_population[%d] = %s\n", k, commaint(H->debris_population[k]));
            printf(RS_INDENT "o Global debris_population[%d] = %s\n", k, commaint(H->debris_population[k]));
        }
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 0) {
        k--;
        size_t debris_count_left = H->debris_population[k];
        if (debris_count_left == 0) {
            for (i = 0; i < H->num_workers; i++) {
                H->worker[i].debris_population[k] = 0;
            }
            continue;
        }
        // Groups of debris types
        size_t round_up_down_toggle = H->num_workers > 1 ? k % H->num_workers : k;
        size_t sub_debris_population = (H->debris_population[k] + round_up_down_toggle) / H->num_workers;
        for (i = 0; i < H->num_workers - 1; i++) {
            H->worker[i].debris_population[k] = sub_debris_population;
            debris_count_left -= sub_debris_population;
        }
        // The last worker gets all the remainders
        H->worker[i].debris_population[k] = debris_count_left;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        k = RS_MAX_DEBRIS_TYPES;
        size_t origin = H->worker[i].num_scats;
        while (k > 1) {
            k--;
            if (H->worker[i].debris_population[k] == 0) {
                continue;
            }
            origin -= H->worker[i].debris_population[k];
            H->worker[i].debris_origin[k] = origin;
        }
    }
    
    if (H->verb > 2) {
        for (i = 0; i < H->num_workers; i++) {
            rsprint("RS : worker[%d] with total population %s  offset %s\n", i, commaint(H->worker[i].num_scats), commaint(H->worker[i].debris_global_offset));
            for (k = 0; k < H->num_body_types; k++) {
                printf(RS_INDENT "o debris_population[%d] - [ %9s, %9s, %9s ]\n", k,
                       commaint(H->worker[i].debris_origin[k]),
                       commaint(H->worker[i].debris_population[k]),
                       commaint(H->worker[i].debris_origin[k] + H->worker[i].debris_population[k]));
            }
        }
    }
}


void RS_set_dsd(RSHandle *H, const float *nd, const float *diameters, const int count, const char name) {
    
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. DSD cannot be changed.");
        return;
    }
    
    int i;
    
    if (count == 0) {
        printf(" %s : RS : DSD bin count cannot be 0.\n", now());
        return;
    }
    
    H->dsd_name = name;
    H->dsd_count = count;
    
    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
        free(H->dsd_pop);
    }

    // Derive concentration to pdf
    RSfloat *pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_nd_sum = 0.0f;
    for (i = 0; i < count; i++) {
        H->dsd_nd_sum += nd[i];
    }
    for (i = 0; i < count; i++) {
        pdf[i] = nd[i] / H->dsd_nd_sum;
    }
    
    // Total drops
    rsprint("Drop concentration ~ %s drops / m^3", commaint(H->dsd_nd_sum));

    H->dsd_r = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_cdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pop = (size_t *)malloc(count * sizeof(size_t));
    
    if (H->dsd_r == NULL || H->dsd_pdf == NULL || H->dsd_cdf == NULL || H->dsd_pop == NULL) {
        rsprint("Error. Unable to allocate memory for DSD parameterization.");
        return;
    }
    
    memset(H->dsd_r, 0, count * sizeof(RSfloat));
    memset(H->dsd_pdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_cdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_pop, 0, count * sizeof(size_t));
    
    RSfloat lo = 0.0f;
    
    for (i = 0; i < count; i++) {
        H->dsd_r[i] = 0.5f * diameters[i];
        H->dsd_pdf[i] = pdf[i];
        H->dsd_cdf[i] = lo;
        lo += pdf[i];
    }
    
    if (H->verb > 1) {
        printf("%s : RS : User set DSD specifications:\n", now());
        for (i = 0; i < MIN(MAX(count - 2, 1), 3); i++) {
            printf(RS_INDENT "o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
        if (count > 5) {
            printf(RS_INDENT "o  :      -      :     /     :\n");
            printf(RS_INDENT "o  :      -      :     /     :\n");
            i = MAX(4, count - 1);
        }
        for (; i < count; i++) {
            printf(RS_INDENT "o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
    }
    
    free(pdf);
}


void RS_set_dsd_to_mp_with_sizes(RSHandle *H, const float *ds, const int count) {
    
    int i;
    
    float d;
    
    H->dsd_n0 = 8000.0f;              // Marshall-Palmer 1948, mu = 0.08 cm^-4 = 8000 m^-3 m^-1
    H->dsd_lambda = 2.3f * 1000.0f;   // Let's say rainrate of ~15 mm hr^-1, lambda = 41 R ^-0.21 = 2.3
    
    RSfloat *n = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    // Derive a concentration curve
    for (i = 0; i < count; i++) {
        d = ds[i];
        n[i] = H->dsd_n0 * exp(-H->dsd_lambda * d);
    }
    
    RS_set_dsd(H, n, ds, count, RSDropSizeDistributionMarshallPalmer);

    free(n);
}


void RS_set_dsd_to_mp(RSHandle *H) {
    float ds[] = {0.001f, 0.002f, 0.003f, 0.004f, 0.005f};
    //float ds[] = {0.001f, 0.003f, 0.005f};
    //float ds[] = {0.003f, 0.004f, 0.005f, 0.006f};

    RS_set_dsd_to_mp_with_sizes(H, ds, sizeof(ds) / sizeof(float));
}


void RS_set_rcs_ellipsoid_table(RSHandle *H, const cl_float4 *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {

    int i;
    
    RSTable table = RS_table_init(table_size * 4);
    if (table.data == NULL) {
        return;
    }
    // Set up the coefficients for FMA(a, b, c) in the CL kernel
    table.dx = 1.0f / table_index_delta;
    table.x0 = -table_index_start * table.dx;
    table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(cl_float4));
    if (H->verb > 1) {
        rsprint("Host RCS of ellipsoid table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n",
                table.dx, table.x0, table.xm, table_size);
    }
    
//    cl_image_format format = {CL_RGBA, CL_FLOAT};
//    
//#if defined (CL_VERSION_1_2)
//    
//    cl_image_desc desc;
//    desc.image_type = CL_MEM_OBJECT_IMAGE1D;
//    desc.image_width  = table_size;
//    desc.image_height = 1;
//    desc.image_depth  = 1;
//    desc.image_array_size = 0;
//    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
//    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
//    desc.num_mip_levels = 0;
//    desc.num_samples = 0;
//    desc.buffer = NULL;
//    
//#endif
//    
//#if defined (_USE_GCL_)
//    
//    for (i = 0; i < H->num_workers; i++) {
//        if (H->worker[i].rcs_ellipsoid != NULL) {
//            if (H->verb > 1) {
//                rsprint("worker[%d] setting RCS of ellipsoids.", i);
//            }
//            gcl_release_image(H->worker[i].rcs_ellipsoid);
//            H->worker[i].mem_size -= (cl_uint)(H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionMaximum] + 1.0f) * sizeof(cl_float4);
//        }
//        H->worker[i].rcs_ellipsoid = gcl_create_image(&format, table_size, 1, 1, H->worker[i].surf_rcs_ellipsoids);
//        if (H->worker[i].rcs_ellipsoid == NULL) {
//            fprintf(stderr, "%s : RS : Error creating RCS of ellipsoid table on CL device.\n", now());
//            return;
//        }
//        for (int i = 0; i < 5; i++ ) {
//            printf("weights[%d] = %.3e %.3e %.3e %.3e ...\n", i, weights[i].s0, weights[i].s1, weights[i].s2, weights[i].s3);
//        }
//        dispatch_async(H->worker[i].que, ^{
//            size_t origin[3] = {0, 0, 0};
//            size_t region[3] = {table_size, 1, 1};
//            gcl_copy_ptr_to_image(H->worker[i].rcs_ellipsoid, (void *)weights, origin, region);
//            dispatch_semaphore_signal(H->worker[i].sem);
//        });
//    }
//    
//    for (i = 0; i < H->num_workers; i++) {
//        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
//    }
//    
//#else
//    
//    cl_int ret;
//    cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
//
//    for (i = 0; i < H->num_workers; i++) {
//        if (H->worker[i].rcs_ellipsoid != NULL) {
//            if (H->verb > 1) {
//                rsprint("worker[%d] setting RCS of ellipsoids.", now(), i);
//            }
//            clReleaseMemObject(H->worker[i].rcs_ellipsoid);
//        }
//        if (H->verb > 2) {
//            rsprint("worker[%d] creating RCS of ellipsoids (cl_mem) & copying data from %p.\n", i, table.data);
//        }
//        
//        #if defined (CL_VERSION_1_2)
//        
//        H->worker[i].rcs_ellipsoid = clCreateImage(H->worker[i].context, flags, &format, &desc, (void *)weights, &ret);
//        
//        #else
//        
//        H->worker[i].rcs_ellipsoid = clCreateImage2D(H->worker[i].context, flags, &format, table_size, 1, table_size * sizeof(cl_float4), (void *)weights, &ret);
//        
//        #endif
//        
//        if (ret != CL_SUCCESS) {
//            rsprint("Error creating RCS of ellipsoid table on CL device.");
//            return;
//        }
//        if (H->verb > 2) {
//            rsprint("worker[%d] created RCS of ellipsoids @ %p.", i, H->worker[i].rcs_ellipsoid);
//        }
//    }
//    
//#endif
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].rcs_ellipsoid != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting RCS of ellipsoids.", i);
            }
            gcl_free(H->worker[i].rcs_ellipsoid);
        }
        H->worker[i].rcs_ellipsoid = gcl_malloc(table_size * sizeof(cl_float4), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].rcs_ellipsoid == NULL) {
            rsprint("Error. Unable to create RCS of ellipsoid table on CL device.");
            return;
        }
    }
    
#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].rcs_ellipsoid != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting RCS of ellipsoid.", i);
            }
            clReleaseMemObject(H->worker[i].rcs_ellipsoid);
        }
        if (H->verb > 2) {
            rsprint("worker[%d] creating RCS of ellipsoid (cl_mem) & copying data from %p.", i, table.data);
        }
        H->worker[i].rcs_ellipsoid = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(cl_float4), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("Error. Unable to create RCS of ellipsoid table on CL device.");
            return;
        }
        if (H->verb > 2) {
            rsprint("worker[%d] created RCS of ellipsoid table @ %p.\n", i, H->worker[i].rcs_ellipsoid);
        }
    }
    
#endif

    for (i = 0; i < H->num_workers; i++) {
        // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
        H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
        if (H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] == 0.0f) {
            rsprint("WARNING: Drop concentration scaling not set.");
        }
        H->worker[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }
    
    RS_table_free(table);
    
}


void RS_set_range_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host range weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n",
               table.dx, table.x0, table.xm, table_size);
    }
		
#if defined (_USE_GCL_)
		
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting range weight.", i);
            }
            gcl_free(H->worker[i].range_weight);
        }
        H->worker[i].range_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].range_weight == NULL) {
            rsprint("Error. Unable to create range weight table on CL device.");
            return;
        }
    }

#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting range weight.", i);
            }
            clReleaseMemObject(H->worker[i].range_weight);
        }
        if (H->verb > 2) {
            rsprint("worker[%d] creating range weight (cl_mem) & copying data from %p.", now(), i, table.data);
        }
        H->worker[i].range_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("Error. Unable to create range weight table on CL device.");
            return;
        }
        if (H->verb > 2) {
            rsprint("worker[%d] created range weight @ %p.", i, H->worker[i].range_weight);
        }
    }

#endif

    for (i = 0; i < H->num_workers; i++) {
        // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->worker[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float);
    }
    
    RS_table_free(table);

}


void RS_set_range_weight_to_triangle(RSHandle *H, float pulse_width_m) {
	float w[3] = {0.0f, 1.0f, 0.0f};
	RS_set_range_weight(H, w, -pulse_width_m, pulse_width_m, 3);
}


void RS_set_angular_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
	memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host angular weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d",
               table.dx, table.x0, table.xm, table_size);
    }

#if defined (_USE_GCL_)

    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting angular weight.", i);
            }
            gcl_free(H->worker[i].angular_weight);
        }
//        for (int k = 0; k < table_size; k++) {
//            printf("k=%d  w = %.3f  %.2f\n", k, table.data[k], 10 * log10f(table.data[k]));
//        }
        H->worker[i].angular_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].angular_weight == NULL) {
            rsprint("Error. Unable to create angular weight table on CL device.");
            return;
        }
    }
		
#else
		
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting angular weight.\n", i);
            }
            clReleaseMemObject(H->worker[i].angular_weight);
        }
        if (H->verb > 2) {
            rsprint("worker[%d] creating angular weight (cl_mem) & copying data from %p.", i, table.data);
        }
        H->worker[i].angular_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("Error. Unable to create angular weight table on CL device.");
            return;
        }
        if (H->verb > 2) {
            rsprint("worker[%d] created angular weight.", i);
        }
    }
		
#endif
    
    // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
    for (i = 0; i < H->num_workers; i++) {
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->worker[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float);
    }

    RS_table_free(table);
}


void RS_set_angular_weight_to_double_cone(RSHandle *H, float beamwidth_rad) {
	float w[] = {1.0f, 0.0f, 0.8f, 0.0f};
	unsigned int n = sizeof(w) / sizeof(float);
	RS_set_angular_weight(H, w, 0.0f, 2.0f * beamwidth_rad, n);
}


void RS_set_angular_weight_to_standard(RSHandle *H, float beamwidth_rad) {
	const unsigned int n = 32;
	float a;
	float b = 1.27f * M_PI / beamwidth_rad;
	float c;
	float *w = (float *)malloc(n * sizeof(float));
	
    float delta = 1.0f / 360.0f * M_PI;
    
	for (int i = 0; i < n; i++) {
		a = (float)i * delta;
		c = b * sinf(a);
		if (i == 0) {
			w[i] = 1.0f;
		} else if (i == (n - 1)) {
			w[i] = 0.0f;
		} else {
			w[i] = 8.0f * jn(2, c) / (c * c);
			w[i] *= w[i];
		}
		//printf("angle=%.4f deg  w[%d] = %.4f dB\n", a / M_PI * 180.0f, i, 10.0f * log10f(w[i]));
	}
	
    RS_set_angular_weight(H, w, 0.0f, delta, n);

    free(w);
}


void RS_set_vel_data(RSHandle *H, const RSTable3D table) {
	
	int i;
		
    int t = H->vel_count;
    
	cl_image_format format = {CL_RGBA, CL_FLOAT};
	
#if defined (CL_VERSION_1_2)

    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE3D;
    desc.image_width  = table.x_;
    desc.image_height = table.y_;
    desc.image_depth  = table.z_;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vel[t] != NULL) {

#if defined (_USE_GCL_)

            gcl_release_image(H->worker[i].vel[t]);

#else
            
            clReleaseMemObject(H->worker[i].vel[t]);
            
#endif

        }

#if defined (_USE_GCL_)

        H->worker[i].vel[t] = gcl_create_image(&format, desc.image_width, desc.image_height, desc.image_depth, H->worker[i].surf_vel[t]);

#else
        
        cl_int ret;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
    #if defined (CL_VERSION_1_2)
        
        H->worker[i].vel[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, table.data, &ret);
        
    #else
        
        H->worker[i].vel[t] = clCreateImage3D(H->worker[i].context, flags, &format, table.x_, table.y_, table.z_,
                                              table.x_ * sizeof(cl_float4), table.y_ * table.x_ * sizeof(cl_float4), table.data, &ret);
        
    #endif
        
#endif
        
        if (H->worker[i].vel[t] == NULL) {
			rsprint("Error. worker[%d] unable to create wind table on CL device.\n", i);
			return;
        } else if (H->verb > 2) {
            rsprint("worker[%d] created wind table vel[%d] @ %p\n", i, t, &H->worker[i].vel[t]);
        }

#if defined (_USE_GCL_)

        dispatch_async(H->worker[i].que, ^{
			size_t origin[3] = {0, 0, 0};
			size_t region[3] = {table.x_, table.y_, table.z_};
			gcl_copy_ptr_to_image(H->worker[i].vel[t], table.data, origin, region);
			dispatch_semaphore_signal(H->worker[i].sem);
		});

#endif

    }
	
	for (i = 0; i < H->num_workers; i++) {

#if defined (_USE_GCL_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
#endif

        // Copy over to CL worker
        float tmpf; memcpy(&tmpf, &table.spacing, sizeof(float));
        H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionFormat] = tmpf;                   // Make a copy in float so we are maintaining all 32-bits
        //printf("%s : RS : %d / %.9f\n", now(), table.spacing, H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionFormat]);
        if (table.spacing & RSTableSpacingStretchedX) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeX] = table.xs;      // "m" for stretched grid: m * log1p(n * pos.x) + o;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleX] = table.xo;   // "n" for stretched grid: m * log1p(n * pos.y) + o;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetX] = table.xm;          // "o" for stretched grid: m * log1p(n * pos.z) + o;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleX] = table.xs;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginX] = table.xo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumX] = table.xm;
        }
        if (table.spacing & RSTableSpacingStretchedY) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeY] = table.ys;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleY] = table.yo;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetY] = table.ym;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleY] = table.ys;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginY] = table.yo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumY] = table.ym;
        }
        if (table.spacing & RSTableSpacingStretchedZ) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeZ] = table.zs;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleZ] = table.zo;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetZ] = table.zm;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleZ] = table.zs;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginZ] = table.zo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumZ] = table.zm;
        }
        H->worker[i].vel_desc.s[RSTable3DDescriptionRefreshTime] = table.tr;

        H->worker[i].mem_usage += (cl_uint)((table.xm + 1.0f) * (table.ym + 1.0f) * (table.zm + 1.0f)) * sizeof(cl_float4);
	}

    H->vel_count++;
}


void RS_set_vel_data_to_config(RSHandle *H, LESConfig c) {
    if (H->L != NULL) {
        LES_free(H->L);
    }
    H->L = LES_init_with_config_path(c, NULL);
    // Reset the velocity count to 0, as if no table has been uploaded.
    // The GPU handles are still kept intact, will be released upon framework completion / table replacement
    H->vel_count = 0;
    H->vel_out_idx = 0;
    H->vel_out_count = (uint32_t)LES_get_table_count(H->L);
    rsprint("Reading LES table (%u out of %u)...", H->vel_out_idx, H->vel_out_count);
    RS_set_vel_data_to_LES_table(H, LES_get_frame(H->L, H->vel_out_idx++));
}


void RS_set_vel_data_to_LES_table(RSHandle *H, const LESTable *leslie) {
	
	int i;
    float hmax, zmax;
	
	RSTable3D table = RS_table3d_init(leslie->nn);
    if (table.data == NULL) {
        rsprint("Error. LES input data cannot be NULL.");
        return;
    }

    // For LES tables:
    //
    // dz(k) = a * r ^ 1.05
    //
    //  z(k) = a * ( 1 - r ^ k ) / ( 1 - r )
    //
    //     k = 1 / log(r) * log( 1 - ( 1 - r ) / a * z( k ) )
    //       = 1 / log(r) * log( 1 + ( r - 1 ) / a * z( k ) )
    //
    // For a = 2.7, r = 1.05, these values may be documented in the data files at some point
    //
    //     k = 20.495934314287851 * log1p ( 0.018518518518519 * z( k ) )

    table.x_ = leslie->nx;    table.xm = 0.5f * (float)(leslie->nx - 1);    table.xs = 1.0f / log(leslie->rx);    table.xo = (leslie->rx - 1.0f) / leslie->ax;
    table.y_ = leslie->ny;    table.ym = 0.5f * (float)(leslie->ny - 1);    table.ys = 1.0f / log(leslie->ry);    table.yo = (leslie->ry - 1.0f) / leslie->ay;
    table.z_ = leslie->nz;    table.zm = 0.0f;                              table.zs = 1.0f / log(leslie->rz);    table.zo = (leslie->rz - 1.0f) / leslie->az;

    hmax = leslie->ax * (1.0f - powf(leslie->rx, table.xm)) / (1.0f - leslie->rx);
    zmax = leslie->az * (1.0f - powf(leslie->rz, (float)(leslie->nz - 1))) / (1.0f - leslie->rz);
    
    if (H->verb > 1) {
        if (H->vel_count == 0 && H->vel_out_idx == 1) {
            rsprint("LES stretched x-grid using %.6f * log1p( %.6f * x )    Mid = %.2f m\n",
                   table.xs, table.xo, hmax);
            rsprint("LES stretched z-grid using %.6f * log1p( %.6f * z )    Max = %.2f m\n",
                   table.zs, table.zo, zmax);
        }
        rsprint("GPU LES[%2d/%2d/%2d] @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
                H->vel_count, H->vel_out_idx, H->vel_out_count,
                -hmax, hmax,
                -hmax, hmax,
                0.0, zmax);
    }

    // Some other parameters
    table.tr = leslie->tr;
    table.spacing = RSTableSpacingStretchedX | RSTableSpacingStretchedY | RSTableSpacingStretchedZ;

	// Need to arrange LES values into float4, then upload to GPU's global memory
	for (i = 0; i < leslie->nn; i++) {
		table.data[i].x = leslie->data.u[i];
		table.data[i].y = leslie->data.v[i];
		table.data[i].z = leslie->data.w[i];
		table.data[i].w = 0.0f;
        if (!(isfinite(table.data[i].x) &&
              isfinite(table.data[i].y) &&
              isfinite(table.data[i].z))) {
            rsprint("WARNING. Some LES entries are not finite  (i = %d, vel = %.2f, %.2f, %.2f).",
                    i, table.data[i].x, table.data[i].y, table.data[i].z);
        }
	}

    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->vel_desc = *leslie;
    memset(&H->vel_desc.data, 0, sizeof(LESValue));

    RS_set_vel_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_vel_data_to_uniform(RSHandle *H, cl_float4 velocity) {
    
    RSTable3D table = RS_table3d_init(1);
    
    RSVolume domain = RS_get_domain(H);
    
    if (H->verb > 1) {
        rsprint("Uniform @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
    }
    
    // Set up the mapping coefficients:
    table.x_ = 1;    table.xm = 0.0f;    table.xs = 1.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
    table.y_ = 1;    table.ym = 0.0f;    table.ys = 1.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
    table.z_ = 1;    table.zm = 0.0f;    table.zs = 1.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
    
    table.tr = 1000.0f;

    table.data[0].x = velocity.x;
    table.data[0].y = velocity.y;
    table.data[0].z = velocity.z;
    table.data[0].w = 0.0f;
    
    RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube27(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(27);
	
    RSVolume domain = RS_get_domain(H);
    
	if (H->verb > 1) {
		rsprint("Cube27 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
	}
	
	// Set up the mapping coefficients: -table_start * table_xs
	table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
	table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
	table.z_ = 3;    table.zm = 2.0f;    table.zs = 3.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	//	printf(" %.2f x %.2f = %.2f\n", -domain.origin.x, H->physics_table.xs, -domain.origin.x / domain.size.x * 2.0f);
	//	printf("o = [%.2f, %.2f, %.2f]\n", table.xo, table.yo, table.zo);
	
	const float v = 10.0f;
	
	for (i = 0; i < 27; i++) {
		table.data[i].x = (float) (i % 3)      * v - v;
		table.data[i].y = (float)((i % 9) / 3) * v - v;
		table.data[i].z = (float) (i / 9)      * v - v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_vel_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube125(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(125);
	
    RSVolume domain = RS_get_domain(H);
    
	if (H->verb > 1) {
		rsprint("Cube125 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
	}
	
	// Set up the mapping coefficients
	table.x_ = 5;    table.xm = 4.0f;    table.xs = 5.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
	table.y_ = 5;    table.ym = 4.0f;    table.ys = 5.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
	table.z_ = 5;    table.zm = 4.0f;    table.zs = 5.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	const float v = 0.5f;
	
	for (i = 0; i < 125; i++) {
		table.data[i].x = (float) (i %  5)      * v - 2.0f * v;
		table.data[i].y = (float)((i % 25) / 5) * v - 2.0f * v;
		table.data[i].z = (float) (i / 25)      * v - 2.0f * v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
	
}


void RS_clear_vel_data(RSHandle *H) {
    // Technically the video RAM hasn't been freed but we will assume there is enough room and this memory gets freed when a new table comes in
    for (int i = 0; i < H->num_workers; i++) {
        cl_uint nx = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumX] + 1;
        cl_uint ny = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumY] + 1;
        cl_uint nz = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumZ] + 1;
        H->worker[i].mem_usage -= nx * ny * nz * H->vel_count * sizeof(cl_float4);
    }
    H->vel_count = 0;
}


void RS_set_adm_data(RSHandle *H, const RSTable2D cd, const RSTable2D cm) {
    
    int i;
    
    const int t = H->adm_count;
    
    const size_t n = cd.x_ * cd.y_;
    if (cm.x_ * cm.y_ != n) {
        rsprint("WARNING. RS_set_adm_data() received inconsistent cd (%d x %d) & cm (%d x %d) dimensions", cd.x_, cd.y_, cm.x_, cm.y_);
        return;
    }
    
    if (H->verb > 2) {
        rsprint("ADM[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]", H->adm_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = cd.x_;
    desc.image_height = cd.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].adm_cd[t] != NULL && H->worker[i].adm_cm[t] != NULL) {
            
#if defined (_USE_GCL_)
            
            gcl_release_image(H->worker[i].adm_cd[t]);
            gcl_release_image(H->worker[i].adm_cm[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].adm_cd[t]);
            clReleaseMemObject(H->worker[i].adm_cm[t]);
            
#endif
            
            H->worker[i].mem_usage -= ((cl_uint)(H->worker[i].adm_desc[t].s8 + 1.0f) * (H->worker[i].adm_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  adm_cd & adm_cm always have the same desc
        
        
#if defined (_USE_GCL_)
        
        H->worker[i].adm_cd[t] = gcl_create_image(&format, cd.x_, cd.y_, 1, H->worker[i].surf_adm_cd[t]);
        H->worker[i].adm_cm[t] = gcl_create_image(&format, cm.x_, cm.y_, 1, H->worker[i].surf_adm_cm[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
    #if defined (CL_VERSION_1_2)
        
        H->worker[i].adm_cd[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cm.data, &retm);
        
    #else
        
        H->worker[i].adm_cd[t] = clCreateImage2D(H->worker[i].context, flags, &format, cd.x_, cd.y_, cd.x_ * sizeof(cl_float4), cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage2D(H->worker[i].context, flags, &format, cm.x_, cm.y_, cm.x_ * sizeof(cl_float4), cm.data, &retm);
        
    #endif
        
#endif
        if (H->worker[i].adm_cd[t] == NULL || H->worker[i].adm_cm[t] == NULL) {
            rsprint("Error. worker[%d] unable to create ADM tables on CL device(s).", i);
            return;
        } else if (H->verb > 2) {
            rsprint("worker[%d] created ADM tables adm_cd[%d] & adm_cd[%d] @ %p & %p", i, t, t, &H->worker[i].adm_cd[t], &H->worker[i].adm_cm[t]);
        }
        
#if defined (_USE_GCL_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {cd.x_, cd.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].adm_cd[t], cd.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].adm_cm[t], cm.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {

#if defined (_USE_GCL_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleX] = cd.xs;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleY] = cd.ys;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginX] = cd.xo;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginY] = cd.yo;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] = cd.xm;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] = cd.ym;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnX] = H->adm_desc[t].phys.inv_inln_x;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnY] = H->adm_desc[t].phys.inv_inln_y;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnZ] = H->adm_desc[t].phys.inv_inln_z;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionTachikawa] = H->adm_desc[t].phys.Ta;
        H->worker[i].mem_usage += ((cl_uint)(cd.xm + 1.0f) * (cd.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->adm_count++;
}


void RS_set_adm_data_to_config(RSHandle *H, ADMConfig c) {
    RS_set_adm_data_to_ADM_table(H, ADM_get_table(H->A, c));
}


void RS_set_adm_data_to_ADM_table(RSHandle *H, const ADMTable *adam) {
    
    int i;
    
    RSTable2D cd = RS_table2d_init(adam->nn);
    RSTable2D cm = RS_table2d_init(adam->nn);
    
    if (cd.data == NULL || cm.data == NULL) {
        rsprint("ADM input data cannot be NULL.");
        return;
    }

    // Set up the mapping coefficients
    // Assumptions: maps are always in beta in [-180deg, +180deg] and alpha in [0, +180deg]
    cd.x_ = adam->nb;    cd.xm = (float)(cd.x_ - 1);    cd.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cd.xo = -(-M_PI) * cd.xs + 0.5f;
    cd.y_ = adam->na;    cd.ym = (float)(cd.y_ - 1);    cd.ys = (float)(adam->na - 1) / M_PI;             cd.yo = 0.5f;
    
    cm.x_ = adam->nb;    cm.xm = (float)(cm.x_ - 1);    cm.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cm.xo = -(-M_PI) * cm.xs + 0.5f;
    cm.y_ = adam->na;    cm.ym = (float)(cm.y_ - 1);    cm.ys = (float)(adam->na - 1) / M_PI;             cm.yo = 0.5f;

    // Arrange ADM values into float4, getting ready for GPU's global memory
    for (i = 0; i < adam->nn; i++) {
        cd.data[i].x = adam->data.cdx[i];
        cd.data[i].y = adam->data.cdy[i];
        cd.data[i].z = adam->data.cdz[i];
        cd.data[i].w = 0.0f;
        cm.data[i].x = adam->data.cmx[i];
        cm.data[i].y = adam->data.cmy[i];
        cm.data[i].z = adam->data.cmz[i];
        cm.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->adm_desc[H->adm_count] = *adam;
    memset(&H->adm_desc[H->adm_count].data, 0, sizeof(ADMData));

    if (H->verb > 1) {
        const int t = H->adm_count;
        rsprint("GPU ADM[%d]   Ta = %.4f  inv_inln = [%.4f %.4f %.4f]   mass = %.4f kg",
               t, H->adm_desc[t].phys.Ta, H->adm_desc[t].phys.inv_inln_x, H->adm_desc[t].phys.inv_inln_y, H->adm_desc[t].phys.inv_inln_z, H->adm_desc[t].phys.mass);
    }

    RS_set_adm_data(H, cd, cm);
    
    RS_table2d_free(cd);
    RS_table2d_free(cm);
}

void RS_set_adm_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table = RS_table2d_init(9);
    
    if (H->verb > 1) {
        rsprint("ADM to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]");
    }
    
    table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / (2.0f * M_PI);    table.xo = -(-M_PI) * table.xs;
    table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / M_PI;             table.yo = 0.0f;

    for (i = 0; i < 9; i++) {
        table.data[i].x = 1.0f;
        table.data[i].y = 1.0f;
        table.data[i].z = 1.0f;
        table.data[i].w = 0.0f;
    }
    
    RS_set_adm_data(H, table, table);
    
    RS_table2d_free(table);
}


void RS_clear_adm_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->adm_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->worker[i].mem_usage -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->adm_count = 0;
}


void RS_set_rcs_data(RSHandle *H, const RSTable2D real, const RSTable2D imag) {
    
    int i;
    
    const int t = H->rcs_count;

    const size_t n = real.x_ * real.y_;
    if (imag.x_ * imag.y_ != n) {
        rsprint("WARNING. RS_set_rcs_data() received inconsistent real (%d x %d) & imag (%d x %d) dimensions", now(), real.x_, real.y_, imag.x_, imag.y_);
        return;
    }

    if (H->verb > 1) {
        rsprint("GPU RCS[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]", H->rcs_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = real.x_;
    desc.image_height = real.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].rcs_real[t] != NULL && H->worker[i].rcs_imag[t] != NULL) {
            
#if defined (_USE_GCL_)
            
            gcl_release_image(H->worker[i].rcs_real[t]);
            gcl_release_image(H->worker[i].rcs_imag[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].rcs_real[t]);
            clReleaseMemObject(H->worker[i].rcs_imag[t]);
            
#endif
            
            H->worker[i].mem_usage -= ((cl_uint)(H->worker[i].rcs_desc[t].s8 + 1.0f) * (H->worker[i].rcs_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  rcs_real & rcs_imag always have the same desc
        
        
#if defined (_USE_GCL_)
        
        H->worker[i].rcs_real[t] = gcl_create_image(&format, real.x_, real.y_, 1, H->worker[i].surf_rcs_real[t]);
        H->worker[i].rcs_imag[t] = gcl_create_image(&format, imag.x_, imag.y_, 1, H->worker[i].surf_rcs_imag[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
    #if defined (CL_VERSION_1_2)
        
        H->worker[i].rcs_real[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, imag.data, &retm);
        
    #else
        
        H->worker[i].rcs_real[t] = clCreateImage2D(H->worker[i].context, flags, &format, real.x_, real.y_, real.x_ * sizeof(cl_float4), real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage2D(H->worker[i].context, flags, &format, imag.x_, imag.y_, imag.x_ * sizeof(cl_float4), imag.data, &retm);
        
    #endif
        
#endif
        if (H->worker[i].rcs_real[t] == NULL || H->worker[i].rcs_imag[t] == NULL) {
            rsprint("Error. worker[%d] unable to create RCS tables on CL device(s).", i);
            return;
        } else if (H->verb > 2) {
            rsprint("worker[%d] created RCS tables rcs_real[%d] & rcs_imag[%d] @ %p & %p", i, t, t, &H->worker[i].rcs_real[t], &H->worker[i].rcs_imag[t]);
        }
        
#if defined (_USE_GCL_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {real.x_, imag.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].rcs_real[t], real.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].rcs_imag[t], imag.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {
        
#if defined (_USE_GCL_)
        
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleX] = real.xs;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleY] = real.ys;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginX] = real.xo;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginY] = real.yo;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] = real.xm;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] = real.ym;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->worker[i].mem_usage += ((cl_uint)(real.xm + 1.0f) * (real.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->rcs_count++;
}


void RS_set_rcs_data_to_config(RSHandle *H, RCSConfig c) {
    RS_set_rcs_data_to_RCS_table(H, RCS_get_table(H->R, c));
}


void RS_set_rcs_data_to_RCS_table(RSHandle *H, const RCSTable *rosie) {

    int i;
    
    RSTable2D real = RS_table2d_init(rosie->nn);
    RSTable2D imag = RS_table2d_init(rosie->nn);
    
    if (real.data == NULL || imag.data == NULL) {
        rsprint("Error. RCS input data cannot be NULL.");
        return;
    }
    // Set up the mapping coefficients
    // Assumptions: maps are always in alpha in [-180deg, +180deg] and beta in [0, +180deg]
    real.x_ = rosie->na;    real.xm = (float)(real.x_ - 1);    real.xs = (float)(rosie->na - 1) / (2.0f * M_PI);    real.xo = -(-M_PI) * real.xs;
    real.y_ = rosie->nb;    real.ym = (float)(real.y_ - 1);    real.ys = (float)(rosie->nb - 1) / M_PI;             real.yo = 0.0f;
    
    imag.x_ = rosie->na;    imag.xm = (float)(imag.x_ - 1);    imag.xs = (float)(rosie->na - 1) / (2.0f * M_PI);    imag.xo = -(-M_PI) * real.xs;
    imag.y_ = rosie->nb;    imag.ym = (float)(imag.y_ - 1);    imag.ys = (float)(rosie->nb - 1) / M_PI;             imag.yo = 0.0f;
    
    // Arrange RCS values into float4, getting ready for GPU's global memory
    for (i = 0; i < rosie->nn; i++) {
        real.data[i].x = rosie->data.hh_real[i];
        real.data[i].y = rosie->data.vv_real[i];
        real.data[i].z = rosie->data.hv_real[i];
        real.data[i].w = 0.0f;
        imag.data[i].x = rosie->data.hh_imag[i];
        imag.data[i].y = rosie->data.vv_imag[i];
        imag.data[i].z = rosie->data.hv_imag[i];
        imag.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->rcs_desc[H->rcs_count] = *rosie;
    memset(&H->rcs_desc[H->rcs_count].data, 0, sizeof(RCSData));

    if (H->verb > 1) {
        const int t = H->rcs_count;
        rsprint("GPU RCS[%d]   lambda = %.2f m",
               t, H->rcs_desc[t].lambda);
    }

    RS_set_rcs_data(H, real, imag);
    
    RS_table2d_free(real);
    RS_table2d_free(imag);

}


void RS_set_rcs_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table_real = RS_table2d_init(9);
    RSTable2D table_imag = RS_table2d_init(9);
    
    if (H->verb > 1) {
        rsprint("RCS to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]");
    }
    
    table_real.x_ = 3;    table_real.xm = 2.0f;    table_real.xs = 3.0f / (2.0f * M_PI);    table_real.xo = -(-M_PI) * table_real.xs;
    table_real.y_ = 3;    table_real.ym = 2.0f;    table_real.ys = 3.0f / M_PI;             table_real.yo = 0.0f;

    table_imag.x_ = 3;    table_imag.xm = 2.0f;    table_imag.xs = 3.0f / (2.0f * M_PI);    table_imag.xo = -(-M_PI) * table_imag.xs;
    table_imag.y_ = 3;    table_imag.ym = 2.0f;    table_imag.ys = 3.0f / M_PI;             table_imag.yo = 0.0f;
    
    for (i =  0; i < 9; i++) {
        table_real.data[i].x = 1.0f;
        table_real.data[i].y = 1.0f;
        table_real.data[i].z = 1.0f;
        table_real.data[i].w = 0.0f;

        table_imag.data[i].x = 0.0f;
        table_imag.data[i].y = 0.0f;
        table_imag.data[i].z = 0.0f;
        table_imag.data[i].w = 0.0f;
    }
    
    RS_set_rcs_data(H, table_real, table_imag);
    
    RS_table2d_free(table_real);
    RS_table2d_free(table_imag);
}


void RS_clear_rcs_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->rcs_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->worker[i].mem_usage -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->rcs_count = 0;
}


void RS_set_random_seed(RSHandle *H, const unsigned int seed) {
    if (H->verb) {
        rsprint("Random number generator set to use seed %s", commaint(seed));
    }
    H->random_seed = seed;
}


#pragma mark -
#pragma mark GUI Specific Functions

#if defined (GUI) || defined (_USE_GCL_)

// Compute auxiliary attributes: range, angular weight, etc.
// Users should not need to call this directly. It's either RS_make_pulse() or RS_update_colors()
// The framework will check the status to avoid redundant compuations.
void RS_update_auxiliary_attributes(RSHandle *H) {
    
    int i;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("Error. Simulation domain not populated.");
        return;
    }
    
#if defined (_USE_GCL_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            scat_sig_aux_kernel(&H->worker[i].ndrange_scat_all,
                                (cl_float4 *)H->worker[i].scat_sig,
                                (cl_float4 *)H->worker[i].scat_aux,
                                (cl_float4 *)H->worker[i].scat_pos,
                                (cl_float4 *)H->worker[i].scat_rcs,
                                (cl_float *)H->worker[i].angular_weight,
                                H->worker[i].angular_weight_desc,
                                H->sim_desc);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE];
    memset(events, 0, sizeof(events));
    
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }

    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, events);
        clReleaseEvent(events[i]);
    }
    
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
    
#endif
    
}

void RS_update_colors(RSHandle *H) {

    int i, k;
    int r, a;

    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("Error. Simulation domain not populated.");
        return;
    }

#if defined (_USE_GCL_)

    if (H->status & RSStatusScattererSignalNeedsUpdate) {
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->worker[i];
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    dispatch_async(C->que, ^{
                        db_rcs_kernel(&C->ndrange_scat[k],
                                      (cl_float4 *)C->scat_pos,
                                      (cl_float4 *)C->scat_ori,
                                      (cl_float4 *)C->scat_rcs,
                                      (cl_image)H->worker[i].rcs_real[r],
                                      (cl_image)H->worker[i].rcs_imag[r],
                                      H->worker[i].rcs_desc[r],
                                      H->sim_desc);
                        dispatch_semaphore_signal(C->sem);
                    });
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
                }
            }
            dispatch_async(C->que, ^{
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
                scat_clr_kernel(&C->ndrange_scat_all,
                                (cl_float4 *)C->scat_clr,
                                (cl_float4 *)C->scat_pos,
                                (cl_float4 *)C->scat_aux,
                                (cl_float4 *)C->scat_rcs,
                                H->draw_mode);
                dispatch_semaphore_signal(C->sem);
            });
            dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
        }
    } else {
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->worker[i];
            dispatch_async(H->worker[i].que, ^{
                // Set individual color based on draw mode
                scat_clr_kernel(&C->ndrange_scat_all,
                                (cl_float4 *)C->scat_clr,
                                (cl_float4 *)C->scat_pos,
                                (cl_float4 *)C->scat_aux,
                                (cl_float4 *)C->scat_rcs,
                                H->draw_mode);
                dispatch_semaphore_signal(C->sem);
            });
            dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
        }
    }

#else
    
    cl_event events[RS_MAX_GPU_DEVICE][H->num_body_types];
    memset(events, 0, sizeof(events));
    
    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        // Very similar to the RS_advance_time() function but only the debris RCS is updated
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->worker[i];
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
                    clEnqueueNDRangeKernel(C->que, C->kern_db_rcs, 1, &C->debris_origin[k], &C->debris_population[k], NULL, 0, NULL, &events[i][k]);
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            clFlush(H->worker[i].que);
        }
        for (i = 0; i < H->num_workers; i++) {
            for (k = 1; k < H->num_body_types; k++) {
                if (H->worker[i].debris_population[k]) {
                    clWaitForEvents(1, &events[i][k]);
                    clReleaseEvent(events[i][k]);
                }
            }
        }
        H->status |= RSStatusScattererSignalNeedsUpdate;
    }
    for (i = 0; i < H->num_workers; i++) {
        if (H->status & RSStatusScattererSignalNeedsUpdate) {
            RSWorker *C = &H->worker[i];
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][0]);
            
            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 1, &events[i][0], &events[i][1]);
        } else {
            RSWorker *C = &H->worker[i];
            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][1]);
        }
    }
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][1]);
        clReleaseEvent(events[i][0]);
        clReleaseEvent(events[i][1]);
    }
    
#endif
    
    H->status &= ~RSStatusDebrisRCSNeedsUpdate;
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
}

void RS_share_mem_with_vbo(RSHandle *H, const int n, unsigned int vbo[][n]) {
    if (H->verb) {
        if (H->num_workers == 1) {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2]);
        } else {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2],
                   vbo[1][0], vbo[1][1], vbo[1][2]);
        }
    }
    for (int i = 0; i < H->num_workers; i++) {
        H->worker[i].vbo_scat_pos = vbo[i][0];
        H->worker[i].vbo_scat_clr = vbo[i][1];
        H->worker[i].vbo_scat_ori = vbo[i][2];
    }
    H->has_vbo_from_gl = 1;
}

#endif

#if defined (_USE_GCL_)

void RS_derive_ndranges(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {

        RSWorker *C = &H->worker[i];
        
        C->ndrange_scat_all.work_dim = 1;
        C->ndrange_scat_all.global_work_offset[0] = 0;
        C->ndrange_scat_all.global_work_size[0] = C->num_scats;
        C->ndrange_scat_all.local_work_size[0] = 0;
        
        for (int k = 0; k < H->num_body_types; k++) {
            if (H->debris_population[k] == 0) {
                continue;
            }
            C->ndrange_scat[k].work_dim = 1;
            C->ndrange_scat[k].global_work_offset[0] = C->debris_origin[k];
            C->ndrange_scat[k].global_work_size[0] = C->debris_population[k];
            C->ndrange_scat[k].local_work_size[0] = 0;
            if (C->verb > 2) {
                rsprint("work[%d] offset, size = %d, %d",
                       (int)C->name, (int)C->ndrange_scat[k].global_work_offset[0], (int)C->ndrange_scat[k].global_work_size[0]);
            }
        }
        
        C->ndrange_pulse_pass_1.work_dim = 1;
        C->ndrange_pulse_pass_1.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_1.global_work_size[0] = C->make_pulse_params.global[0];
        C->ndrange_pulse_pass_1.local_work_size[0] = C->make_pulse_params.local[0];
        
        C->ndrange_pulse_pass_2.work_dim = 1;
        C->ndrange_pulse_pass_2.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_2.global_work_size[0] = C->make_pulse_params.global[1];
        C->ndrange_pulse_pass_2.local_work_size[0] = C->make_pulse_params.local[1];
    }
}


#endif

#pragma mark -
#pragma mark Framework Functions

void RS_io_test(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			io_kernel(&H->worker[i].ndrange_scat[0],
                      (cl_float4 *)H->worker[i].scat_pos,
                      (cl_float4 *)H->worker[i].scat_aux);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
    
#else
    
	for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_io, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
	}
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
	
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }

#endif
	
}


void RS_populate(RSHandle *H) {

    int i, k;

    // Divide the scatter bodies into (num_workers) chunks
    const size_t sub_num_scats = H->num_scats / MAX(1, H->num_workers);
    
    if (H->verb > 1) {
        rsprint("RS_populate()");
    }
    
	if (H->num_scats > RS_MAX_NUM_SCATS) {
		rsprint("Number of scatterers exceed the maximum allowed. (%s > %s).\n", commaint(H->num_scats), commaint(RS_MAX_NUM_SCATS));
        exit(EXIT_FAILURE);
	}
	
    size_t max_var_size;
    CL_CHECK(clGetDeviceInfo(H->worker[0].dev, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(max_var_size), &max_var_size, NULL));
    if (sub_num_scats * sizeof(cl_float4) > max_var_size) {
        rsprint("Error. Every scatterer attribute occupies %s B > %s B.", commaint(sub_num_scats * sizeof(cl_float4)), commaint(max_var_size));
        exit(EXIT_FAILURE);
    }
    
    if (H->adm_count != H->rcs_count) {
        rsprint("ADM & RCS are not consistent. Unexpected behavior may happen.");
    }
    
    // Use some default tables if there aren't any set
//    if (H->vel_count == 0) {
//        RS_set_vel_data_to_cube27(H);
//    }
//    rsprint("Reading first LES table ...");
//    RS_set_vel_data_to_LES_table(H, LES_get_frame(H->L, 0));

    if (H->adm_count == 0) {
        RS_set_adm_data_to_unity(H);
    }
    if (H->rcs_count == 0) {
        RS_set_rcs_data_to_unity(H);
    }

    if (H->status & RSStatusDomainPopulated) {
        rsprint("WARNING. Simulation was populated.");
        return;
    }

    //
	// CPU memory allocation
	//
	if (H->scat_pos != NULL) {
		RS_free_scat_memory(H);
	}

    H->status = RSStatusDomainNull;

    posix_memalign((void **)&H->scat_pos, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_vel, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_ori, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_tum, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_aux, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rcs, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_sig, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rnd, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_uint4));

	posix_memalign((void **)&H->pulse, RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
	
	if (H->scat_pos == NULL ||
		H->scat_vel == NULL ||
		H->scat_ori == NULL ||
        H->scat_tum == NULL ||
		H->scat_aux == NULL ||
        H->scat_rcs == NULL ||
		H->scat_sig == NULL ||
        H->scat_rnd == NULL ||
		H->pulse == NULL) {
		rsprint("Error. Unable to allocate memory space for scatterers.");
		return;
	}
	
    H->mem_size = H->num_scats * (7 * sizeof(cl_float4) + sizeof(cl_uint4)) + H->params.range_count * sizeof(cl_float4);
    
	char has_null = 0;
	for (i = 0; i < H->num_workers; i++) {
		posix_memalign((void **)&H->pulse_tmp[i], RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
		has_null |= H->pulse_tmp[i] == NULL;
        H->mem_size += H->params.range_count * sizeof(cl_float4);
	}
	if (has_null) {
		rsprint("Error. Unable to allocate memory space for pulses.");
		return;
	}

    // Get the available memory of the host

#if defined(_SC_PHYS_PAGES)

    long mem_pages = sysconf(_SC_PHYS_PAGES);
    long mem_page_size = sysconf(_SC_PAGE_SIZE);
    size_t host_mem = mem_pages * mem_page_size;

#else

    uint64_t mem;
    size_t len = sizeof(mem);
    sysctlbyname("hw.memsize", &mem, &len, NULL, 0);
    size_t host_mem = mem;

#endif

    if (H->mem_size > host_mem / 4 * 3) {
        rsprint("WARNING: High host memory usage: %s GB out of %s GB.", commafloat((float)H->mem_size * 1.0e-9f), commafloat((float)host_mem * 1.0e-9f));
    } else if (H->verb) {
        if (H->mem_size > (size_t)1.0e9f) {
            rsprint("CPU memory usage = %s GB out of %s GB", commafloat((float)H->mem_size * 1.0e-9f), commafloat((float)host_mem * 1.0e-9f));
        } else {
            rsprint("CPU memory usage = %s MB out of %s MB", commafloat((float)H->mem_size * 1.0e-6f), commafloat((float)host_mem * 1.0e-6f));
        }
    }

    // Initialize the scatter body positions on CPU, will upload to the GPU later
    //RS_init_scat_pos(H);
    srand(H->random_seed);
    
    RSVolume domain = RS_get_domain(H);

    //
	// Initialize the scatter body positions & velocities
	//
	for (i = 0; i < H->num_scats; i++) {
		H->scat_pos[i].x = (float)rand() / RAND_MAX * domain.size.x + domain.origin.x;
		H->scat_pos[i].y = (float)rand() / RAND_MAX * domain.size.y + domain.origin.y;
		H->scat_pos[i].z = (float)rand() / RAND_MAX * domain.size.z + domain.origin.z;
        H->scat_pos[i].w = 0.0f;                       // Use this to store drop radius in m
        
		H->scat_aux[i].s0 = 0.0f;                      // range
        H->scat_aux[i].s1 = (float)rand() / RAND_MAX;  // age
		H->scat_aux[i].s2 = 0.0f;                      // dsd bin index
		H->scat_aux[i].s3 = 1.0f;                      // angular weight [0.0, 1.0]
		
		H->scat_vel[i].x = 0.0f;                       // u component of velocity
		H->scat_vel[i].y = 0.0f;                       // v component of velocity
		H->scat_vel[i].z = 0.0f;                       // w component of velocity
		H->scat_vel[i].w = 0.0f;                       // n/a

        // At the reference
        H->scat_ori[i].x = 0.0f;                       // x of quaternion
        H->scat_ori[i].y = 0.0f;                       // y of quaternion
        H->scat_ori[i].z = 0.0f;                       // z of quaternion
        H->scat_ori[i].w = 1.0f;                       // w of quaternion
        
        // Facing the sky
//        H->scat_ori[i].x =  0.0f;                      // x of quaternion
//        H->scat_ori[i].y = -0.707106781186547f;        // y of quaternion
//        H->scat_ori[i].z =  0.0f;                      // z of quaternion
//        H->scat_ori[i].w =  0.707106781186548f;        // w of quaternion

        // Facing the beam
        H->scat_ori[i].x =  0.5f;                      // x of quaternion
        H->scat_ori[i].y = -0.5f;                      // y of quaternion
        H->scat_ori[i].z = -0.5f;                      // z of quaternion
        H->scat_ori[i].w =  0.5f;                      // w of quaternion
        
        // Some other tests
//        H->scat_ori[i].x =  0.5f;                      // x of quaternion
//        H->scat_ori[i].y = -0.5f;                      // y of quaternion
//        H->scat_ori[i].z =  0.5f;                      // z of quaternion
//        H->scat_ori[i].w =  0.5f;                      // w of quaternion

        // Rotate by theta
//        float theta = -70.0f / 180.0f * M_PI;
//        H->scat_ori[i].x = 0.0f;
//        H->scat_ori[i].y = sinf(0.5f * theta);
//        H->scat_ori[i].z = 0.0f;
//        H->scat_ori[i].w = cosf(0.5f * theta);
        
        // Tumbling vector for orientation update
        H->scat_tum[i].x = 0.0f;                       // x of quaternion
        H->scat_tum[i].y = 0.0f;                       // y of quaternion
        H->scat_tum[i].z = 0.0f;                       // z of quaternion
        H->scat_tum[i].w = 1.0f;                       // w of quaternion

        // Initial return from each point
        H->scat_rcs[i].s0 = 1.0f;                      // sh_real of rcs
		H->scat_rcs[i].s1 = 0.0f;                      // sh_imag of rcs
		H->scat_rcs[i].s2 = 1.0f;                      // sv_real of rcs
		H->scat_rcs[i].s3 = 0.0f;                      // sv_imag of rcs
        
        // Random seeds
        H->scat_rnd[i].s0 = rand();                    // random seed
        H->scat_rnd[i].s1 = rand();                    // random seed
        H->scat_rnd[i].s2 = rand();                    // random seed
        H->scat_rnd[i].s3 = rand();                    // random seed
	}
    
    // Volume of the simulation domain (m^3)
    float vol = H->sim_desc.s[RSSimulationDescriptionBoundSizeX] * H->sim_desc.s[RSSimulationDescriptionBoundSizeY] * H->sim_desc.s[RSSimulationDescriptionBoundSizeZ];
    float drops_per_scat = (vol * H->dsd_nd_sum) / H->num_scats;

    sprintf(H->summary + strlen(H->summary), "Drops / scatterer = %s\n", commafloat(drops_per_scat));
    
    // Store a copy of concentration scale in simulation description
    H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale] = sqrt(drops_per_scat);

    
    // Parameterized drop radius as scat_pos.w if DSD has been set
    // May want to add maximum relaxation time of each drop size
    // Potential places: vel.w, aux.s2
    float a;
    int bin;
    if (H->dsd_name != RSDropSizeDistributionUndefined) {
        if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
            for (i = 0; i < H->num_scats; i++) {
                a = (float)rand() / RAND_MAX;
                bin = (int)(a * (float)H->dsd_count);
                H->dsd_pop[bin]++;
                H->scat_pos[i].w = H->dsd_r[bin];                                  // set the drop radius
                H->scat_aux[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // set the dsd bin index (temporary)
            }
        } else {
            for (i = 0; i < H->num_scats; i++) {
                a = (float)rand() / RAND_MAX;
                k = H->dsd_count;
                bin = 0;
                while (k > 0) {
                    k--;
                    if (a >= H->dsd_cdf[k]) {
                        bin = k;
                        break;
                    }
                }
                H->dsd_pop[bin]++;
                H->scat_pos[i].w = H->dsd_r[bin];                                  // set the drop radius
                H->scat_aux[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // set the dsd bin index
            }
            
            // Replace a few for debugging purpose
            #if defined(DEBUG_DSD)
            H->scat_pos[0].w = 0.0025f;
            H->scat_pos[1].w = 0.001f;
            H->scat_pos[2].w = 0.0005f;
            #endif
        }
        
        sprintf(H->summary + strlen(H->summary),
            "DSD Specifications:\n");
        for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
            sprintf(H->summary + strlen(H->summary), "  o %.2f mm - P %.5f / %s particles\n", 2000.0f * H->dsd_r[i], (float)H->dsd_pop[i] / (float)H->num_scats, commaint(H->dsd_pop[i]));
        }
        if (H->dsd_count > 8) {
            sprintf(H->summary + strlen(H->summary), "  o  :      -      :     /  :     /\n");
            sprintf(H->summary + strlen(H->summary), "  o  :      -      :     /  :     /\n");
            i = MAX(4, H->dsd_count - 1);
        }
        for (; i < H->dsd_count; i++) {
            sprintf(H->summary + strlen(H->summary), "  o %.2f mm - P %.5f / %s particles\n", 2000.0f * H->dsd_r[i], (float)H->dsd_pop[i] / (float)H->num_scats, commaint(H->dsd_pop[i]));
        }
        
        if (H->verb) {
            rsprint("Actual DSD Specifications:");
            for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
                printf(RS_INDENT "o %.2f mm - PDF %.5f / %.5f / %s particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)H->dsd_pop[i] / (float)H->num_scats, commaint(H->dsd_pop[i]));
            }
            if (H->dsd_count > 8) {
                printf(RS_INDENT "o  :      -      :     /  :     /\n");
                printf(RS_INDENT "o  :      -      :     /  :     /\n");
                i = MAX(4, H->dsd_count - 1);
            }
            for (; i < H->dsd_count; i++) {
                printf(RS_INDENT "o %.2f mm - PDF %.5f / %.5f / %s particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)H->dsd_pop[i] / (float)H->num_scats, commaint(H->dsd_pop[i]));
            }
        }
    } else {
        rsprint("INFO: No DSD specified. The background drops do not return any power.");
    }
	
    // Replace a few points for debugging purpose.
    #if defined(DEBUG_RCS)
	H->scat_pos[0].x = domain.origin.x + 0.5f * domain.size.x;
    H->scat_pos[0].y = domain.origin.y + 0.5f * domain.size.y;
    H->scat_pos[0].z = H->scat_pos[0].y * tanf(5.0f / 180.0f * M_PI);
    #endif
	
    // Replace the very first debris particle
    #if defined(DEBUG_DEBRIS)
    if (H->debris_population[1] > 0) {
        k = (int)H->debris_population[0];
        //printf("k = %d\n", k);
        H->scat_pos[k].x = 0.0f;
        H->scat_pos[k].y = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
        H->scat_pos[k].z = 0.5f * domain.size.z;
        
        H->scat_aux[k].s0 = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
    }
    #endif
	
	// Restore simulation time, default beam position at unit vector (0, 1, 0)
	H->sim_tic = 0;
	H->sim_toc = (size_t)(H->vel_desc.tp / H->params.prt);
	H->sim_time = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = 1.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionTotalParticles] = H->num_scats;
    
    // Make a copy in float so we are maintaining all 32-bits
    float tmpf; memcpy(&tmpf, &H->sim_concept, sizeof(float));
    H->sim_desc.s[RSSimulationDescriptionConcept] = tmpf;
    
    // Propagate / duplicate some constants to other places for efficient kernel execution
    for (i = 0; i < H->num_workers; i++) {
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionWaveNumber];
        H->worker[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
    }

    // First frame is loaded during RS_init(), now we fill in the buffer
    while (H->vel_count < RS_MAX_VEL_TABLES) {
        LESTable *table = LES_get_frame(H->L, H->vel_out_idx);
        if (table == NULL) {
            rsprint("Error. There is no more frame(s)?");
            exit(EXIT_FAILURE);
        }
        RS_set_vel_data_to_LES_table(H, table);
        H->vel_out_idx = H->vel_out_idx == H->vel_out_count - 1 ? 0 : H->vel_out_idx + 1;
    }

    // All tables must be ready at this point
    // - range weight table
    // - antenna weight table
    // - RCS of ellipsoid table
    // - RCS of debris table
    // - ADM of debris table
    // - 3D wind table
    RS_compute_rcs_ellipsoids(H);

    //
	// GPU memory allocation
	//
	
	size_t offset = 0;
	
    for (i = 0; i < H->num_workers; i++) {
        H->offset[i] = offset;
        if (H->verb > 1) {
            rsprint("worker[%d] num_scats = %s   offset = %s", i, commaint(sub_num_scats), commaint(offset));
        }
        RS_worker_malloc(H, i, sub_num_scats, offset);
        offset += sub_num_scats;
    }
	
    RS_update_debris_count(H);
    
#if defined (_USE_GCL_)
    
    CGLContextObj cobj = CGLGetCurrentContext();
    if (cobj == NULL) {
        rsprint("Error. No GL context yet.");
        return;
    }
    
    gcl_gl_set_sharegroup(CGLGetShareGroup(cobj));
    
    RS_derive_ndranges(H);

#endif

    // Upload the particle parameters to the GPU
    RS_upload(H);

    if (H->verb) {
        rsprint("VEL / ADM / RCS count = %d / %d / %d", H->vel_count, H->adm_count, H->rcs_count);
        rsprint("CL domain synchronized.");
    }
    
	H->status |= RSStatusDomainPopulated;
    H->status |= RSStatusScattererSignalNeedsUpdate;

	return;
}


void RS_download(RSHandle *H) {
	
	int i;

#if defined (_USE_GCL_)

//    printf("%p <-----------------------\n", H->scat_ori);
    
    for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_vel + H->offset[i], H->worker[i].scat_vel, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_aux + H->offset[i], H->worker[i].scat_aux, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_rcs + H->offset[i], H->worker[i].scat_rcs, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_sig + H->offset[i], H->worker[i].scat_sig, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
		});
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

    int k;

    cl_event events[H->num_workers][7];
    
    // Non-blocking read, wait for events later when they are all queued up.
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, &events[i][0]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, &events[i][1]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, &events[i][2]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_aux, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, &events[i][3]);
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_rcs, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_rcs + H->offset[i], 0, NULL, &events[i][4]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, &events[i][5]);
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_FALSE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, &events[i][6]);
	}

    cl_int ret;
    
    for (i = 0; i < H->num_workers; i++) {
        ret = clWaitForEvents(7, events[i]);
        if (ret != CL_SUCCESS) {
            rsprint("Error. Unable to properly read back the values.");
        }
        for (k = 0; k < 7; k++) {
            clReleaseEvent(events[i][k]);
        }
    }

#endif

    RS_merge_pulse_tmp(H);
}


void RS_download_position_only(RSHandle *H) {
	
	int i;
	
#if defined (_USE_GCL_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
	}
	
#endif

}

void RS_download_orientation_only(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
    }
    
#endif
    
}

void RS_merge_pulse_tmp(RSHandle *H) {
	memcpy(H->pulse, H->pulse_tmp[0], H->params.range_count * sizeof(cl_float4));
	for (int i = 1; i < H->num_workers; i++) {
		for (int k = 0; k < H->params.range_count; k++) {
			H->pulse[k].s0 += H->pulse_tmp[i][k].s0;
			H->pulse[k].s1 += H->pulse_tmp[i][k].s1;
			H->pulse[k].s2 += H->pulse_tmp[i][k].s2;
			H->pulse[k].s3 += H->pulse_tmp[i][k].s3;
		}
	}
    //
    // Scale the amplitude by antenna gain, tx power
    // Amplitude scaling, Ga = 10 ^ (Gt / 20) * 10 ^ (Gr / 20) * sqrt(Pt)
    // For dish antennas: Gt = Gr
    //
    //                  => g = 10 ^ (G / 20) * 10 ^ (G / 20) * sqrt(Pt)
    //                       = 10 ^ (G / 10) * sqrt(Pt)
    //
    // Amplitude scale to 1-km referece: sqrt(R ^ 4) = R ^ 2 = 1.0e6
    //
    float g = powf(10.0f, 0.1f * H->params.antenna_gain_dbi) * sqrtf(H->params.tx_power_watt) / (4.0f * M_PI) * 1.0e6f;
    for (int k = 0; k < H->params.range_count; k++) {
        H->pulse[k].s0 *= g;
        H->pulse[k].s1 *= g;
        H->pulse[k].s2 *= g;
        H->pulse[k].s3 *= g;
    }
}

void RS_download_pulse_only(RSHandle *H) {
	
	int i;
	
#if defined (_USE_GCL_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	for (i = 0; i < H->num_workers; i++)
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	
#else
	
    // Blocking read since there is only one read
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_TRUE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, NULL);
	}
	
#endif
    
	RS_merge_pulse_tmp(H);
//    printf("pulse %zu [ %+11.4e%+11.4ei %+11.4e%+11.4ei (%+6.2f)   %+11.4e%+11.4ei %+11.4e%+11.4ei (%+6.2f)  ... ]\n", H->sim_tic,
//           H->pulse[0].s0, H->pulse[0].s1, H->pulse[0].s2, H->pulse[0].s3, zdr(H->pulse[0]),
//           H->pulse[1].s0, H->pulse[1].s1, H->pulse[1].s2, H->pulse[1].s3, zdr(H->pulse[1]));
}


void RS_upload(RSHandle *H) {
	
	int i;
	
	if (H->verb > 3) {
		for (i = 0; i < H->num_workers; i++) {
			printf("%s : RS : worker[%d].scat_pos @ %p\n", now(), i, H->worker[i].scat_pos);
			printf("%s : RS : worker[%d].scat_vel @ %p\n", now(), i, H->worker[i].scat_vel);
		}
		printf("%s : RS : scat_pos @ %p\n", now(), H->scat_pos);
		printf("%s : RS : scat_vel @ %p\n", now(), H->scat_vel);
	}
	
    if (H->num_scats == 0) {
        printf("%s : RS : Abort @ num_scats = 0 during RS_upload()\n", now());
        return;
    }
	
#if defined (_USE_GCL_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->worker[i].scat_pos, H->scat_pos + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_vel, H->scat_vel + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_ori, H->scat_ori + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->worker[i].scat_tum, H->scat_tum + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_aux, H->scat_aux + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_rcs, H->scat_rcs + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_rnd, H->scat_rnd + H->offset[i], H->worker[i].num_scats * sizeof(cl_uint4));
            dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

    // Blocking write since there is no need to optimize this too much
    for (i = 0; i < H->num_workers; i++) {
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_tum, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_tum + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_aux, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rcs, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rnd, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_uint4),  H->scat_rnd + H->offset[i], 0, NULL, NULL);
	}

#endif

}


// Signal strength as a function of drop size
//void RS_rcs_from_dsd(RSHandle *H) {
//    
//    int i;
//    
//#if defined (_USE_GCL_)
//
//    for (i = 0; i < H->num_workers; i++) {
//        dispatch_async(H->worker[i].que, ^{
//            scat_rcs_kernel(&H->worker[i].ndrange_scat[0],
//                            (cl_float4 *)H->worker[i].scat_rcs,
//                            (cl_float4 *)H->worker[i].scat_pos,
//                            (cl_float4 *)H->worker[i].scat_aux,
//                            H->sim_desc);
//            dispatch_semaphore_signal(H->worker[i].sem);
//        });
//        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
//    }
//    
//#else
//    
//    cl_event events[RS_MAX_GPU_DEVICE];
//    
//    for (i = 0; i < H->num_workers; i++) {
//        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_rcs, 1, &H->worker[i].debris_origin[0], &H->worker[i].debris_population[0], NULL, 0, NULL, &events[i]);
//    }
//    
//    for (i = 0; i < H->num_workers; i++) {
//        clFlush(H->worker[i].que);
//    }
//    
//    for (i = 0; i < H->num_workers; i++) {
//        clWaitForEvents(1, &events[i]);
//        clReleaseEvent(events[i]);
//    }
//    
//#endif
//
//}


void RS_advance_time(RSHandle *H) {
	
	int i, k;
    int r, a;

    if (!(H->status & RSStatusDomainPopulated)) {
		rsprint("Error. Simulation domain not yet populated.");
		return;
	}

    const int v = H->vel_idx;

    // Advance to next wind table when the time comes
    if (H->sim_tic >= H->sim_toc) {
        H->sim_toc = H->sim_tic + (size_t)(H->vel_desc.tp / H->params.prt);
        H->vel_idx = H->vel_idx == H->vel_count - 1 ? 0 : H->vel_idx + 1;

        if (H->vel_idx == 0) {
            H->vel_count = 0;
            rsprint("Loading LES tables from files ...");
            if (H->vel_out_idx == 0) {
                rsprint("Wind table restarted.");
            }
            for (k = 0; k < RS_MAX_VEL_TABLES; k++) {
                RS_set_vel_data_to_LES_table(H, LES_get_frame(H->L, H->vel_out_idx));
                H->vel_out_idx = H->vel_out_idx == H->vel_out_count - 1 ? 0 : H->vel_out_idx + 1;
            }
        }
        if (H->verb > 2) {
            rsprint("Wind table advanced. vel_idx = %d   ( %.2f / %.4f )", H->vel_idx, H->vel_desc.tp, H->params.prt);
        }
    }
    
#if defined (_USE_GCL_)

    #if defined (_DUMMY_)
    
    i = 0;
    k = 0;
    r = 0;
    a = 0;
    dispatch_async(H->worker[i].que, ^{
        dummy_kernel(&H->worker[i].ndrange_scat_all,
                     (cl_float4 *)H->worker[i].scat_pos,
                     (cl_float4 *)H->worker[i].scat_ori,
                     (cl_float4 *)H->worker[i].scat_rcs,
                     (cl_image)H->worker[i].rcs_real[r],
                     (cl_image)H->worker[i].rcs_imag[r],
                     H->worker[i].rcs_desc[r],
                     H->sim_desc);
        dispatch_semaphore_signal(H->worker[i].sem);
    });
    dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);

    #elif defined (_ALL_DEBRIS_)
    
    i = 0;
    r = 0;
    a = 0;
    dispatch_async(H->worker[i].que, ^{
        db_atts_kernel(&H->worker[i].ndrange_scat_all,
                       (cl_float4 *)H->worker[i].scat_pos,
                       (cl_float4 *)H->worker[i].scat_ori,
                       (cl_float4 *)H->worker[i].scat_vel,
                       (cl_float4 *)H->worker[i].scat_tum,
                       (cl_float4 *)H->worker[i].scat_sig,
                       (cl_uint4 *)H->worker[i].scat_rnd,
                       (cl_image)H->worker[i].vel[v],
                       H->worker[i].vel_desc,
                       (cl_image)H->worker[i].adm_cd[a],
                       (cl_image)H->worker[i].adm_cm[a],
                       H->worker[i].adm_desc[a],
                       (cl_image)H->worker[i].rcs_real[r],
                       (cl_image)H->worker[i].rcs_imag[r],
                       H->worker[i].rcs_desc[r],
                       H->sim_desc);
        dispatch_semaphore_signal(H->worker[i].sem);
    });
    dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);

    #else
    
    // These kernels are actually independent and, thus, can be parallelized.
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            if (H->sim_concept & RSSimulationConceptDraggedBackground) {
                el_atts_kernel(&H->worker[i].ndrange_scat[0],
                               (cl_float4 *)H->worker[i].scat_pos,
                               (cl_float4 *)H->worker[i].scat_vel,
                               (cl_float4 *)H->worker[i].scat_rcs,
                               (cl_uint4 *)H->worker[i].scat_rnd,
                               (cl_image)H->worker[i].vel[v],
                               H->worker[i].vel_desc,
                               (cl_float4 *)H->worker[i].rcs_ellipsoid,
                               H->worker[i].rcs_ellipsoid_desc,
                               H->sim_desc);
            } else {
                bg_atts_kernel(&H->worker[i].ndrange_scat[0],
                               (cl_float4 *)H->worker[i].scat_pos,
                               (cl_float4 *)H->worker[i].scat_vel,
                               (cl_float4 *)H->worker[i].scat_rcs,
                               (cl_uint4 *)H->worker[i].scat_rnd,
                               (cl_image)H->worker[i].vel[v],
                               H->worker[i].vel_desc,
                               (cl_float4 *)H->worker[i].rcs_ellipsoid,
                               H->worker[i].rcs_ellipsoid_desc,
                               H->sim_desc);
            }
            dispatch_semaphore_signal(H->worker[i].sem);
		});

        r = 0;
        a = 0;
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].debris_population[k]) {
                dispatch_async(H->worker[i].que, ^{
                    db_atts_kernel(&H->worker[i].ndrange_scat[k],
                                   (cl_float4 *)H->worker[i].scat_pos,
                                   (cl_float4 *)H->worker[i].scat_ori,
                                   (cl_float4 *)H->worker[i].scat_vel,
                                   (cl_float4 *)H->worker[i].scat_tum,
                                   (cl_float4 *)H->worker[i].scat_rcs,
                                   (cl_uint4 *)H->worker[i].scat_rnd,
                                   (cl_image)H->worker[i].vel[v],
                                   H->worker[i].vel_desc,
                                   (cl_image)H->worker[i].adm_cd[a],
                                   (cl_image)H->worker[i].adm_cm[a],
                                   H->worker[i].adm_desc[a],
                                   (cl_image)H->worker[i].rcs_real[r],
                                   (cl_image)H->worker[i].rcs_imag[r],
                                   H->worker[i].rcs_desc[r],
                                   H->sim_desc);
                    dispatch_semaphore_signal(H->worker[i].sem);
                });
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
	}
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].debris_population[k]) {
                dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
            }
        }
    }
    
    #endif

#else

    cl_event events[RS_MAX_GPU_DEVICE][H->num_body_types];
    memset(events, 0, sizeof(events));
	
//	if (H->sim_tic >= H->sim_toc) {
//		H->sim_toc = H->sim_tic + (size_t)(1.0f / H->params.prt);
//	}

	for (i = 0; i < H->num_workers; i++) {
        r = 0;
        a = 0;

        // A convenient pointer to reduce dereferencing
        RSWorker *C = &H->worker[i];

//        clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->debris_origin[0], &C->num_scats, NULL, 0, NULL, &events[i][0]);
        
        // Need to refresh some parameters of the background at each time update
        if (H->sim_concept & RSSimulationConceptDraggedBackground) {
            clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,      sizeof(cl_mem),     &C->vel[v]);
            clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription,   sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_el_atts, 1, &C->debris_origin[0], &C->debris_population[0], NULL, 0, NULL, &events[i][0]);
        } else {
            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_bg_atts, 1, &C->debris_origin[0], &C->debris_population[0], NULL, 0, NULL, &events[i][0]);
        }
        
        // Debris particles
        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        for (k = 1; k < H->num_body_types; k++) {
            if (C->debris_population[k]) {
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->debris_origin[k], &C->debris_population[k], NULL, 0, NULL, &events[i][k]);
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
    }

    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
   
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][0]);
        clReleaseEvent(events[i][0]);
        for (k = 1; k < H->num_body_types; k++) {
            if (H->worker[i].debris_population[k]) {
                clWaitForEvents(1, &events[i][k]);
                clReleaseEvent(events[i][k]);
            }
        }
    }
	
#endif
	
    H->sim_time += H->params.prt;
    H->sim_desc.s[RSSimulationDescriptionSimTic] = ++H->sim_tic;
    H->status |= RSStatusScattererSignalNeedsUpdate;
}


void RS_make_pulse(RSHandle *H) {
	
    int i, k;
    int r, a;
	
	if (!(H->status & RSStatusDomainPopulated)) {
		rsprint("Error. Simulation domain not populated.");
		return;
	}

#if defined (_USE_GCL_)

    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->worker[i];
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    dispatch_async(C->que, ^{
                        db_rcs_kernel(&C->ndrange_scat[k],
                                      (cl_float4 *)C->scat_pos,
                                      (cl_float4 *)C->scat_ori,
                                      (cl_float4 *)C->scat_rcs,
                                      (cl_image)H->worker[i].rcs_real[r],
                                      (cl_image)H->worker[i].rcs_imag[r],
                                      H->worker[i].rcs_desc[r],
                                      H->sim_desc);
                        dispatch_semaphore_signal(C->sem);
                    });
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->worker[i];
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
                }
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->worker[i];
            dispatch_async(C->que, ^{
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
                dispatch_semaphore_signal(C->sem);
            });
        }
        for (i = 0; i < H->num_workers; i++) {
            dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        }
    }
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        dispatch_async(C->que, ^{
            if (H->status & RSStatusScattererSignalNeedsUpdate) {
                //printf("RS_make_pulse: kern_scat_sig_aux\n");
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
            }
            make_pulse_pass_1_kernel(&C->ndrange_pulse_pass_1,
                                     (cl_float4 *)C->work,
                                     (cl_float4 *)C->scat_sig,
                                     (cl_float4 *)C->scat_aux,
                                     C->make_pulse_params.local_mem_size[0],
                                     (cl_float *)C->range_weight,
                                     C->range_weight_desc,
                                     C->make_pulse_params.range_start,
                                     C->make_pulse_params.range_delta,
                                     C->make_pulse_params.range_count,
                                     C->make_pulse_params.group_counts[0],
                                     C->make_pulse_params.entry_counts[0]);
            switch (C->make_pulse_params.cl_pass_2_method) {
                case RS_CL_PASS_2_IN_LOCAL:
                make_pulse_pass_2_local_kernel(&C->ndrange_pulse_pass_2,
                                               (cl_float4 *)C->pulse,
                                               (cl_float4 *)C->work,
                                               C->make_pulse_params.local_mem_size[1],
                                               C->make_pulse_params.range_count,
                                               C->make_pulse_params.entry_counts[1]);
                break;
                case RS_CL_PASS_2_IN_RANGE:
                make_pulse_pass_2_range_kernel(&C->ndrange_pulse_pass_2,
                                               (cl_float4 *)C->pulse,
                                               (cl_float4 *)C->work,
                                               C->make_pulse_params.local_mem_size[1],
                                               C->make_pulse_params.range_count,
                                               C->make_pulse_params.entry_counts[1]);
                break;
                default:
                make_pulse_pass_2_group_kernel(&C->ndrange_pulse_pass_2,
                                               (cl_float4 *)C->pulse,
                                               (cl_float4 *)C->work,
                                               C->make_pulse_params.local_mem_size[1],
                                               C->make_pulse_params.range_count,
                                               C->make_pulse_params.entry_counts[1]);
                break;
            }
            dispatch_semaphore_signal(C->sem);
        });
    }
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    

#else

    cl_event events[H->num_workers][MAX(H->num_body_types, 3)];
    memset(events, 0, sizeof(events));

    // In this implementation, kern_make_pulse_pass_2 should point to kern_make_pulse_pass_2_group, kern_make_pulse_pass_2_local or kern_make_pulse_pass_2_range,
    // which had been selected based on the group size in RS_make_pulse_params()
    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        // Update all the debris RCS
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->worker[i];
            for (k = 1; k < H->num_body_types; k++) {
                if (C->debris_population[k]) {
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
                    clEnqueueNDRangeKernel(C->que, C->kern_db_rcs, 1, &C->debris_origin[k], &C->debris_population[k], NULL, 0, NULL, &events[i][k]);
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            clFlush(H->worker[i].que);
        }
        for (i = 0; i < H->num_workers; i++) {
            for (k = 1; k < H->num_body_types; k++) {
                if (H->worker[i].debris_population[k]) {
                    clWaitForEvents(1, &events[i][k]);
                    clReleaseEvent(events[i][k]);
                }
            }
        }
        H->status |= RSStatusScattererSignalNeedsUpdate;
    }
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        if (H->status & RSStatusScattererSignalNeedsUpdate) {
            //printf("RS_make_pulse: kern_scat_sig_aux : %zu\n", C->num_scats);
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][0]);
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 1, &events[i][0], &events[i][1]);
        } else {
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 0, NULL, &events[i][1]);
        }
        clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_2, 1, NULL, &C->make_pulse_params.global[1], &C->make_pulse_params.local[1], 1, &events[i][1], &events[i][2]);
    }
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][2]);
        clReleaseEvent(events[i][0]);
        clReleaseEvent(events[i][1]);
        clReleaseEvent(events[i][2]);
    }

#endif
	
    H->status &= ~RSStatusDebrisRCSNeedsUpdate;
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
}


#pragma mark -
#pragma mark Elements for table lookup

RSTable RS_table_init(size_t numel) {
    RSTable table = {0.0f, 1.0f, 1.0f, 0, NULL};
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(float))) {
		rsprint("Error. Unable to allocate an RSTable->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table_free(RSTable T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


RSTable2D RS_table2d_init(size_t numel) {
    RSTable2D table;
    
    table.xs = 1.0f;      table.ys = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        rsprint("Error. Unable to allocate an RSTable2D->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table2d_free(RSTable2D T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable3D RS_table3d_init(size_t numel) {
	RSTable3D table;
	
    table.spacing = RSTableSpacingUniform;
    
	table.xs = 1.0f;      table.ys = 1.0f;      table.zs = 1.0f;
	table.xo = 0.0f;      table.yo = 0.0f;      table.zo = 0.0f;
	table.xm = 1.0f;      table.ym = 1.0f;      table.zm = 1.0f;
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        rsprint("Error. Unable to allocate an RSTable3D->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table3d_free(RSTable3D T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


#pragma mark -
#pragma mark Display

void RS_show_radar_params(RSHandle *H) {
    rsprint("Radar Parameters:\n");
    printf(RS_INDENT "o beamwidth = %4.2f deg      o dr = %.2f m\n", H->params.antenna_bw_deg, H->params.dr);
    printf(RS_INDENT "o lambda = %4.2f m           o PRT = %.2f ms      o va = %.2f m/s\n", H->params.lambda, H->params.prt * 1.0e3f, H->params.va);
}


static void RS_show_scat_i(RSHandle *H, const size_t i) {
	printf(" %7lu - ( %9.2f, %9.2f, %9.2f, %4.2f )  %7.2f %7.2f %7.2f   %7.4f %7.4f %7.4f %7.4f\n", i,
		   H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, H->scat_pos[i].w,
		   H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w);
}


static void RS_show_rcs_i(RSHandle *H, const size_t i) {
    printf(" %7lu - ( %10.3e, %10.3e, %10.3e, %10.3e )   ( %10.3e %10.3e %10.3e %10.3e )   r = %.2f m  d = %.1f mm\n", i,
           H->scat_sig[i].x, H->scat_sig[i].y, H->scat_sig[i].z, H->scat_sig[i].w,
           H->scat_rcs[i].x, H->scat_rcs[i].y, H->scat_rcs[i].z, H->scat_rcs[i].w,
           H->scat_aux[i].s0, 2000.0f * H->scat_pos[i].w);
}


void RS_show_scat_pos(RSHandle *H) {
	size_t i, w;
    printf("positions:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = H->worker[w].debris_origin[0];
             i < H->worker[w].debris_origin[0] + H->worker[w].debris_population[0];
             i += H->worker[w].debris_population[0] / 9) {
            RS_show_scat_i(H, i);
        }
        if (H->worker[w].debris_population[1]) {
            for (i = H->worker[w].debris_origin[1];
                 i < H->worker[w].debris_origin[1] + H->worker[w].debris_population[1];
                 i += H->worker[w].debris_population[1] / 9) {
                RS_show_scat_i(H, i);
            }
        }
    }
}


void RS_show_scat_sig(RSHandle *H) {
    size_t i, w;
    printf("background:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].debris_population[0]; i += H->worker[w].debris_population[0] / 9) {
        //for (i = 0; i < H->worker[w].debris_population[0]; i++) {
            RS_show_rcs_i(H, H->worker[w].debris_global_offset + H->worker[w].debris_origin[0] + i);
        }
    }
    if (H->debris_population[1] == 0) {
        return;
    }
    // Show the debris
    //i = (int)H->debris_population[0] / H->num_workers;
    printf("debris type #1:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].debris_population[1]; i += H->worker[w].debris_population[1] / 9) {
            RS_show_rcs_i(H, H->worker[w].debris_global_offset + H->worker[w].debris_origin[1] + i);
        }
    }
}


void RS_show_pulse(RSHandle *H) {
	unsigned int i;
	printf(" %7zu - [", H->sim_tic);
	for (i = 0; i < MIN(4, H->params.range_count); i++) {
		if (i > 0) {
			printf(",");
		}
		printf(" %9.2f", H->pulse[i].s0);
	}
	if (i < H->params.range_count) {
		printf(",  . . . , %9.2f", H->pulse[H->params.range_count - 1].s0);
	}
	printf(" ] (%d)\n", H->params.range_count);
}

#pragma mark -

RSBox RS_suggest_scan_domain(RSHandle *H, const int nbeams) {
    RSBox box;

    if (H->verb > 1) {
        rsprint("RS_suggest_scan_domain()");
    }
    
    // Extremas of the domain
    float w = H->vel_desc.ax * (1.0f - powf(H->vel_desc.rx, 0.5f * (float)(H->vel_desc.nx - 3))) / (1.0f - H->vel_desc.rx);
    float h = H->vel_desc.az * (1.0f - powf(H->vel_desc.rz,        (float)(H->vel_desc.nz - 1))) / (1.0f - H->vel_desc.rz);
    
    // Maximum number of beams plus the padding on one side in azimuth
    float na = 0.5f * (float)nbeams + RS_DOMAIN_PAD + 0.5f;
    
    // Maximum number of beams in elevation
    float ne = 18.0f;
    
    // Maximum y of the emulation box: The range when the width is fully utilized; This is also rmax
    float rmax = w / sinf(na * H->params.antenna_bw_rad);
    
    // Minimum y of the emulation box: The range when the height is fully utilized
    float rmin = (rmax - 2.0f * w) / cosf(na * H->params.antenna_bw_rad) / cosf(ne * H->params.antenna_bw_rad);
    
    // If we cannot respect the padding on both sides
    // Maximum number of range cells minus the padding on both sides minus one radar cell
    float nr = (rmax - rmin) / H->params.dr - 2.0f * RS_DOMAIN_PAD - 1.0f;
    nr = ceilf(nr * 0.5f) * 2.0f;
    if (rmax - rmin < 8.0f * H->params.dr) {
        rsprint("Error. Range resolution of the radar is too coarse!");
        rsprint("rmax = %.3f  rmin = %.3f   dr = %.2f", rmax, rmin, H->params.dr);
        exit(EXIT_FAILURE);
    }

    box.origin.a = ceilf(-0.5f * (float)nbeams) * H->params.antenna_bw_rad * 180.0f / M_PI;
    box.size.a = nbeams * H->params.antenna_bw_deg;

    box.origin.r = rmax - (nr + 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;
    box.size.r = floorf(nr - 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;

    box.origin.e = 0.0f;
    box.size.e = ne * H->params.antenna_bw_deg;

    if (H->verb) {
        printf("%s : RS : Suggest scan box based on [ 2w = %.1f m, h = %.1f m ] : nr = %.1f   na = %.1f   ne = %.1f\n"
               "%s : RS : Best fit with R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %6.2f ~ %6.2f ] deg\n",
               now(), 2.0f * w, h, nr, na, ne,
               now(), 1.0e-3f * box.origin.r, 1.0e-3f * (box.origin.r + box.size.r), box.origin.e, box.origin.e + box.size.e, box.origin.a, box.origin.a + box.size.a);
    }

    return box;
}

void RS_compute_rcs_ellipsoids(RSHandle *H) {
    
    int i;
    
    const cl_double k_0 = H->sim_desc.s[RSSimulationDescriptionWaveNumber] * 0.5f;
    const cl_double epsilon_0 = 8.85418782e-12f;
    const cl_double4 epsilon_r_minus_one = (cl_double4){{78.669, 18.2257, 78.669, 18.2257}};

    if (H->verb > 1) {
        rsprint("RS_compute_rcs_ellipsoids()");
    }
    
    //
    // Sc = k_0 ^ 2 / (4 * pi * epsilon_0)
    // Coefficient 1.0e-9 for scaling the volume to unit of m^3
    //
    if (H->verb) {
        i = (int)roundf((H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale] * H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale]));
        rsprint("Drops / scatterer = %s", commaint(i));
        rsprint("Drop concentration scaling = %s  (k_0 = %.4f)", commafloat(H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale]), k_0);
    }
    const cl_double sc = k_0 * k_0 / (4.0f * M_PI * epsilon_0) * 1.0e-9f * H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
    
    // Make table with D = 0.5mm, 0.6mm, ... 10.0mm (96 entries)
    const size_t n = 96;
    
    cl_float4 *table = (cl_float4 *)malloc(n * sizeof(cl_float4));
    
    for (i = 0; i < n; i++) {
        // Diameter (mm) to be computed
        cl_double d = 0.5 + (cl_double)i * 0.1;
        cl_double d2 = d * d;
        cl_double d3 = d2 * d;
        cl_double d4 = d3 * d;
        cl_double rba = 1.0048 + (0.0057e-1 * d) - (2.628e-2 * d2) + (3.682e-3 * d3) - (1.677e-4 * d4);
        cl_double rab = 1.0f / rba;
        cl_double fsq = rab * rab - 1.0;
        cl_double f = sqrt(fsq);
        cl_double lz = (1.0 + fsq) / fsq * (1.0 - atan(f) / f);
        cl_double lx = (1.0 - lz) * 0.5;
        cl_double vol = M_PI * d3 / 6.0;
        cl_double4 numer = double_complex_multiply((cl_double4){{vol * epsilon_0, 0.0, vol * epsilon_0, 0.0}}, epsilon_r_minus_one);
        cl_double4 denom = {{
            lx * epsilon_r_minus_one.s0 + 1.0,
            lx * epsilon_r_minus_one.s1,
            lz * epsilon_r_minus_one.s2 + 1.0,
            lz * epsilon_r_minus_one.s3
        }};
        cl_double4 alxz = double_complex_divide(numer, denom);
        // Reduced precision at the very last step
        table[i].s0 = (cl_float)(sc * alxz.s0);
        table[i].s1 = (cl_float)(sc * alxz.s1);
        table[i].s2 = (cl_float)(sc * alxz.s2);
        table[i].s3 = (cl_float)(sc * alxz.s3);
        
        #ifdef DEBUG_HEAVY
        rsprint("D = %.2fmm  rba %.4f  rab %.4f  lz %.4f  lx %.4f  numer = %.3e %.3e %.3e %.3e  denom = %.3f %.3f %.3f %.3f  alxz = %.3e %.3e %.3e %.3e  lx/lz = %.3e %.3e %.3e %.3e",
                d, rba, rab, lz, lx, numer.s0, numer.s1, numer.s2, numer.s3, denom.s0, denom.s1, denom.s2, denom.s3, alxz.s0, alxz.s1, alxz.s2, alxz.s3, table[i].s0, table[i].s1, table[i].s2, table[i].s3);
        #endif
    }
    
    // Each size has same probably of occurence, the return power is scaled by the ratio of the
    if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
        
        int k;
        float s;
        const float p = 1.0f / (float)H->dsd_count;
        cl_float4 *table_copy = (cl_float4 *)malloc(n * sizeof(cl_float4));
        memcpy(table_copy, table, n * sizeof(cl_float4));
        memset(table, 0, n * sizeof(cl_float4));

        snprintf(H->summary + strlen(H->summary), sizeof(H->summary), "Drop RCS Scaling:\n");
        for (i = 0; i < H->dsd_count; i++) {
            k = (int)(H->dsd_r[i] * 20000.0f) - 5;
            s = sqrtf(H->dsd_pdf[i] / p);
            if (H->verb) {
                printf(RS_INDENT "o %.2f mm scale by %.4f / %.4f = %.4f = %.2f dB  k = %d\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], p, s, 20.0f * log10f(s), k);
            }
            snprintf(H->summary + strlen(H->summary), sizeof(H->summary), "  o %.2f mm %.5f -> %.2f dB\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], 20.0f * log10f(s));
            table[k].s0 = table_copy[k].s0 * s;
            table[k].s1 = table_copy[k].s1 * s;
            table[k].s2 = table_copy[k].s2 * s;
            table[k].s3 = table_copy[k].s3 * s;
        }

        #ifdef DEBUG_HEAVY
        for (i = 0; i < n; i++) {
            cl_double d = 0.5 + (cl_double)i * 0.1;
            rsprint("D = %.2fmm  %.3e %.3e %.3e %.3e --> %.3e %.3e %.3e %.3e", d, table_copy[i].s0, table_copy[i].s1, table_copy[i].s2, table_copy[i].s3, table[i].s0, table[i].s1, table[i].s2, table[i].s3);
        }
        #endif
        
        free(table_copy);
    }

    // Set table lookup in radius in mm
    RS_set_rcs_ellipsoid_table(H, table, 0.25e-3f, 0.05e-3f, n);
    
    free(table);
}


char *RS_simulation_description(RSHandle *H) {
    char *c = H->summary + strlen(H->summary) - 1;
    if (*c == '\n') {
        *c = 0;
    }
    return H->summary;
}
