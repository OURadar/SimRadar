//
//  rs.c
//  Radar Simulation Framework
//
//  Created by Boon Leng Cheong.
//  Copyright (c) 2015-2016 Boon Leng Cheong. All rights reserved.
//

#include "rs.h"
#include "rs_priv.h"

// The block declaration is automatically generated by XCode
#if defined (_USE_GCL_)
#include "rs.cl.h"
#endif

#define RS_INDENT     "                  "
#define RS_FMT        "%-35s"
#define RS_FMT2       "%-14s"
#define RS_SHOW_DIV   9


#define CHECK_CL_CREATE_KERNEL                                                \
    if (ret != CL_SUCCESS) {                                                  \
        rsprint("ERROR: Could not create OpenCL kernel.  ret = %d\n", ret);   \
        clReleaseProgram(C->prog);                                            \
        clReleaseContext(C->context);                                         \
        return;                                                               \
}

#define CHECK_CL_CREATE_BUFFER                                       \
    if (ret != CL_SUCCESS) {                                         \
        rsprint("ERROR: clCreateBuffer() failed.  ret = %d\n", ret); \
        return;                                                      \
    }



#pragma mark -

// These implementations are very inefficient on CPU; They are coded this way so comparison with the GPU kernel codes can be made easily.
cl_float4 complex_multiply(const cl_float4 a, const cl_float4 b) {
    return (cl_float4){{
        a.s0 * b.s0 - a.s1 * b.s1,
        a.s1 * b.s0 + a.s0 * b.s1,
        a.s2 * b.s2 - a.s3 * b.s3,
        a.s3 * b.s2 + a.s2 * b.s3
    }};
}

cl_float4 complex_divide(const cl_float4 a, const cl_float4 b) {
    float bm01 = b.s0 * b.s0 + b.s1 * b.s1;
    float bm23 = b.s2 * b.s2 + b.s3 * b.s3;
    return (cl_float4){{
        (a.s0 * b.s0 + a.s1 * b.s1) / bm01,
        (a.s1 * b.s0 - a.s0 * b.s1) / bm01,
        (a.s2 * b.s2 + a.s3 * b.s3) / bm23,
        (a.s3 * b.s2 - a.s2 * b.s3) / bm23
    }};
}

cl_double4 double_complex_multiply(const cl_double4 a, const cl_double4 b) {
    return (cl_double4){{
        a.s0 * b.s0 - a.s1 * b.s1,
        a.s1 * b.s0 + a.s0 * b.s1,
        a.s2 * b.s2 - a.s3 * b.s3,
        a.s3 * b.s2 + a.s2 * b.s3
    }};
}

cl_double4 double_complex_divide(const cl_double4 a, const cl_double4 b) {
    double bm01 = b.s0 * b.s0 + b.s1 * b.s1;
    double bm23 = b.s2 * b.s2 + b.s3 * b.s3;
    return (cl_double4){{
        (a.s0 * b.s0 + a.s1 * b.s1) / bm01,
        (a.s1 * b.s0 - a.s0 * b.s1) / bm01,
        (a.s2 * b.s2 + a.s3 * b.s3) / bm23,
        (a.s3 * b.s2 - a.s2 * b.s3) / bm23
    }};
}

void pfn_prog_notify(cl_program program, void *user_data) {
    if (user_data != NULL) {
        rsprint("Program %p returned %p (via pfn_prog_notify)\n", program, user_data);
    }
}


void pfn_notify(const char *errinfo, const void *private_info, size_t cb, void *user_data) {
    fprintf(stderr, "%s : RS : %s (via pfn_notify)\n", now(), errinfo);
}


// CL_DEVICE_TYPE_GPU
void get_device_info(cl_device_type device_type, cl_uint *num_devices, cl_device_id *devices, cl_uint *num_cus, cl_uint *vendors, cl_int detail_level) {
    
    int i = 0, j = 0;
    cl_uint num_platforms = 0;
    cl_uint platform_num_devices = 0;
    
    *num_devices = 0;
    
    cl_platform_id platforms[RS_MAX_GPU_PLATFORM];
    
    char buf_char[RS_MAX_STR];
    cl_uint buf_uint;
    cl_ulong buf_ulong;
    
    int s = 0;
    char str[RS_MAX_STR];

    CL_CHECK(clGetPlatformIDs(RS_MAX_GPU_PLATFORM, platforms, &num_platforms));
    
    if (detail_level)
        s += snprintf(str + s, RS_MAX_STR, "* Number of OpenCL platforms: %d\n", num_platforms);

    for (; i < num_platforms; i++) {
        
        CL_CHECK(clGetDeviceIDs(platforms[i], device_type, RS_MAX_GPU_DEVICE - *num_devices, &devices[*num_devices], &platform_num_devices));
        
        *num_devices += platform_num_devices;
        if (*num_devices >= RS_MAX_GPU_DEVICE) {
            fprintf(stderr, "%s : RS : Sweet. A lot of devices found. Upgrade! Upgrade! Upgrade! \n", now());
            *num_devices = RS_MAX_GPU_DEVICE;
            return;
        }
        
        if (detail_level) {
            s += snprintf(str + s, RS_MAX_STR, "  > PLATFORM %d:\n", i);
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, RS_MAX_STR, buf_char, NULL));
            s += snprintf(str + s, RS_MAX_STR, "    * NAME = %s\n", buf_char);
            if (detail_level > 1) {
                CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, RS_MAX_STR, buf_char, NULL));
                s += snprintf(str + s, RS_MAX_STR, "    * VENDOR = %s\n", buf_char);
            }
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_PROFILE, RS_MAX_STR, buf_char, NULL));
            s += snprintf(str + s, RS_MAX_STR, "    * PROFILE = %s\n", buf_char);
            CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, RS_MAX_STR, buf_char, NULL));
            s += snprintf(str + s, RS_MAX_STR, "    * VERSION = %s\n", buf_char);
            if (detail_level > 2) {
                CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, RS_MAX_STR, buf_char, NULL));
                if (strlen(buf_char)) {
                    char *b = buf_char;
                    while (1) {
                        char *e = strchr(b, ' ');
                        if (e) {
                            *e = '\0';
                        }
                        if (b == buf_char) {
                            s += snprintf(str + s, RS_MAX_STR, "    * EXTENSIONS = %s\n", b);
                        } else {
                            s += snprintf(str + s, RS_MAX_STR, "                   %s\n", b);
                        }
                        if (e) {
                            b = e + 1;
                        } else {
                            break;
                        }
                    }
                }
            }
            s += snprintf(str + s, RS_MAX_STR, "    * Number of OpenCL devices = %d\n", *num_devices);
            
            for (j = 0; j < platform_num_devices; j++) {
                s += snprintf(str + s, RS_MAX_STR, "      > DEVICE %d:\n", j);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_NAME, RS_MAX_STR, buf_char, NULL));
                s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s\n", "CL_DEVICE_NAME", buf_char);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VENDOR, RS_MAX_STR, buf_char, NULL));
                if (strcasestr(buf_char, "intel")) {
                    vendors[j] = RS_GPU_VENDOR_INTEL;
                } else if (strcasestr(buf_char, "nvidia")) {
                    vendors[j] = RS_GPU_VENDOR_NVIDIA;
                } else if (strcasestr(buf_char, "amd")) {
                    vendors[j] = RS_GPU_VENDOR_AMD;
                } else {
                    vendors[j] = RS_GPU_VENDOR_UNKNOWN;
                }
                s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s (%d)\n", "CL_DEVICE_VENDOR", buf_char, vendors[j]);
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
                s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s B\n", "CL_DEVICE_GLOBAL_MEM_SIZE", commaint(buf_ulong));
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
                s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s B\n", "CL_DEVICE_MAX_MEM_ALLOC_SIZE", commaint(buf_ulong));
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
                s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %u\n", "CL_DEVICE_MAX_COMPUTE_UNITS", (unsigned int)num_cus[j]);
                if (detail_level > 1) {
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, RS_MAX_STR, buf_char, NULL));
                    s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s\n", "CL_DEVICE_VERSION", buf_char);
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, RS_MAX_STR, buf_char, NULL));
                    s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s\n", "CL_DRIVER_VERSION", buf_char);
                    CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(buf_uint), &buf_uint, NULL));
                    s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s MHz\n", "CL_DEVICE_MAX_CLOCK_FREQUENCY", commaint(buf_uint));
                    if (detail_level > 2) {
                        size_t work_sizes[3];
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(work_sizes), &work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %zu / %zu / %zu\n", "CL_DEVICE_MAX_WORK_ITEM_SIZES", work_sizes[0], work_sizes[1], work_sizes[2]);
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %zu\n", "CL_DEVICE_MAX_WORK_GROUP_SIZE", work_sizes[0]);
                        clGetDeviceInfo(devices[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s B\n", "CL_DEVICE_LOCAL_MEM_SIZE", commaint(buf_ulong));
                        clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT " = %s B\n\n", "CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE", commaint(buf_ulong));
                        
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "        - " RS_FMT "   " RS_FMT2 " %7s\n", "CL_DEVICE_IMAGE <dim>", "2D_MAX_WIDTH", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "          " RS_FMT "   " RS_FMT2 " %7s\n", "", "2D_MAX_HEIGHT", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "          " RS_FMT "   " RS_FMT2 " %7s\n", "", "3D_MAX_WIDTH", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "          " RS_FMT "   " RS_FMT2 " %7s\n", "", "3D_MAX_HEIGHT", commaint(work_sizes[0]));
                        clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_DEPTH, sizeof(size_t), work_sizes, NULL);
                        s += snprintf(str + s, RS_MAX_STR, "          " RS_FMT "   " RS_FMT2 " %7s\n\n", "", "3D_MAX_DEPTH", commaint(work_sizes[0]));
                    }
                }
            } // for (; j < platform_num_devices; j++)
        } else {
            for (; j < platform_num_devices; j++)
                CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
        }
    } // for (; i < num_platforms; i++)
    printf("%s", str);
}


cl_uint read_kernel_source_from_files(char *src_ptr[], ...) {
    
    static char char_buf[RS_MAX_KERNEL_SRC] = "";
    
    cl_uint count = 0, len = 0;
    
    va_list files;
    
    va_start(files, src_ptr);
    char *filename = va_arg(files, char *);
    while (filename != NULL && strlen(filename) > 0) {
        
#ifdef DEBUG_KERNEL_READ

        rsprint("src '%s' (%d)\n", filename, (int)strlen(filename));

#endif
        
        // Read in the kernel source
        FILE *fid = fopen(filename, "r");
        if (fid == NULL) {
            rsprint("ERROR: Unable to open kernel source %s.\n", filename);
            break;
        }
        while (!feof(fid) && strlen(char_buf) < RS_MAX_KERNEL_SRC && count < RS_MAX_KERNEL_LINES) {
            src_ptr[count] = fgets(char_buf + len, RS_MAX_KERNEL_SRC - len, fid);
            if (src_ptr[count] != NULL) {
                len += strlen(src_ptr[count]) + 1;
                count++;
            }
        }
        fclose(fid);
        
        filename = va_arg(files, char *);
    }
    va_end(files);
    
    if (len >= RS_MAX_KERNEL_SRC * 8 / 10) {
        rsprint("\e[31mWARNING. Kernel source size = %s / %s (%.2f > 80%%)\e[0m\n",
                commaint(len), commaint(RS_MAX_KERNEL_SRC), (float)len / RS_MAX_KERNEL_SRC * 100.0f);
    }
    
    if (len >= RS_MAX_KERNEL_SRC || count >= RS_MAX_KERNEL_LINES) {
        rsprint("ERROR: Kernel source exceeds buffer size constraints.  (len = %s / %s, count = %s / %s)\n",
                commaint(len), commaint(RS_MAX_KERNEL_SRC), commaint(count), commaint(RS_MAX_KERNEL_LINES));
        return 0;
    }
    
#ifdef DEBUG_KERNEL_READ

    printf("%d lines\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d:%s", i, src_ptr[i]);
    }

#endif
    
    return count;
}


ReductionParams *make_reduction_params(cl_uint count, cl_uint user_max_groups, cl_uint user_max_work_items) {
    
    ReductionParams *params = (ReductionParams *)malloc(sizeof(ReductionParams));
    
    if (params == NULL) {
        rsprint("ERROR: Unable to allocate memory for ReductionParams.");
        return NULL;
    }
    
    // Copy these for housekeeping
    params->count = count;
    params->user_max_groups = user_max_groups;
    params->user_max_work_items = user_max_work_items;
    
    // Work items is only count / 2 for small counts
    int work_items = count > 2 * user_max_work_items ? user_max_work_items : count / 2;
    
    // Number of group of item-pairs
    int groups = count / (work_items * 2);
    if (groups > user_max_groups) {
        groups = user_max_groups;
    }
    
    cl_uint levels = 1;
    cl_uint numels = groups;
    
    // First pass to figure out how many levels
    while (numels > 1) {
        int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
        numels = numels / (work_items * 2);
        levels++;
    }
    
    params->pass_counts = levels;
    params->entry_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    params->group_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    params->work_item_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
    
    params->entry_counts[0] = count;
    params->group_counts[0] = groups;
    params->work_item_counts[0] = work_items;
    
    int level = 1;
    
    numels = groups;
    while (numels > 1) {
        int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
        int groups = numels / (work_items * 2);
        if (groups > user_max_groups) {
            groups = user_max_groups;
        }
        
        params->entry_counts[level] = numels;
        params->group_counts[level] = groups;
        params->work_item_counts[level] = work_items;
        
        numels = numels / (work_items * 2);
        level++;
    }
    
    return params;
}


void free_reduction_params(ReductionParams *params) {
    free(params->entry_counts);
    free(params->group_counts);
    free(params->work_item_counts);
    free(params);
}


float read_table(const float *table, const float index_last, const float index) {
    float floor_index = floorf(index);
    float alpha = index - floor_index;
    if (index <= 0.0f) {
        //		printf("%.2f / %.2f --> i = %u  X0\n", index, index_last, 0);
        return table[0];
    } else if (floor_index >= index_last) {
        //		printf("%.2f / %.2f --> i = %u  XM\n", index, index_last, (unsigned int)index_last);
        return table[(unsigned int)index_last];
    }
    unsigned int i = (unsigned int)floor_index;
    //	printf("%.2f / %.2f --> i = %d, %d / %.2f, %.2f  alpha = %.2f  v = %.3f\n", index, index_last, i, i+1,
    //		   table[i], table[i + 1],
    //		   alpha,
    //		   table[i] + alpha * (table[i + 1] - table[i]);
    return table[i] + alpha * (table[i + 1] - table[i]);
}

float zdr(cl_float4 x) {
    return 10.0f * log10f((x.s0 * x.s0 + x.s1 * x.s1) / (x.s2 * x.s2 + x.s3 * x.s3 + 1.0e-20));
}

#pragma mark -
#pragma mark Private Functions

void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, cl_context_properties sharegroup, const char verb) {
    
    C->dev = dev;
    C->verb = verb;
    C->mem_usage = 0;
    
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &C->num_cus, NULL);
    
    CL_CHECK(clGetDeviceInfo(C->dev, CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(C->mem_size), &C->mem_size, NULL));
    
#if defined (_USE_GCL_)

    // A queue & semaphore for the CL work
	rsprint("== GCL ===");
    rsprint("RS_worker_init - gcl_create_dispatch_queue() ...");
    C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_USE_ID, C->dev);
    
//    C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
//    cl_device_id gpu_device = gcl_get_device_id_with_dispatch_queue(C->que);
//    rsprint("Asking for CL_DEVICE_TYPE_GPU gives us: %p vs %p", gpu_device, dev);
    
    C->sem = dispatch_semaphore_create(0);
    C->sem_upload = dispatch_semaphore_create(0);
    
    if (C->sem == NULL || C->sem_upload == NULL) {
        rsprint("Error. Unable to create semaphore for CL workers.\n");
        return;
    }
    
    // Set all the surface to null
    int i;
    for (i = 0; i < RS_MAX_ADM_TABLES; i++) {
        C->surf_adm_cd[i] = NULL;
        C->surf_adm_cm[i] = NULL;
    }
    for (i = 0; i < RS_MAX_RCS_TABLES; i++) {
        C->surf_rcs_real[i] = NULL;
        C->surf_rcs_imag[i] = NULL;
    }
    C->surf_rcs_ellipsoids = NULL;
    C->surf_uvwt[0] = NULL;
    C->surf_uvwt[1] = NULL;
    C->surf_cpxx[0] = NULL;
    C->surf_cpxx[1] = NULL;

#else

    cl_int ret;
    
    if (sharegroup) {
        
#if defined (__APPLE__)
        
        cl_context_properties prop[] = {
            CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE, (cl_context_properties)sharegroup,
            0
        };
        
#else
        
        cl_context_properties prop[] = {
            0
        };
        
        rsprint("ERROR: I do not know how to share GL & CL on this platform.");
        
#endif
        
        // Create a context from a CGL share group
        C->context = clCreateContext(prop, 1, &C->dev, &pfn_notify, NULL, &ret);
        C->sharegroup = sharegroup;
    } else {
        // Create an independent OpenCL context
        C->context = clCreateContext(NULL, 1, &C->dev, &pfn_notify, NULL, &ret);
    }
    
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL context.  ret = %d\n", now(), ret);
        exit(EXIT_FAILURE);
    } else if (verb > 1) {
        rsprint("OpenCL context[%d] created (context @ %p, device_id @ %p).\n", (int)C->name, C->context, dev);
    }
    
    // Program
    C->prog = clCreateProgramWithSource(C->context, src_size, (const char **)src_ptr, NULL, &ret);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : ERROR: Unable to create OpenCL program.  ret = %d\n", now(), ret);
        clReleaseContext(C->context);
        exit(EXIT_FAILURE);
    }
    if (verb) {
        rsprint("clBuildProgram() ... worker[%d]", (int)C->name);
        ret = clBuildProgram(C->prog, 1, &C->dev, "", &pfn_prog_notify, NULL);
    } else {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", NULL, NULL);
    }
    
    if (ret != CL_SUCCESS) {
        char char_buf[RS_MAX_STR] = "";
        clGetProgramBuildInfo(C->prog, C->dev, CL_PROGRAM_BUILD_LOG, RS_MAX_STR, char_buf, NULL);
        fprintf(stderr, "%s : RS : ERROR: CL Compilation failed:\n%s", now(), char_buf);
        clReleaseProgram(C->prog);
        clReleaseContext(C->context);
        exit(EXIT_FAILURE);
    } else if (verb > 1) {
        rsprint("OpenCL program[%d] created (program @ %p).\n", (int)C->name, C->prog);
    }
    
    // Tie all kernels to the program
    C->kern_io = clCreateKernel(C->prog, "io", &ret);                                             CHECK_CL_CREATE_KERNEL
    C->kern_dummy = clCreateKernel(C->prog, "dummy", &ret);                                       CHECK_CL_CREATE_KERNEL
    C->kern_db_rcs = clCreateKernel(C->prog, "db_rcs", &ret);                                     CHECK_CL_CREATE_KERNEL
    C->kern_bg_atts = clCreateKernel(C->prog, "bg_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_fp_atts = clCreateKernel(C->prog, "fp_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_el_atts = clCreateKernel(C->prog, "el_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_db_atts = clCreateKernel(C->prog, "db_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_scat_clr = clCreateKernel(C->prog, "scat_clr", &ret);                                 CHECK_CL_CREATE_KERNEL
    C->kern_scat_sig_aux = clCreateKernel(C->prog, "scat_sig_aux", &ret);                         CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_1 = clCreateKernel(C->prog, "make_pulse_pass_1", &ret);               CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_group = clCreateKernel(C->prog, "make_pulse_pass_2_group", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_local = clCreateKernel(C->prog, "make_pulse_pass_2_range", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_range = clCreateKernel(C->prog, "make_pulse_pass_2_local", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
    
    if (verb > 1) {
        rsprint("Kernels for program[%d] created.\n", (int)C->name);
        if (verb > 2) {
            size_t pref_size;
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_db_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   db_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_el_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   el_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_1()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_group, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_group()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_local, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_local()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_range, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_range()\n", pref_size);
        }
    }
    
    // A queue for the CL work of each device
    C->que = clCreateCommandQueue(C->context, C->dev, 0, &ret);
    if (ret != CL_SUCCESS) {
        rsprint("Creating command queue[%d] failed  (ret = %d).\n", (int)C->name, ret);
    } else if (verb > 1) {
        rsprint("Command queue for context[%d] created.\n", (int)C->name);
    }
    
#endif
    
}


void RS_worker_free(RSWorker *C) {
    
#if defined (_USE_GCL_)
    
    dispatch_release(C->sem);
    dispatch_release(C->que);
    
#else
    
    clReleaseCommandQueue(C->que);
    
    clReleaseKernel(C->kern_io);
    clReleaseKernel(C->kern_dummy);
    clReleaseKernel(C->kern_db_rcs);
    clReleaseKernel(C->kern_bg_atts);
    clReleaseKernel(C->kern_fp_atts);
    clReleaseKernel(C->kern_el_atts);
    clReleaseKernel(C->kern_db_atts);
    clReleaseKernel(C->kern_scat_clr);
    clReleaseKernel(C->kern_scat_sig_aux);
    clReleaseKernel(C->kern_make_pulse_pass_1);
    clReleaseKernel(C->kern_make_pulse_pass_2_group);
    clReleaseKernel(C->kern_make_pulse_pass_2_local);
    clReleaseKernel(C->kern_make_pulse_pass_2_range);
    
    clReleaseProgram(C->prog);
    
    clReleaseContext(C->context);
    
#endif
    
}


void RS_worker_malloc(RSHandle *H, const int worker_id) {
    
    RSWorker *C = &H->workers[worker_id];
    
    if (C == NULL) {
        rsprint("Worker[%d] has not been initialized?\n", worker_id);
        return;
    }
    
    if ((H->status & RSStatusPopulationDefined) == 0) {
        rsprint("ERROR: Population has not been defined.\n");
        return;
    }
    
    // Derive the necessary parameters from host to compute workers
    if (C->num_scats != H->num_scats / MAX(1, H->num_workers)) {
        rsprint("ERROR: Inconsistent number of scatterers.\n");
        return;
    }
    
    size_t group_size_multiple = RS_CL_GROUP_ITEMS;
    
#if !defined (_USE_GCL_)
    
    clGetKernelWorkGroupInfo(C->kern_dummy, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(group_size_multiple), &group_size_multiple, NULL);
    
#endif
    
    if (group_size_multiple > RS_CL_GROUP_ITEMS) {
        rsprint("ERROR: Potential memory leak. work_items(%d) > RS_CL_GROUP_ITEMS(%d).\n", now(), (int)group_size_multiple, RS_CL_GROUP_ITEMS);
        exit(EXIT_FAILURE);
    }
    
    size_t max_work_group_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    
    cl_ulong local_mem_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &local_mem_size, NULL);
    
    if (H->verb > 2) {
        rsprint("CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %zu", group_size_multiple);
        rsprint("CL_DEVICE_MAX_WORK_GROUP_SIZE = %zu", (int)max_work_group_size);
        rsprint("CL_DEVICE_LOCAL_MEM_SIZE = %zu", (size_t)local_mem_size);
    }
    
    C->make_pulse_params = RS_make_pulse_params((cl_uint)C->num_scats,
                                                (cl_uint)group_size_multiple,
                                                (cl_uint)max_work_group_size,
                                                (cl_uint)local_mem_size,
                                                H->params.range_start,
                                                H->params.range_delta,
                                                H->params.range_count);
    
    const unsigned long work_numel = C->make_pulse_params.global[0] * C->make_pulse_params.local[0] * H->params.range_count;
    
#if defined (_USE_GCL_)
    
    // printf("Creating cl_mem from vbo ... %d %d %d \n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);
    C->scat_pos = gcl_gl_create_ptr_from_buffer(C->vbo_scat_pos);
    if (C->scat_pos == NULL) {
        rsprint("ERROR: gcl_gl_create_ptr_from_buffer() failed for scat_pos.\n");
        C->scat_pos = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_clr = gcl_gl_create_ptr_from_buffer(C->vbo_scat_clr);
    if (C->scat_clr == NULL) {
        rsprint("ERROR: gcl_gl_create_ptr_from_buffer() failed for scat_clr.\n");
        C->scat_clr = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_ori = gcl_gl_create_ptr_from_buffer(C->vbo_scat_ori);
    if (C->scat_ori == NULL) {
        rsprint("ERROR: gcl_gl_create_ptr_from_buffer() failed for scat_ori.\n");
        C->scat_ori = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    
    C->scat_vel = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_tum = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_aux = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_rcs = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_sig = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->work = gcl_malloc(work_numel * sizeof(cl_float4), NULL, 0);
    C->pulse = gcl_malloc(H->params.range_count * sizeof(cl_float4), NULL, 0);
    
    C->scat_rnd = gcl_malloc(C->num_scats * sizeof(cl_int4), NULL, 0);
    
    C->mem_size += (8 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_uint4);
    
#else
    
    cl_int ret;
    
    //printf("shared_vbo: %d %d %d\n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);
    
    size_t numel = ((C->num_scats + group_size_multiple - 1) / group_size_multiple) * group_size_multiple;
    
    //printf("numel = %zu  num_scats = %zu\n", numel, C->num_scats);
    
    if (H->has_vbo_from_gl) {
        C->scat_pos = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_pos, &ret);
        C->scat_clr = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_clr, &ret);
        C->scat_ori = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_ori, &ret);
        if (C->scat_pos == NULL || C->scat_clr == NULL || C->scat_ori == NULL || ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error in clCreateFromGLBuffer().  ret = %d\n", now(), ret);
            exit(EXIT_FAILURE);
        }
    } else {
        C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
        C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
        C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                  CHECK_CL_CREATE_BUFFER
    }
    
    C->scat_vel = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_tum = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_aux = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_rcs = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_sig = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
    C->scat_rnd = clCreateBuffer(C->context, CL_MEM_READ_WRITE, numel * sizeof(cl_int4), NULL, &ret);                        CHECK_CL_CREATE_BUFFER
    C->work     = clCreateBuffer(C->context, CL_MEM_READ_WRITE, work_numel * sizeof(cl_float4), NULL, &ret);                 CHECK_CL_CREATE_BUFFER
    C->pulse    = clCreateBuffer(C->context, CL_MEM_READ_WRITE, H->params.range_count * sizeof(cl_float4), NULL, &ret);      CHECK_CL_CREATE_BUFFER
    
    // Set some components to zero
    cl_float4 *zeros = (cl_float4 *)malloc(numel * sizeof(cl_float4));
    memset(zeros, 0, numel * sizeof(cl_float4));
    clEnqueueWriteBuffer(C->que, C->scat_aux, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    clEnqueueWriteBuffer(C->que, C->scat_rcs, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    clEnqueueWriteBuffer(C->que, C->scat_sig, CL_TRUE, 0, numel * sizeof(cl_float4), zeros, 0, NULL, NULL);
    free(zeros);
    
    C->mem_usage += (8 * numel + work_numel + H->params.range_count) * sizeof(cl_float4) + numel * sizeof(cl_uint4);
    
    //
    // Set up kernel's input / output arguments
    //
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_io, 0, sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_io, 1, sizeof(cl_mem), &C->scat_aux);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel io().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_dummy, 0, sizeof(cl_mem), &C->scat_pos);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel dummy().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
    ret |= clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_rcs().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->les_uvwt[0]);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure,         sizeof(cl_mem),     &C->les_cpxx[0]);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundDescription,         sizeof(cl_float16), &C->les_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCS,                  sizeof(cl_mem),     &C->rcs_ellipsoid);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCSDescription,       sizeof(cl_float4),  &C->rcs_ellipsoid_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_bg_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->les_uvwt[0]);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure,         sizeof(cl_mem),     &C->les_cpxx[0]);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentBackgroundDescription,         sizeof(cl_float16), &C->les_desc);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCS,                  sizeof(cl_mem),     &C->rcs_ellipsoid);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCSDescription,       sizeof(cl_float4),  &C->rcs_ellipsoid_desc);
    ret |= clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_fp_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->les_uvwt[0]);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure,         sizeof(cl_mem),     &C->les_cpxx[0]);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentBackgroundDescription,         sizeof(cl_float16), &C->les_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCS,                  sizeof(cl_mem),     &C->rcs_ellipsoid);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentEllipsoidRCSDescription,       sizeof(cl_float4),  &C->rcs_ellipsoid_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_el_atts().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentTumble,                        sizeof(cl_mem),     &C->scat_tum);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->les_uvwt[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->les_desc);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_atts().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentColor,             sizeof(cl_mem),   &C->scat_clr);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentPosition,          sizeof(cl_mem),   &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentAuxiliary,         sizeof(cl_mem),   &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentRadarCrossSection, sizeof(cl_mem),   &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode,          sizeof(cl_uint4), &H->draw_mode);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_clr().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSignal,                 sizeof(cl_mem),     &C->scat_sig);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentAuxiliary,              sizeof(cl_mem),     &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentPosition,               sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentRadarCrossSection,      sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTable,            sizeof(cl_mem),     &C->angular_weight);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTableDescription, sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription,  sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_sig_aux().\n", now());
        exit(EXIT_FAILURE);
    }
    
    if (C->verb > 1) {
        rsprint("Pass 1   global =%7s   local = %3zu x %2d = %6s B   groups = %4d   N = %9s\n",
                commaint(C->make_pulse_params.global[0]),
                C->make_pulse_params.local[0],
                C->make_pulse_params.range_count,
                commaint(C->make_pulse_params.local_mem_size[0]),
                C->make_pulse_params.group_counts[0],
                commaint(C->make_pulse_params.entry_counts[0]));
    }
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 0, sizeof(cl_mem),                         &C->work);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 1, sizeof(cl_mem),                         &C->scat_sig);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 2, sizeof(cl_mem),                         &C->scat_aux);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 3, C->make_pulse_params.local_mem_size[0], NULL);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 4, sizeof(cl_mem),                         &C->range_weight);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 5, sizeof(cl_float4),                      &C->range_weight_desc);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 6, sizeof(float),                          &C->make_pulse_params.range_start);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 7, sizeof(float),                          &C->make_pulse_params.range_delta);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 8, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 9, sizeof(unsigned int),                   &C->make_pulse_params.group_counts[0]);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 10, sizeof(unsigned int),                  &C->make_pulse_params.entry_counts[0]);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_1().\n", now());
        exit(EXIT_FAILURE);
    }
    
    if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL) {
        C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_local;
    } else if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE) {
        C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_range;
    } else {
        C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
    }
    
    if (C->verb > 1) {
        rsprint("Pass 2   global =%7s   local = %3zu x %2lu = %6s B   groups = %3d%s   N = %9s\n",
                commaint(C->make_pulse_params.global[1]),
                C->make_pulse_params.local[1],
                C->make_pulse_params.local_mem_size[1] / C->make_pulse_params.local[1] / sizeof(cl_float4),
                commaint(C->make_pulse_params.local_mem_size[1]),
                C->make_pulse_params.group_counts[1],
                C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE ? "R" :
                (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL ? "L" : "U"),
                commaint(C->make_pulse_params.entry_counts[1]));
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 0, sizeof(cl_mem),                         &C->pulse);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 1, sizeof(cl_mem),                         &C->work);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 2, C->make_pulse_params.local_mem_size[1], NULL);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 3, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 4, sizeof(unsigned int),                   &C->make_pulse_params.entry_counts[1]);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_2().\n", now());
        exit(EXIT_FAILURE);
    }
    
#endif
    
    if (C->mem_usage > C->mem_size / 4 * 3) {
        rsprint("WARNING: High GPU memory usage by workers[%d]: %s GB out of %s GB.", C->name, commafloat((float)C->mem_usage * 1.0e-9f), commafloat((float)C->mem_size * 1.0e-9f));
    }
    if (C->verb) {
        rsprint("workers[%d] memory usage = %s B\n", C->name, commaint(C->mem_usage));
    }
}

void RS_update_computed_properties(RSHandle *H) {
    H->params.prf = 1.0f / H->params.prt;
    H->params.va = 0.25f * H->params.lambda * H->params.prf;
    H->params.fn = 0.5 / H->params.prf;
    H->params.antenna_bw_rad = H->params.antenna_bw_deg / 180.0f * M_PI;
    H->params.dr = 0.5f * H->params.c * H->params.tau;
}

#pragma mark -
#pragma mark RS Convenient functions

cl_uint RS_gpu_count(void) {
    cl_uint          num_devs;
    cl_device_id     devs[RS_MAX_GPU_DEVICE];
    cl_uint          num_cus[RS_MAX_GPU_DEVICE];
    cl_uint          vendors[RS_MAX_GPU_DEVICE];
    get_device_info(CL_DEVICE_TYPE_GPU, &num_devs, devs, num_cus, vendors, 0);
    return num_devs;
}

#pragma mark -
#pragma mark RS Initialization and Deallocation


RSHandle *RS_init_with_path(const char *bundle_path, RSMethod method, cl_context_properties sharegroup, const char verb) {
    
    int i;
    
    RSHandle *H;
    
    // Allocate
    if (posix_memalign((void **)((uintptr_t)&H), RS_ALIGN_SIZE, sizeof(RSHandle))) {
        rsprint("ERROR: Unable to initialize RS Framework.");
        return NULL;
    }
    memset(H, 0, sizeof(RSHandle));
    
    // Default non-zero parameters
    H->sim_tic = 0.0f;
    H->status = RSStatusNull;
    H->params.c = 3.0e8f;
    H->params.tau = 0.2e-6f;
    H->params.body_per_cell = RS_BODY_PER_CELL;
    H->params.domain_pad_factor = RS_DOMAIN_PAD;
    H->num_workers = 1;
    H->num_types = 1;
    H->method = method;
    H->random_seed = 19760520;
    
    for (i = 0; i < RS_MAX_GPU_DEVICE; i++) {
        H->workers[i].name = i;
    }
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        H->counts[i] = 0;
    }
    
    if (H->method == RS_METHOD_GPU) {
        if (verb) {
            rsprint("Getting CL devices ...");
        }
        // Get and show some device info
        get_device_info(CL_DEVICE_TYPE_GPU, &H->num_devs, H->devs, H->num_cus, H->vendors, verb);
    } else if (H->method == RS_METHOD_CPU) {
        // Run this to get the num_cus to the same values.
        get_device_info(CL_DEVICE_TYPE_CPU, &H->num_devs, H->devs, H->num_cus, H->vendors, 0);
    }
    if (H->num_devs == 0 || H->num_cus[0] == 0) {
        rsprint("ERROR: No OpenCL devices found.");
        return NULL;
    }
    
    H->num_workers = H->num_devs;
    switch (H->vendors[0]) {
        case RS_GPU_VENDOR_AMD:
        case RS_GPU_VENDOR_INTEL:
            H->preferred_multiple = H->num_cus[0] * 16;
            break;
        case RS_GPU_VENDOR_NVIDIA:
            H->preferred_multiple = H->num_cus[0] * 64;
            break;
        default:
            H->preferred_multiple = H->num_cus[0] * 256;
            break;
    }
    
#if defined (GUI)
    
    // Force to one GPU at the moment. Seems like OpenGL context can be shared with only one OpenCL context
    H->num_workers = 1;

#endif
    
#if defined (_USE_GCL_)
    
    H->num_workers = 1;
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        //RS_worker_init(&H->workers[i], H->devs[i], 0, NULL, 0, verb);
        RS_worker_init(&H->workers[i], H->devs[i], 0, NULL, sharegroup, verb);
    }
    
#else
    
    cl_uint count;
    char *src_ptr[RS_MAX_KERNEL_LINES];
    
    // Kernel source
    if (!strcmp(bundle_path, ".")) {
        count = read_kernel_source_from_files(src_ptr, "rs.cl", NULL);
    } else {
        
#ifdef INCLUDE_TYPES_IN_KERNEL
        
        // This version combines special types along with the kernel functions
        char types_h_path[RS_MAX_STR];
        char kern_src_path[RS_MAX_STR];
        snprintf(types_h_path, RS_MAX_STR, "%s/rs_types.h", bundle_path);
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, types_h_path, kern_src_path, NULL);
        
#else
        
        // This version does not depend on custom types
        char kern_src_path[RS_MAX_STR];
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, kern_src_path, NULL);
        
#endif
        
    }
    
    if (count == 0) {
        rsprint("Empty kernel source.");
        return NULL;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        RS_worker_init(&H->workers[i], H->devs[i], count, (const char **)src_ptr, sharegroup, verb);
    }
    
#endif
    
    // Temporary supress the verbose output for setting default values; or very verbosy for heavy debug version

#if defined(DEBUG_HEAVY)
    
    H->verb = 3;

#else

    H->verb = verb > 1 ? verb : 0;

#endif
    
    // Set up some basic parameters to default values, H->verb is still 0 so no API message output
    RS_set_prt(H, RS_PARAMS_PRT);
    
    RS_set_lambda(H, RS_PARAMS_LAMBDA);
    
    RS_set_antenna_params(H, RS_PARAMS_BEAMWIDTH, 50.0f);
    
    RS_set_tx_params(H, RS_PARAMS_TAU, 50.0e3f);
    
    RS_set_beam_pos(H, 5.0f, 1.0f);
    
    RS_set_sampling_spacing(H, RS_PARAMS_GATEWIDTH, RS_PARAMS_BEAMWIDTH, RS_PARAMS_BEAMWIDTH);

    H->verb = verb;
    
    return H;
}


RSHandle *RS_init_for_cpu_verbose(const char verb) {
    return RS_init_with_path(".", RS_METHOD_CPU, 0, verb);
}


RSHandle *RS_init_verbose(const char verb) {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, verb);
}


RSHandle *RS_init() {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, 0);
}


void RS_free_scat_memory(RSHandle *H) {
    int i;
    
    if (H->verb > 2) {
        rsprint("Freeing GPU memories ...");
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].vbo_scat_pos == 0) {
            rsprint("ERROR: Unexpected conditions. VBOs were not shared.");
            return;
        }
        gcl_free(H->workers[i].scat_pos);
        gcl_free(H->workers[i].scat_clr);  // Only the GUI version has this
        gcl_free(H->workers[i].scat_vel);
        gcl_free(H->workers[i].scat_ori);
        gcl_free(H->workers[i].scat_tum);
        gcl_free(H->workers[i].scat_aux);
        gcl_free(H->workers[i].scat_rcs);
        gcl_free(H->workers[i].scat_sig);
        gcl_free(H->workers[i].work);
        gcl_free(H->workers[i].pulse);
        gcl_free(H->workers[i].scat_rnd);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clReleaseMemObject(H->workers[i].scat_pos);
        clReleaseMemObject(H->workers[i].scat_clr);
        clReleaseMemObject(H->workers[i].scat_vel);
        clReleaseMemObject(H->workers[i].scat_ori);
        clReleaseMemObject(H->workers[i].scat_tum);
        clReleaseMemObject(H->workers[i].scat_aux);
        clReleaseMemObject(H->workers[i].scat_rcs);
        clReleaseMemObject(H->workers[i].scat_sig);
        clReleaseMemObject(H->workers[i].work);
        clReleaseMemObject(H->workers[i].pulse);
        clReleaseMemObject(H->workers[i].scat_rnd);
    }
    
#endif
    
    if (H->verb > 2) {
        rsprint("Freeing CPU memories ...");
    }
    
    free(H->scat_pos);
    free(H->scat_vel);
    free(H->scat_ori);
    free(H->scat_tum);
    free(H->scat_aux);
    free(H->scat_rcs);
    free(H->scat_sig);
    free(H->scat_rnd);
    
    free(H->pulse);
    
    for (i = 0; i < H->num_workers; i++) {
        free(H->pulse_tmp[i]);
    }
}


void RS_free(RSHandle *H) {
    
    int i;
    
    char v = H->verb;
    
    LES_free(H->L);
    
    if (H->O) {
        OBJ_free(H->O);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        RS_worker_free(&H->workers[i]);
    }
    
    RS_free_scat_memory(H);
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        gcl_free(H->workers[i].angular_weight);
        gcl_free(H->workers[i].range_weight);
        
        gcl_release_image(H->workers[i].rcs_ellipsoid);
        gcl_release_image(H->workers[i].les_uvwt[0]);
        gcl_release_image(H->workers[i].les_uvwt[1]);
        
        for (int a = 0; a < H->adm_count; a++) {
            gcl_release_image(H->workers[i].adm_cd[a]);
            gcl_release_image(H->workers[i].adm_cm[a]);
        }
        
        for (int r = 0; r < H->rcs_count; r++) {
            gcl_release_image(H->workers[i].rcs_real[r]);
            gcl_release_image(H->workers[i].rcs_imag[r]);
        }
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clReleaseMemObject(H->workers[i].angular_weight);
        clReleaseMemObject(H->workers[i].range_weight);
        
        clReleaseMemObject(H->workers[i].rcs_ellipsoid);
        clReleaseMemObject(H->workers[i].les_uvwt[0]);
        clReleaseMemObject(H->workers[i].les_uvwt[1]);
        
        for (int a = 0; a < H->adm_count; a++) {
            clReleaseMemObject(H->workers[i].adm_cd[a]);
            clReleaseMemObject(H->workers[i].adm_cm[a]);
        }
        
        for (int r = 0; r < H->rcs_count; r++) {
            clReleaseMemObject(H->workers[i].rcs_real[r]);
            clReleaseMemObject(H->workers[i].rcs_imag[r]);
        }
    }
    
#endif
    
    free(H->anchor_pos);
    free(H->anchor_lines);
    
    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
        free(H->dsd_pop);
    }
    
    free(H);
    
    if (v) {
        rsprint("Resources released.");
    }
}


RSMakePulseParams RS_make_pulse_params(const cl_uint count,
                                       const cl_uint group_size_multiple,
                                       const cl_uint user_max_groups,
                                       const cl_uint max_local_mem_size,
                                       const float range_start,
                                       const float range_delta,
                                       const unsigned int range_count) {
    RSMakePulseParams param;
    
    // Keep a copy for reference
    param.num_scats = count;
    param.user_max_groups = user_max_groups;
    param.user_max_work_items = group_size_multiple;
    param.range_start = range_start;
    param.range_delta = range_delta;
    param.range_count = MAX(1, range_count);
    
    // The 2nd pass kernel functions are only for work_items <= 1024.
    if (user_max_groups > 1024) {
        fprintf(stderr, "%s : RS : I'm not programmed to handle user_max_groups > 1024.\n", now());
        param.user_max_groups = 1024;
    }
    
    // Work items is at most count / 2
    unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : count / 2;
    //unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : (count + 1) / 2;
    
    // Number of group item-pairs
    //unsigned int group_count = count <= work_items * 2 ? 1 : count / (work_items * 2);
    unsigned int group_count = count <= work_items * 2 ? 1 : (count + work_items * 2 - 1) / (work_items * 2);
    if (group_count > param.user_max_groups) {
        group_count = param.user_max_groups;
    }
    
    // printf("RS_make_pulse_params()   count=%d  work_items=%d  group_count=%d/%d\n", count, work_items, group_count, param.user_max_groups);
    
    // 1st pass
    param.entry_counts[0] = count;
    param.group_counts[0] = group_count;
    param.global[0] = group_count * work_items;
    param.local[0] = work_items;
    param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
    while (param.local_mem_size[0] > max_local_mem_size) {
        #ifdef DEBUG_CL
        rsprint("Local memory size = %s. Adjusting ...", commaint((long long)max_local_mem_size));
        #endif
        if (range_count % 2 == 0) {
            work_items /= 2;
            group_count *= 2;
            if (group_count > param.user_max_groups) {
                group_count = param.user_max_groups;
            }
            param.group_counts[0] = group_count;
            param.global[0] = group_count * work_items;
            param.local[0] = work_items;
            param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
        } else {
            rsprint("ERROR: Could not resolve local memory size limits.");
            exit(EXIT_FAILURE);
        }
    }
    
    // 2nd pass
    unsigned int work_count = group_count * param.range_count;
    
    param.entry_counts[1] = work_count;
    work_items = work_count / (param.range_count * 2);
    if (work_items < 1) {
        fprintf(stderr, "%s : RS : 2nd pass with CL work_items = %u < 2?\n", now(), work_items);
        work_items = 1;
    }
    
    if (param.local[0] % param.range_count == 0 && group_size_multiple >= work_items) {
        //
        param.cl_pass_2_method = RS_CL_PASS_2_UNIVERSAL;
        param.group_counts[1] = 1;
        param.global[1] = work_items;
        param.local[1] = work_items;
        param.local_mem_size[1] = work_items * sizeof(cl_float4);
        
    } else if (group_count >= 2 * param.range_count && group_size_multiple >= work_items) {
        //
        param.cl_pass_2_method = RS_CL_PASS_2_IN_LOCAL;
        param.group_counts[1] = 1;
        param.global[1] = work_items;
        param.local[1] = work_items;
        param.local_mem_size[1] = work_items * sizeof(cl_float4);
        
    } else {
        //
        param.cl_pass_2_method = RS_CL_PASS_2_IN_RANGE;
        param.group_counts[1] = 1;
        param.global[1] = param.range_count;
        param.local[1] = 1;
        param.local_mem_size[1] = sizeof(cl_float4);
        
    }
    if (param.entry_counts[1] > RS_MAX_GATES * work_items) {
        fprintf(stderr, "%s : RS : H->dev_work may not be large enough.\n", now());
    }
    return param;
}


#pragma mark -
#pragma mark Properties

void RS_set_concept(RSHandle *H, RSSimulationConcept c) {
    H->sim_concept = c;
}


char *RS_simulation_concept_string(RSHandle *H) {
    static char string[32];
    sprintf(string,
            "Concepts used: %s%s%s%s%s%s",
            H->sim_concept & RSSimulationConceptBoundedParticleVelocity ? "B" : "",
            H->sim_concept & RSSimulationConceptDraggedBackground ? "D" : "",
            H->sim_concept & RSSimulationConceptFixedScattererPosition ? "F" : "",
            H->sim_concept & RSSimulationConceptTransparentBackground ? "T" : "",
            H->sim_concept & RSSimulationConceptUniformDSDScaledRCS ? "U" : "",
            H->sim_concept & RSSimulationConceptVerticallyPointingRadar ? "V" :"");
    return string;
}


char *RS_simulation_concept_bulleted_string(RSHandle *H) {
    static char string[1024];
    sprintf(string, "Concepts used:\n");
    if (H->sim_concept & RSSimulationConceptBoundedParticleVelocity) {
        sprintf(string + strlen(string), RS_INDENT "o B - Bounded Particle Velocity\n");
    }
    if (H->sim_concept & RSSimulationConceptDraggedBackground) {
        sprintf(string + strlen(string), RS_INDENT "o D - Dragged Meteorological Scatterers\n");
    }
    if (H->sim_concept & RSSimulationConceptFixedScattererPosition) {
        sprintf(string + strlen(string), RS_INDENT "o F - Fixed Scatterer Positions\n");
    }
    if (H->sim_concept & RSSimulationConceptTransparentBackground) {
        sprintf(string + strlen(string), RS_INDENT "o T - Transparent Meteorological Scatterers\n");
    }
    if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
        sprintf(string + strlen(string), RS_INDENT "o U - Uniform DSD with Scaled RCS\n");
    }
    if (H->sim_concept & RSSimulationConceptVerticallyPointingRadar) {
        sprintf(string + strlen(string), RS_INDENT "o V - Vertically Pointing Radar\n");
    }
    return string;
}

void RS_set_prt(RSHandle *H, const RSfloat prt) {
    
    //    RSfloat tic_toc_left = H->sim_toc - H->sim_tic;
    //
    //    RSfloat toc_offset = H->params.prt / prt * tic_toc_left;
    //
    //    if (tic_toc_left + toc_offset < 0) {
    //        H->sim_tic = 0;
    //        H->sim_toc = (size_t)(H->vel_desc.tp / prt);
    //    } else {
    //        H->sim_toc += toc_offset;
    //    }
    
    H->params.prt = prt;
    
    H->sim_desc.s[RSSimulationDescriptionPRT] = H->params.prt;
    
    RS_update_computed_properties(H);
}


void RS_set_lambda(RSHandle *H, const RSfloat lambda) {
    H->params.lambda = lambda;
    
    H->sim_desc.s[RSSimulationDescriptionWaveNumber] = 4.0f * M_PI / H->params.lambda;
    
    RS_update_computed_properties(H);
}


void RS_set_density(RSHandle *H, const RSfloat density) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Density cannot be changed.");
        return;
    }
    //    if (H->status & RSStatusPopulationDefined) {
    //        rsprint("ERROR: Population already defined. RS_set_density() should come before RS_set_scan_box().\n");
    //        exit(EXIT_FAILURE);
    //    }
    H->params.body_per_cell = density;
    
    RS_update_computed_properties(H);
}


void RS_set_antenna_params(RSHandle *H, RSfloat beamwidth_deg, RSfloat gain_dbi) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar antenna parameters cannot be changed.");
        return;
    }
    H->params.antenna_bw_deg = beamwidth_deg;
    H->params.antenna_gain_dbi = gain_dbi;
    
    RS_update_computed_properties(H);
    
    RS_set_angular_weight_to_standard(H, H->params.antenna_bw_rad);
}


void RS_set_tx_params(RSHandle *H, RSfloat pulsewidth, RSfloat tx_power_watt) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar parameters cannot be changed.");
        return;
    }
    H->params.tau = pulsewidth;
    H->params.tx_power_watt = tx_power_watt;
    
    RS_update_computed_properties(H);
    
    RS_set_range_weight_to_triangle(H, H->params.dr);
}


void RS_set_sampling_spacing(RSHandle *H, const RSfloat range, const RSfloat azimuth, const RSfloat elevation) {
    H->params.range_delta = range;
    H->params.azimuth_delta_deg = azimuth;
    H->params.elevation_delta_deg = elevation;
}


void RS_set_scan_box(RSHandle *H, RSBox box) {
    if (H->params.range_delta == 0.0f) {
        H->params.range_delta = RS_PARAMS_GATEWIDTH;
    }
    if (H->params.azimuth_delta_deg == 0.0f) {
        H->params.azimuth_delta_deg = RS_PARAMS_BEAMWIDTH;
    }
    if (H->params.elevation_delta_deg == 0.0f) {
        H->params.elevation_delta_deg = RS_PARAMS_BEAMWIDTH;
    }
    RS_set_scan_extent(H,
                       box.origin.r, box.origin.r + box.size.r, H->params.range_delta,            // Range
                       box.origin.a, box.origin.a + box.size.a, H->params.azimuth_delta_deg,      // Azimuth
                       box.origin.e, box.origin.e + box.size.e, H->params.elevation_delta_deg);   // Elevation
}

// This method also suggests number of scatterer to be used based on the scatterer / resolution volume rule.
void RS_set_scan_extent(RSHandle *H,
                        RSfloat range_start, RSfloat range_end, RSfloat range_delta,
                        RSfloat azimuth_start, RSfloat azimuth_end, RSfloat azimuth_delta,
                        RSfloat elevation_start, RSfloat elevation_end, RSfloat elevation_delta) {

    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Scan box cannot be changed.");
        return;
    }
    
    //rsprint("%.2f  %.2f  %.2f  /  %.2f  %.2f  %.2f\n", azimuth_start, azimuth_end, azimuth_delta, elevation_start, elevation_end, elevation_delta);
    
    //	H->status &= !RSStatusDomainPopulated;
    H->params.range_start = range_start;
    H->params.range_end = range_end;
    H->params.range_delta = range_delta;
    H->params.azimuth_start_deg = azimuth_start;
    H->params.azimuth_end_deg = azimuth_end;
    H->params.azimuth_delta_deg = azimuth_delta;
    H->params.elevation_start_deg = elevation_start;
    H->params.elevation_end_deg = elevation_end;
    H->params.elevation_delta_deg = elevation_delta;
    
    bool is_full_sweep = fabs(azimuth_start - 0.0f) < 0.01f && fabs(azimuth_end - 360.0f) < 0.01f;
    
    const RSfloat r_lo = floor(MAX(H->params.range_delta, H->params.range_start - H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
    const RSfloat r_hi = ceil(MIN(10.0e3f, H->params.range_end + H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
    const RSfloat az_lo = is_full_sweep ? 0.0f : floor(H->params.azimuth_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg * H->params.antenna_bw_deg;
    const RSfloat az_hi = is_full_sweep ? 360.0f : ceil(H->params.azimuth_end_deg + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg * H->params.antenna_bw_deg;
    const RSfloat el_lo = floor(MAX(0.0f, H->params.elevation_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
    const RSfloat el_hi = ceil(MIN(90.0f, H->params.elevation_end_deg + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
    const RSfloat tiny = 1.0e-5f;
    
//    printf("range_start = %.2f   r_lo = %.2f   %.2f   %.2f  %.1f  ... %.2f\n",
//           H->params.range_start, r_lo, H->params.dr, H->params.range_delta, H->params.domain_pad_factor,
//           MAX(H->params.range_delta, H->params.range_start - H->params.domain_pad_factor * H->params.dr));
    
    int nr = 0;
    int naz = 0;
    int nel = 0;
    
    RSfloat
    xmin = INFINITY, xmax = -INFINITY,
    ymin = INFINITY, ymax = -INFINITY,
    zmin = INFINITY, zmax = -INFINITY;

    RSfloat r;
    RSfloat az;
    RSfloat el;
    
    int ii = 0;
    
    if (H->verb) {
        rsprint("Deriving scan box ... BW %.2f deg   DR %.2f m\n", H->params.antenna_bw_deg, H->params.range_delta);
    }

    // Range
    r = floor(H->params.range_start / H->params.range_delta) * H->params.range_delta;
    while (r <= ceil(H->params.range_end / H->params.range_delta) * H->params.range_delta) {
        r += H->params.range_delta;
        nr++;
    }
    H->params.range_count = MIN(RS_MAX_GATES, nr);
    if (H->verb > 1) {
        rsprint("  o Domain range ... %.2f ~ %.2f (%d)\n", r_lo, r_hi, nr);
    }

    if (H->sim_concept & RSSimulationConceptVerticallyPointingRadar) {
        const RSfloat delta = MIN(elevation_delta, azimuth_delta);
        const RSfloat edge = el_lo;
        // Raster grid for AZ, EL
        if (H->verb) {
            rsprint("Spherical grid for a profiler: xx / yy = [ %.2f ... %.2f ] deg\n", edge - 90.0f, 90.0f - edge);
        }
        RSfloat xx;
        RSfloat yy = edge - 90.0f;
        while (yy < (90.0f - edge) + tiny) {
            xx = el_lo - 90.0f;
            while (xx < (90.0f - edge) + tiny) {
                az = atan2f(yy, xx);
                el = 90.0f - sqrtf(yy * yy + xx * xx);
                #if defined(DEBUG_POS)
                rsprint("ii %d   xx = %.2f  yy = %.2f  AZ %.2f   EL %.2f\n", naz, xx, yy, az, el);
                #endif
                xx += delta;
                ii++;
            }
            yy += delta;
        }

        // Total number of anchors, add one for radar origin
        H->num_anchors  = 2 * ii + 1;
        if (H->anchor_pos) {
            if (H->verb > 2) {
                rsprint("Freeing existing anchor memory.");
            }
            free(H->anchor_pos);
        }
        H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
        if (H->anchor_pos == NULL) {
            rsprint("ERROR: Unable to allocate memory for anchors.");
            return;
        }

        // Now populate an actual array
        ii = 0;
        yy = edge - 90.0f;
        while (yy < (90.0f - edge) + tiny) {
            xx = edge - 90.0f;
            while (xx < (90.0f - edge) + tiny) {
                az = atan2f(yy, xx);
                el = 90.0f - sqrtf(yy * yy + xx * xx);
        
                #if defined(DEBUG_POS)
                rsprint("ii %d   xx = %.2f  yy = %.2f  AZ %.2f   EL %.2f\n", ii, xx, yy, az, el);
                #endif

                el = el / 180.0f * M_PI;
                
                H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
                H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
                H->anchor_pos[ii].z = r_lo * sin(el);
                H->anchor_pos[ii].w = 1.0f;
                xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
                xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
                ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
                ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
                zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
                zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
                ii++;
                
                H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
                H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
                H->anchor_pos[ii].z = r_hi * sin(el);
                H->anchor_pos[ii].w = 1.0f;
                xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
                xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
                ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
                ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
                zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
                zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
                ii++;
                
                xx += delta;
            }
            yy += delta;
        }
        
        naz = 360;
        nel = 1;
        
        if (H->P) {
            POSPattern *pattern = (POSPattern *)H->P;
            nel = pattern->count;
        }

    } else {
        // Azimuth
        az = az_lo;
        while (az <= az_hi + tiny) {
            az += H->params.azimuth_delta_deg;
            naz++;
        }
        if (H->verb > 1) {
            rsprint("  o Domain azimuth ... %.2f ~ %.2f (%d)\n", az_lo, az_hi, naz);
        }

        // Elevation
        el = el_lo;
        while (el <= el_hi) {
            el += H->params.elevation_delta_deg;
            nel++;
        }
        if (H->verb > 1) {
            rsprint("  o Domain elevation ... %.2f ~ %.2f (%d)\n", el_lo, el_hi, nel);
        }

        // Zero volume
        if (naz == 0 || nel == 0) {
            rsprint("NEL = %d and/or NAZ = %d resulted in a zero volumne.\n", naz, nel);
            return;
        }
        
        // Evaluate the number of scatterers needed
        H->num_anchors  = 2 * naz * nel + 1;  // Save one for radar origin
        if (H->anchor_pos) {
            if (H->verb > 2) {
                rsprint("Freeing existing anchor memory.");
            }
            free(H->anchor_pos);
        }
        H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
        if (H->anchor_pos == NULL) {
            rsprint("ERROR: Unable to allocate memory for anchors.");
            return;
        }
        
        // Domain size
        el = el_lo / 180.0f * M_PI;
        while (el <= el_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
            az = az_lo / 180.0f * M_PI;
            while ((is_full_sweep && az < (az_hi - azimuth_delta) / 180.0f * M_PI) || (!is_full_sweep && az <= az_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1)) {
                //rsprint("ii %d   AZ %.2f   EL %.2f\n", ii, az / M_PI * 180.0f, el / M_PI * 180.0f);
                H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
                H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
                H->anchor_pos[ii].z = r_lo * sin(el);
                H->anchor_pos[ii].w = 1.0f;
                xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
                xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
                ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
                ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
                zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
                zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
                ii++;
                
                H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
                H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
                H->anchor_pos[ii].z = r_hi * sin(el);
                H->anchor_pos[ii].w = 1.0f;
                xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
                xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
                ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
                ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
                zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
                zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
                ii++;
                
                az += azimuth_delta / 180.0f * M_PI;
            }
            el += elevation_delta / 180.0f * M_PI;
        }
    }
    
    if (H->verb) {
        rsprint("Anchors computed   num_anchors = %d\n", H->num_anchors);
    }
    
    // Radar origin at (0, 0, 0)
    H->anchor_pos[ii].x = 0.0f;
    H->anchor_pos[ii].y = 0.0f;
    H->anchor_pos[ii].z = 0.0f;
    H->anchor_pos[ii].w = 5.0f;
    //printf("H->num_anchors = %zu   ii = %d\n", H->num_anchors, ii);
    
    // The closing domain of the simulation
    H->sim_desc.s[RSSimulationDescriptionBoundSizeX] = xmax - xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeY] = ymax - ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeZ] = zmax - zmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginX] = xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginY] = ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginZ] = zmin;
    
    sprintf(H->summary,
            "User domain @\n  R:[  %6.2f ~  %6.2f ] km\n  E:[  %6.2f ~  %6.2f ] deg\n  A:[ %+7.2f ~ %+7.2f ] deg\n",
            1.0e-3 * H->params.range_start, 1e-3 * H->params.range_end,
            H->params.elevation_start_deg, H->params.elevation_end_deg,
            H->params.azimuth_start_deg, H->params.azimuth_end_deg);
    sprintf(H->summary + strlen(H->summary),
            "Work domain @\n  R:[  %6.2f ~  %6.2f ] km  (%d gates)\n  E:[  %6.2f ~  %6.2f ] deg  (%d rays)\n  A:[ %+7.2f ~ %+7.2f ] deg  (%d rays)\n",
            1.0e-3 * r_lo, 1.0e-3 * r_hi, H->params.range_count,
            el_lo, el_hi, nel,
            az_lo, az_hi, H->sim_concept & RSSimulationConceptVerticallyPointingRadar ? nel : naz);
    sprintf(H->summary + strlen(H->summary),
            "==\n  X:[ %7.2f ~ %7.2f ]  (%.2f) m\n  Y:[ %7.2f ~ %7.2f ]  (%.2f) m\n  Z:[ %7.2f ~ %7.2f ]  (%.2f) m\n",
            xmin, xmax, H->sim_desc.s[RSSimulationDescriptionBoundSizeX],
            ymin, ymax, H->sim_desc.s[RSSimulationDescriptionBoundSizeY],
            zmin, zmax, H->sim_desc.s[RSSimulationDescriptionBoundSizeZ]);
    sprintf(H->summary + strlen(H->summary),
            "Concepts used: %s\n", RS_simulation_concept_string(H));

    if (H->verb) {
        rsprint("User domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+7.2f ~ %+7.2f ] deg\n",
                1.0e-3 * H->params.range_start, 1e-3 * H->params.range_end,
                H->params.elevation_start_deg, H->params.elevation_end_deg,
                H->params.azimuth_start_deg, H->params.azimuth_end_deg);
        rsprint("Work domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+7.2f ~ %+7.2f ] deg\n",
                1.0e-3 * r_lo, 1.0e-3 * r_hi,
                el_lo, el_hi,
                az_lo, az_hi);
        rsprint("            @ R:[       %-3d     ]      E:[       %-3d     ]       A:[         %-3d       ]",
                H->params.range_count, nel, naz);
        rsprint("            @ X:[ %.2f ~ %.2f ] m   Y:[ %.2f ~ %.2f ] m   Z:[ %.2f ~ %.2f ] m\n",
                xmin, xmax,
                ymin, ymax,
                zmin, zmax);
        rsprint("              = ( %.2f m x %.2f m x %.2f m )\n",
                xmax - xmin, ymax - ymin, zmax - zmin);
        if (H->sim_concept == RSSimulationConceptNull) {
            rsprint("No special concepts are active.\n");
        } else {
            rsprint("%s", RS_simulation_concept_bulleted_string(H));
        }
    }
    
    RS_revise_population(H);
    
    // Anchor lines to show the volume of interest, which was set by the user. The number is well more than enough
    H->num_anchor_lines  = 8 * (naz + nel);
    
    if (H->anchor_lines) {
        if (H->verb > 2) {
            printf("%s : RS : Freeing existing anchor_line memory.\n", now());
        }
        free(H->anchor_lines);
    }
    H->anchor_lines = (cl_float4 *)malloc(H->num_anchor_lines * sizeof(cl_float4));
    if (H->anchor_lines == NULL) {
        rsprint("ERROR: Unable to allocate memory for anchor_lines.");
        return;
    }
    ii = 0;
    
    //
    //             o----(4)----o             (end)
    //            /:          /|
    //           / :         / |
    //         (B)(7)      (C)(8)             EL
    //        /    :       /   |
    //       /     :      /    |
    //       o----(3)---[2]....o   (end)   (start)
    //       |    /      |    /
    //       |   /       |   /
    //      (5)(9)      (6)(A)    R
    //       | /         | /
    //       |/          |/
    //       o----(1)----o   (start)
    //
    //    (start)  AZ   (end)
    //
    
    if (H->params.elevation_start_deg < 90.0f) {
        // Line 1
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            az += H->params.azimuth_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 2
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            az += H->params.azimuth_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
    }
    if (H->params.elevation_end_deg < 90.0f) {
        // Line 3
        el = H->params.elevation_end_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            az += H->params.azimuth_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 4
        el = H->params.elevation_end_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            az += H->params.azimuth_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 5
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            el += H->params.elevation_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 6
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_end_deg / 180.0 * M_PI;
        while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            el += H->params.elevation_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_start * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 7
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            el += H->params.elevation_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
        // Line 8
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_end_deg / 180.0 * M_PI;
        while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
            
            el += H->params.elevation_delta_deg / 180.0 * M_PI;
            
            H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
            H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
            H->anchor_lines[ii].z = H->params.range_end * sin(el);
            H->anchor_lines[ii].w = 1.0;
            ii++;
        }
    }
    if (!is_full_sweep) {
        // Line 9
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_start * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_end * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        // Line A
        el = H->params.elevation_start_deg / 180.0 * M_PI;
        az = H->params.azimuth_end_deg / 180.0 * M_PI;
        H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_start * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_end * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        // Line B
        el = H->params.elevation_end_deg / 180.0 * M_PI;
        az = H->params.azimuth_start_deg / 180.0 * M_PI;
        H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_start * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_end * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        // Line C
        el = H->params.elevation_end_deg / 180.0 * M_PI;
        az = H->params.azimuth_end_deg / 180.0 * M_PI;
        H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_start * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
        H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
        H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
        H->anchor_lines[ii].z = H->params.range_end * sin(el);
        H->anchor_lines[ii].w = 1.0;
        ii++;
    }
    
    // printf("num_anchor_lines = %zu  ii = %d\n", H->num_anchor_lines, ii);
    
    H->num_anchor_lines = ii;
    
    return;
}


void RS_set_beam_pos(RSHandle *H, RSfloat az_deg, RSfloat el_deg) {
    // Compute the unit vector of the pointing direction
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = cosf(el_deg / 180.0f * M_PI) * sinf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = cosf(el_deg / 180.0f * M_PI) * cosf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = sinf(el_deg / 180.0f * M_PI);
    
    H->status |= RSStatusDebrisRCSNeedsUpdate;
    H->status |= RSStatusScattererSignalNeedsUpdate;
}


void RS_set_verbosity(RSHandle *H, const char verb) {
    H->verb = verb;
}


void RS_set_debris_count(RSHandle *H, const int debris_id, const size_t count) {
    
    int i;
    
    if (debris_id == 0) {
        printf("%s : RS : RS_set_debris_count() cannot have debris = 0.\n", now());
        return;
    }
    
    // Account for hydrometeors -> debris
    if (H->status & RSStatusDomainPopulated) {
        size_t delta = count - H->counts[debris_id];
        rsprint("Readjusting scatterer[0] %s -> %s", commaint(H->counts[0]), commaint(H->counts[0] - delta));
        H->counts[0] -= delta;
    }
    H->counts[debris_id] = count;
    
    // Always start with one as the background scatterers are always there
    H->num_types = 1;
    for (i = 1; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->counts[i] > 0) {
            H->num_types++;
        }
    }
    
    if (H->verb > 2) {
        rsprint("Total number of body types = %d", (int)H->num_types);
    }
    
    if (H->sim_tic > 0.0f) {
        RS_update_origins_offsets(H);
        
#if defined (_USE_GCL_)
        
        RS_derive_ndranges(H);
        
#endif
        
    }
}


void RS_revise_population(RSHandle *H) {
    int ii;
    
    // Get GPU preferred multiplication factor
    // NOTE: make_pulse_pass_1 uses 2 x max_work_group_size stride
    size_t max_work_group_size;
    clGetDeviceInfo(H->workers[0].dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    const size_t mul = H->num_cus[0] * H->num_workers * max_work_group_size * 2;
    
    if (H->sim_concept & RSSimulationConceptVerticallyPointingRadar) {
        size_t anchors_per_plane = (H->num_anchors - 1) / 2;
        H->num_scats = H->params.range_count * anchors_per_plane;
        H->counts[0] = H->num_scats;

        // Round the total population to a GPU preferred number
        //size_t preferred_n = (size_t)((H->num_scats + mul - 1) / mul) * mul;
        
        // Revise the background (rain)
        //H->counts[0] = preferred_n;
        
        sprintf(H->summary + strlen(H->summary),
                "Anchors / Plane = %s\n", commafloat(anchors_per_plane));
        if (H->verb) {
            rsprint("Anchors / Plane = %s\n", commaint(anchors_per_plane));
        }
    } else {
        // Volume of a single resolution cell at the start of the domain (svol = smallest volume)
        RSfloat r = H->params.range_start;
        RSfloat svol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5f);
        RSfloat nvol = H->sim_desc.s[RSSimulationDescriptionBoundSizeX]
        * H->sim_desc.s[RSSimulationDescriptionBoundSizeY]
        * H->sim_desc.s[RSSimulationDescriptionBoundSizeZ] / svol;
        
        // Suggest a number of scatter bodies to use
        H->num_scats = (size_t)(H->params.body_per_cell * nvol);
        H->counts[0] = H->num_scats;
        
        // Round the total population to a GPU preferred number
        size_t preferred_n = H->num_scats;
        if (H->num_scats > 50000) {
            preferred_n = (size_t)(H->num_scats / mul) * mul;
            if (preferred_n < H->params.body_per_cell * 9 / 10) {
                preferred_n += mul;
            }
        }
        
        // Revise the background (rain)
        H->counts[0] = preferred_n;

        sprintf(H->summary + strlen(H->summary),
                "nvol = %s x volumes of %s m^3\n", commafloat(nvol), commafloat(svol));
        sprintf(H->summary + strlen(H->summary),
                "Average meteor. scatterer density = %s\n", commafloat((float)H->counts[0] / nvol));
        if (H->verb) {
            rsprint("nvol = %s x volumes of %s m^3\n", commafloat(nvol), commafloat(svol));
            rsprint("Setting to GPU preferred %s", commaint(preferred_n));
            rsprint("Average all-type scatterer density = %s scatterers / closest radar cell\n", commafloat((float)preferred_n / nvol));
            rsprint("Average meteorological scatterer density = %s scatterers / closest radar cell\n", commafloat((float)H->counts[0] / nvol));
        }
    }
    
    // Add in the debris
    H->num_scats = H->counts[0];
    for (ii = 1; ii < RS_MAX_DEBRIS_TYPES; ii++) {
        if (H->counts[ii] > 0) {
            H->num_scats += H->counts[ii];
        }
    }
    
    // A hard limit here. Will do something about this next time.
    if (H->num_scats > 20000000) {
        rsprint("Too many scatterers (%s).\n", commaint(H->num_scats));
        exit(0);
    }
    
    // The population count is now considered defined
    H->status |= RSStatusPopulationDefined;
}


void RS_revise_debris_counts_to_gpu_preference(RSHandle *H) {
    
    int i;
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->counts[i]) {
            H->counts[i] = ((H->counts[i] + H->preferred_multiple - 1) / H->preferred_multiple) * H->preferred_multiple;
        }
    }
}


size_t RS_get_debris_count(RSHandle *H, const int debris_id) {
    return H->counts[debris_id];
}


size_t RS_get_worker_debris_count(RSHandle *H, const int debris_id, const int worker_id) {
    return H->workers[worker_id].counts[debris_id];
}


size_t RS_get_all_worker_debris_counts(RSHandle *H, const int debris_id, size_t counts[]) {
    
    int i;
    
    for (i = 0; i < H->num_workers; i++) {
        counts[i] = H->workers[i].counts[debris_id];
    }
    return H->counts[debris_id];
}


RSVolume RS_get_domain(RSHandle *H) {
    RSVolume v;
    v.size.x = H->sim_desc.s[RSSimulationDescriptionBoundSizeX];
    v.size.y = H->sim_desc.s[RSSimulationDescriptionBoundSizeY];
    v.size.z = H->sim_desc.s[RSSimulationDescriptionBoundSizeZ];
    v.origin.x = H->sim_desc.s[RSSimulationDescriptionBoundOriginX];
    v.origin.y = H->sim_desc.s[RSSimulationDescriptionBoundOriginY];
    v.origin.z = H->sim_desc.s[RSSimulationDescriptionBoundOriginZ];
    return v;
}


void RS_update_origins_offsets(RSHandle *H) {
    
    int i, k;
    
    size_t count = H->num_scats;
    
    if (H->num_workers == 0) {
        rsprint("ERROR: Number of workers = 0.");
        exit(EXIT_FAILURE);
    }
    
    // Divide the scatter bodies into (num_workers) chunks
    const size_t sub_num_scats = H->num_scats / MAX(1, H->num_workers);
    
    size_t offset = 0;
    for (i = 0; i < H->num_workers; i++) {
        H->offset[i] = offset;
        H->workers[i].num_scats = sub_num_scats;
        if (H->verb > 2) {
            rsprint("workers[%d]   num_scats = %s   offset = %s", i, commaint(sub_num_scats), commaint(H->offset[i]));
        }
        offset += sub_num_scats;
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 1) {
        k--;
        count -= H->counts[k];
    }
    if (H->counts[0] != count) {
        rsprint("ERROR: Inconsistent debris counts.");
        printf(RS_INDENT "o sub_num_scats = %s\n", commaint(sub_num_scats));
        printf(RS_INDENT "o population[0] = %s  !=  count = %s\n", commaint(H->counts[0]), commaint(count));
        for (k = 1; k < H->num_types; k++) {
            printf(RS_INDENT "o population[%d] = %s\n", k, commaint(H->counts[k]));
        }
        exit(EXIT_FAILURE);
    }
    
    // Volume of a single resolution cell at the start of the domain (svol = smallest volume)
    RSfloat r = H->params.range_start;
    RSfloat svol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5f);
    RSfloat nvol = (H->sim_desc.s[RSSimulationDescriptionBoundSizeX] * H->sim_desc.s[RSSimulationDescriptionBoundSizeY] * H->sim_desc.s[RSSimulationDescriptionBoundSizeZ]) / svol;
    
    if (H->verb) {
        rsprint("RS : Population details:");
        for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->counts[k] == 0) {
                break;
            }
            printf(RS_INDENT "o Global population[%d] = %s (%s scatterers / resolution cell)\n", k, commaint(H->counts[k]), commafloat((float)H->counts[k] / nvol));
        }
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 0) {
        k--;
        size_t debris_count_left = H->counts[k];
        if (debris_count_left == 0) {
            for (i = 0; i < H->num_workers; i++) {
                H->workers[i].counts[k] = 0;
            }
            continue;
        }
        // Groups of debris types
        size_t round_up_down_toggle = H->num_workers > 1 ? k % H->num_workers : k;
        size_t sub_counts = (H->counts[k] + round_up_down_toggle) / H->num_workers;
        for (i = 0; i < H->num_workers - 1; i++) {
            H->workers[i].counts[k] = sub_counts;
            debris_count_left -= sub_counts;
        }
        // The last worker gets all the remainders
        H->workers[i].counts[k] = debris_count_left;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        k = RS_MAX_DEBRIS_TYPES;
        size_t origin = H->workers[i].num_scats;
        while (k > 1) {
            k--;
            if (H->workers[i].counts[k] == 0) {
                continue;
            }
            origin -= H->workers[i].counts[k];
            H->workers[i].origins[k] = origin;
        }
    }
    
    if (H->verb > 2) {
        for (i = 0; i < H->num_workers; i++) {
            rsprint("RS : workers[%d] with total population %s  offset %s\n", i, commaint(H->workers[i].num_scats), commaint(H->offset[i]));
            for (k = 0; k < H->num_types; k++) {
                printf(RS_INDENT "o Local population[%d] - [ %9s, %9s, %9s ]\n", k,
                       commaint(H->workers[i].origins[k]),
                       commaint(H->workers[i].counts[k]),
                       commaint(H->workers[i].origins[k] + H->workers[i].counts[k]));
            }
        }
    }
}


void RS_set_dsd(RSHandle *H, const float *nd, const float *diameters, const int count, const char name) {
    
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. DSD cannot be changed.");
        return;
    }
    
    int i;
    
    if (count == 0) {
        printf(" %s : RS : DSD bin count cannot be 0.\n", now());
        return;
    }
    
    H->dsd_name = name;
    H->dsd_count = count;
    
    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
        free(H->dsd_pop);
    }
    
    // Derive concentration to pdf
    RSfloat *pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_nd_sum = 0.0f;
    for (i = 0; i < count; i++) {
        H->dsd_nd_sum += nd[i];
    }
    for (i = 0; i < count; i++) {
        pdf[i] = nd[i] / H->dsd_nd_sum;
    }
    
    // Total drops
    rsprint("Drop concentration ~ %s drops / m^3", commaint(H->dsd_nd_sum));
    
    H->dsd_r = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_cdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pop = (size_t *)malloc(count * sizeof(size_t));
    
    if (H->dsd_r == NULL || H->dsd_pdf == NULL || H->dsd_cdf == NULL || H->dsd_pop == NULL) {
        rsprint("ERROR: Unable to allocate memory for DSD parameterization.");
        free(pdf);
        return;
    }
    
    memset(H->dsd_r, 0, count * sizeof(RSfloat));
    memset(H->dsd_pdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_cdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_pop, 0, count * sizeof(size_t));
    
    RSfloat lo = 0.0f;
    
    for (i = 0; i < count; i++) {
        H->dsd_r[i] = 0.5f * diameters[i];
        H->dsd_pdf[i] = pdf[i];
        H->dsd_cdf[i] = lo;
        lo += pdf[i];
    }
    
    if (H->verb > 1) {
        printf("%s : RS : User set DSD specifications:\n", now());
        for (i = 0; i < MIN(MAX(count - 2, 1), 3); i++) {
            printf(RS_INDENT "o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
        if (count > 5) {
            printf(RS_INDENT "o  :      -      :     /     :\n");
            printf(RS_INDENT "o  :      -      :     /     :\n");
            i = MAX(4, count - 1);
        }
        for (; i < count; i++) {
            printf(RS_INDENT "o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
    }
    
    free(pdf);
}


void RS_set_dsd_to_mp_with_sizes(RSHandle *H, const float *ds, const int count) {
    
    int i;
    
    float d;
    
    H->dsd_n0 = 8000.0f;              // Marshall-Palmer 1948, mu = 0.08 cm^-4 = 8000 m^-3 m^-1
    H->dsd_lambda = 2.3f * 1000.0f;   // Let's say rainrate of ~15 mm hr^-1, lambda = 41 R ^-0.21 = 2.3
    
    RSfloat *n = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    // Derive a concentration curve
    for (i = 0; i < count; i++) {
        d = ds[i];
        n[i] = H->dsd_n0 * exp(-H->dsd_lambda * d);
    }
    
    RS_set_dsd(H, n, ds, count, RSDropSizeDistributionMarshallPalmer);
    
    free(n);
}


void RS_set_dsd_to_mp(RSHandle *H) {
    float ds[] = {0.001f, 0.002f, 0.003f, 0.004f, 0.005f};
    
    RS_set_dsd_to_mp_with_sizes(H, ds, sizeof(ds) / sizeof(float));
}


void RS_set_rcs_ellipsoid_table(RSHandle *H, const cl_float4 *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
    
    int i;
    
    RSTable table = RS_table_init(table_size * 4);
    if (table.data == NULL) {
        return;
    }
    // Set up the coefficients for FMA(a, b, c) in the CL kernel
    table.dx = 1.0f / table_index_delta;
    table.x0 = -table_index_start * table.dx;
    table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(cl_float4));
    if (H->verb > 1) {
        rsprint("Host RCS of ellipsoid table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n",
                table.dx, table.x0, table.xm, table_size);
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].rcs_ellipsoid != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting RCS of ellipsoids.\n", i);
            }
            gcl_free(H->workers[i].rcs_ellipsoid);
        }
        H->workers[i].rcs_ellipsoid = gcl_malloc(table_size * sizeof(cl_float4), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->workers[i].rcs_ellipsoid == NULL) {
            rsprint("ERROR: Unable to create RCS of ellipsoid table on CL device.\n");
            return;
        }
    }
    
#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].rcs_ellipsoid != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting RCS of ellipsoid.\n", i);
            }
            clReleaseMemObject(H->workers[i].rcs_ellipsoid);
        }
        if (H->verb > 2) {
            rsprint("workers[%d] creating RCS of ellipsoid (cl_mem) & copying data from %p.\n", i, table.data);
        }
        H->workers[i].rcs_ellipsoid = clCreateBuffer(H->workers[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(cl_float4), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("ERROR: Unable to create RCS of ellipsoid table on CL device.  ret = %d\n", ret);
            return;
        }
        if (H->verb > 2) {
            rsprint("workers[%d] created RCS of ellipsoid table @ %p.\n", i, H->workers[i].rcs_ellipsoid);
        }
    }
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
        H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
        if (!(H->sim_concept & RSSimulationConceptFixedScattererPosition) && H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] == 0.0f) {
            rsprint("WARNING: Drop concentration scale not set.");
        }
        H->workers[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }
    
    RS_table_free(table);
    
}


void RS_set_range_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
    
    int i;
    
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
    // Set up the coefficients for FMA(a, b, c) in the CL kernel
    table.dx = 1.0f / table_index_delta;
    table.x0 = -table_index_start * table.dx;
    table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host range weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n",
                table.dx, table.x0, table.xm, table_size);
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting range weight.", i);
            }
            gcl_free(H->workers[i].range_weight);
        }
        H->workers[i].range_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->workers[i].range_weight == NULL) {
            rsprint("ERROR: Unable to create range weight table on CL device.");
            return;
        }
    }
    
#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting range weight.", i);
            }
            clReleaseMemObject(H->workers[i].range_weight);
        }
        if (H->verb > 2) {
            rsprint("workers[%d] creating range weight (cl_mem) & copying data from %p.", now(), i, table.data);
        }
        H->workers[i].range_weight = clCreateBuffer(H->workers[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("ERROR: Unable to create range weight table on CL device.");
            return;
        }
        if (H->verb > 2) {
            rsprint("workers[%d] created range weight @ %p.", i, H->workers[i].range_weight);
        }
    }
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
        H->workers[i].range_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->workers[i].range_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->workers[i].range_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->workers[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float);
    }
    
    RS_table_free(table);
    
}


void RS_set_range_weight_to_triangle(RSHandle *H, float pulse_width_m) {
    float w[3] = {0.0f, 1.0f, 0.0f};
    RS_set_range_weight(H, w, -pulse_width_m, pulse_width_m, 3);
}


void RS_set_angular_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
    
    int i;
    
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
    // Set up the coefficients for FMA(a, b, c) in the CL kernel
    table.dx = 1.0f / table_index_delta;
    table.x0 = -table_index_start * table.dx;
    table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host angular weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d",
                table.dx, table.x0, table.xm, table_size);
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting angular weight.", i);
            }
            gcl_free(H->workers[i].angular_weight);
        }
        //for (int k = 0; k < table_size; k++) {
        //    printf("k=%d  w = %.3f  %.2f\n", k, table.data[k], 10 * log10f(table.data[k]));
        //}
        H->workers[i].angular_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->workers[i].angular_weight == NULL) {
            rsprint("ERROR: Unable to create angular weight table on CL device.");
            return;
        }
    }
    
#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("workers[%d] setting angular weight.\n", i);
            }
            clReleaseMemObject(H->workers[i].angular_weight);
        }
        if (H->verb > 2) {
            rsprint("workers[%d] creating angular weight (cl_mem) & copying data from %p.", i, table.data);
        }
        H->workers[i].angular_weight = clCreateBuffer(H->workers[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            rsprint("ERROR: Unable to create angular weight table on CL device.");
            return;
        }
        if (H->verb > 2) {
            rsprint("workers[%d] created angular weight.", i);
        }
    }
    
#endif
    
    // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
    for (i = 0; i < H->num_workers; i++) {
        H->workers[i].angular_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->workers[i].angular_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->workers[i].angular_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->workers[i].mem_usage += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float);
    }
    
    RS_table_free(table);
}


void RS_set_angular_weight_2d(RSHandle *H,
                              const float *weights,
                              const float xs, const float xo, unsigned int xc,
                              const float ys, const float yo, unsigned int yc) {
    int i;
    
    RSTable2D table = RS_table2d_init(xc * yc);
    table.xs = xs;
    table.xo = xo;
    table.xm = (float)(xc - 1);
    table.ys = ys;
    table.yo = yo;
    table.ym = (float)(yc - 1);
    memcpy(table.data, weights, xc * yc * sizeof(float));
    
    if (H->verb > 1) {
        rsprint("Host angular weight table 2d received\n");
        rsprint("dx = %.4f   x0 = %.1f   xm = %.1f   n = %d\n", table.xs, table.xo, table.xm, xc);
        rsprint("dy = %.4f   y0 = %.1f   ym = %.1f   n = %d\n", table.ys, table.yo, table.ym, yc);
    }
    
    // This is the part that we need to create a texture map for the RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};

#if defined (CL_VERSION_1_2)

    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = xc;
    desc.image_height = yc;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;

#endif

    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].angular_weight_2d != NULL) {

#if defined (_USE_GCL_)

            gcl_release_image(H->workers[i].angular_weight_2d);

#else

            clReleaseMemObject(H->workers[i].angular_weight_2d);
            
#endif
            
            H->workers[i].mem_usage -= ((cl_uint)(H->workers[i].angular_weight_2d_desc.s8 + 1.0f) * (H->workers[i].angular_weight_2d_desc.s9 + 1.0f) * sizeof(cl_float4));
    
    }
        
#if defined (_USE_GCL_)

        H->workers[i].angular_weight_2d = gcl_create_image(&format, xc, yc, 1, H->workers[i].surf_angular_weight_2d);
        
#elif defined (CL_VERSION_1_2)

        cl_int ret;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
        H->workers[i].angular_weight_2d = clCreateImage(H->workers[i].context, flags, &format, &desc, table.data, &ret);
        
#else
        
        H->workers[i].angular_weight_2d = clCreateImage2D(H->workers[i].context, flags, &format, xc, yc, xc * sizeof(cl_float4), table.data, &ret);
        
#endif
        
        if (H->workers[i].angular_weight_2d == NULL) {
            rsprint("ERROR: workers[%d] unable to create angular_weight_2d tables on CL device(s).", i);
            return;
        } else if (H->verb > 2) {
            rsprint("workers[%d] created angular_weight_2d table @ %p", i, H->workers[i].angular_weight_2d);
        }

#if defined (_USE_GCL_)

        dispatch_async(H->workers[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {table.xc, table.yc, 1};
            gcl_copy_ptr_to_image(H->workers[i].angular_weight_2d, table.data, origin, region);
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        
#endif
    
    }
    
    for (i = 0; i < H->num_workers; i++) {

#if defined (_USE_GCL_)
        
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
        
#endif

        // Copy over to CL worker
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionScaleX] = table.xs;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionScaleY] = table.ys;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionOriginX] = table.xo;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionOriginY] = table.yo;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionMaximumX] = table.xm;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionMaximumY] = table.ym;
        H->workers[i].angular_weight_2d_desc.s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->workers[i].mem_usage += ((cl_uint)(table.xm + 1.0f) * (table.ym + 1.0f)) * sizeof(cl_float4);
    }
    
    RS_table2d_free(table);
}

void RS_set_angular_weight_to_double_cone(RSHandle *H, float beamwidth_rad) {
    float w[] = {1.0f, 0.0f, 0.8f, 0.0f};
    unsigned int n = sizeof(w) / sizeof(float);
    RS_set_angular_weight(H, w, 0.0f, 2.0f * beamwidth_rad, n);
}


void RS_set_angular_weight_to_standard(RSHandle *H, float beamwidth_rad) {
    const unsigned int n = 32;
    float a;
    float b = 1.27f * M_PI / beamwidth_rad;
    float c;
    float *w = (float *)malloc(n * sizeof(float));
    
    float delta = 1.0f / 360.0f * M_PI;
    
    for (int i = 0; i < n; i++) {
        a = (float)i * delta;
        c = b * sinf(a);
        if (i == 0) {
            w[i] = 1.0f;
        } else if (i == (n - 1)) {
            w[i] = 0.0f;
        } else {
            w[i] = 8.0f * jn(2, c) / (c * c);
        }
        //printf("angle=%.4f deg  w[%d] = %.4f dB\n", a / M_PI * 180.0f, i, 20.0f * log10f(w[i]));
    }
    
    RS_set_angular_weight(H, w, 0.0f, delta, n);
    
    free(w);
}


void RS_set_vel_data(RSHandle *H, const RSTable3D table) {
    
    int i;
    cl_int ret = -1;
    cl_mem_flags flags = CL_MEM_READ_ONLY;
    cl_image_format format = {CL_RGBA, CL_FLOAT};

   for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].les_uvwt[0] == NULL) {

#if defined (_USE_GCL_)
            
            H->workers[i].les_uvwt[0] = gcl_create_image(&format, table.x_, table.y_, table.z_, H->workers[i].surf_uwvt[0]);
            H->workers[i].les_uvwt[1] = gcl_create_image(&format, table.x_, table.y_, table.z_, H->workers[i].surf_uvwt[1]);
            H->workers[i].les_cpxx[0] = gcl_create_image(&format, table.x_, table.y_, table.z_, H->workers[i].surf_cpxx[0]);
            H->workers[i].les_cpxx[1] = gcl_create_image(&format, table.x_, table.y_, table.z_, H->workers[i].surf_cpxx[1]);

#elif defined (CL_VERSION_1_2)
        

            cl_image_desc desc;
            desc.image_type = CL_MEM_OBJECT_IMAGE3D;
            desc.image_width  = table.x_;
            desc.image_height = table.y_;
            desc.image_depth  = table.z_;
            desc.image_array_size = 0;
            desc.image_row_pitch = 0;
            desc.image_slice_pitch = 0;
            desc.num_mip_levels = 0;
            desc.num_samples = 0;
            desc.buffer = NULL;

            H->workers[i].les_uvwt[0] = clCreateImage(H->workers[i].context, flags, &format, &desc, NULL, &ret);
            H->workers[i].les_uvwt[1] = clCreateImage(H->workers[i].context, flags, &format, &desc, NULL, NULL);
            H->workers[i].les_cpxx[0] = clCreateImage(H->workers[i].context, flags, &format, &desc, NULL, NULL);
            H->workers[i].les_cpxx[1] = clCreateImage(H->workers[i].context, flags, &format, &desc, NULL, NULL);

#else
            
            H->workers[i].les_uvwt[0] = clCreateImage3D(H->workers[i].context, flags, &format, table.x_, table.y_, table.z_, 0, 0, NULL, &ret);
            H->workers[i].les_uvwt[1] = clCreateImage3D(H->workers[i].context, flags, &format, table.x_, table.y_, table.z_, 0, 0, NULL, NULL);
            H->workers[i].les_cpxx[0] = clCreateImage3D(H->workers[i].context, flags, &format, table.x_, table.y_, table.z_, 0, 0, NULL, NULL);
            H->workers[i].les_cpxx[1] = clCreateImage3D(H->workers[i].context, flags, &format, table.x_, table.y_, table.z_, 0, 0, NULL, NULL);

#endif
            
            if (H->workers[i].les_uvwt[0] == NULL || H->workers[i].les_uvwt[1] == NULL || H->workers[i].les_cpxx[0] == NULL || H->workers[i].les_cpxx[1] == NULL) {
                rsprint("ERROR: workers[%d] unable to create wind table on CL device.  ret = %d   table of %d x %d x %d @ %p (%d)\n", i, ret, table.x_, table.y_, table.z_, table.uvwt, flags);
                exit(EXIT_FAILURE);
            } else if (H->verb > 2) {
                rsprint("workers[%d] created wind table @ %p %p %p %p\n", i,
                        &H->workers[i].les_uvwt[0], &H->workers[i].les_uvwt[1],
                        &H->workers[i].les_cpxx[0], &H->workers[i].les_cpxx[1]);
            }
        } // if (H->workers[i].vel[0] == NULL) ...

#if defined (_USE_GCL_)

        dispatch_async(H->workers[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {table.x_, table.y_, table.z_};
            gcl_copy_ptr_to_image(H->workers[i].les_uvwt[H->workers[i].les_id], table.data, origin, region);
            gcl_copy_ptr_to_image(H->workers[i].les_cpxx[H->workers[i].les_id], table.data, origin, region);
            dispatch_semaphore_signal(H->workers[i].sem_upload);
        });

#else
        
        size_t origin[3] = {0, 0, 0};
        size_t region[3] = {table.x_, table.y_, table.z_};
        clEnqueueWriteImage(H->workers[i].que, H->workers[i].les_uvwt[H->workers[i].les_id], CL_FALSE, origin, region,
                            table.x_ * sizeof(cl_float4), table.y_ * table.x_ * sizeof(cl_float4), table.uvwt, 0, NULL, &H->workers[i].event_upload);
        clEnqueueWriteImage(H->workers[i].que, H->workers[i].les_cpxx[H->workers[i].les_id], CL_FALSE, origin, region,
                            table.x_ * sizeof(cl_float4), table.y_ * table.x_ * sizeof(cl_float4), table.cpxx, 0, NULL, &H->workers[i].event_upload);

#endif
        
    }

    for (i = 0; i < H->num_workers; i++) {

#if defined (_USE_GCL_)

        dispatch_semaphore_wait(H->workers[i].sem_upload, DISPATCH_TIME_FOREVER);

#else

        clWaitForEvents(1, &H->workers[i].event_upload);

#endif

        // Copy over to CL worker
        float tmpf; memcpy(&tmpf, &table.spacing, sizeof(float));
        H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionFormat] = tmpf;                   // Make a copy in float so we are maintaining all 32-bits
        //printf("%s : RS : %d / %.9f\n", now(), table.spacing, H->workers[i].vel_desc.s[RSTable3DStaggeredDescriptionFormat]);
        if (table.spacing & RSTableSpacingStretchedX) {
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionBaseChangeX] = table.xs;      // "m" for stretched grid: m * log1p(n * pos.x) + o;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionPositionScaleX] = table.xo;   // "n" for stretched grid: m * log1p(n * pos.y) + o;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionOffsetX] = table.xm;          // "o" for stretched grid: m * log1p(n * pos.z) + o;
        } else {
            H->workers[i].les_desc.s[RSTable3DDescriptionScaleX] = table.xs;
            H->workers[i].les_desc.s[RSTable3DDescriptionOriginX] = table.xo;
            H->workers[i].les_desc.s[RSTable3DDescriptionMaximumX] = table.xm;
        }
        if (table.spacing & RSTableSpacingStretchedY) {
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionBaseChangeY] = table.ys;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionPositionScaleY] = table.yo;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionOffsetY] = table.ym;
        } else {
            H->workers[i].les_desc.s[RSTable3DDescriptionScaleY] = table.ys;
            H->workers[i].les_desc.s[RSTable3DDescriptionOriginY] = table.yo;
            H->workers[i].les_desc.s[RSTable3DDescriptionMaximumY] = table.ym;
        }
        if (table.spacing & RSTableSpacingStretchedZ) {
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionBaseChangeZ] = table.zs;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionPositionScaleZ] = table.zo;
            H->workers[i].les_desc.s[RSTable3DStaggeredDescriptionOffsetZ] = table.zm;
        } else {
            H->workers[i].les_desc.s[RSTable3DDescriptionScaleZ] = table.zs;
            H->workers[i].les_desc.s[RSTable3DDescriptionOriginZ] = table.zo;
            H->workers[i].les_desc.s[RSTable3DDescriptionMaximumZ] = table.zm;
        }
        H->workers[i].les_desc.s[RSTable3DDescriptionRefreshTime] = table.tr;
    }
}


void RS_set_vel_data_to_config(RSHandle *H, LESConfig c) {
    int i;
    if (H->L != NULL) {
        LES_free(H->L);
    }
    if (H->verb) {
        rsprint("Using LES configuration '" UNDERLINE("%s") "' ...", (char *)c);
    }
    H->L = LES_init_with_config_path(c, NULL);

#if defined(GUI)

    LES_set_delayed_read(H->L);
    
#endif

    // Release the pre-existing memory. Alaways assume the new LESConfig is not the same size.
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].les_uvwt[i] != NULL) {

#if defined (_USE_GCL_)

            gcl_release_image(H->workers[i].les_uvwt[0]);
            gcl_release_image(H->workers[i].les_uvwt[1]);

#else

            clReleaseMemObject(H->workers[i].les_uvwt[0]);
            clReleaseMemObject(H->workers[i].les_uvwt[1]);

#endif

            H->workers[i].les_uvwt[0] = NULL;
            H->workers[i].les_uvwt[1] = NULL;
        }
    }

    // Reset the velocity index to 0.
    // The GPU handles are still kept intact, will be released upon framework completion / table replacement
    H->vel_idx = 0;
    H->vel_count = (uint32_t)LES_get_table_count(H->L);
    if (H->verb) {
        rsprint("Reading LES table (%u out of %u)...", H->vel_idx, H->vel_count);
    }
    RS_set_vel_data_to_LES_table(H, LES_get_frame(H->L, 0));
    H->vel_idx = 1;
}


void RS_set_vel_data_to_LES_table(RSHandle *H, const LESTable *leslie) {
    
    float hmax, zmax;
    
    RSTable3D table = RS_table3d_init(leslie->nn);
    if (table.uvwt == NULL) {
        rsprint("ERROR: LES input data cannot be NULL.");
        return;
    }
    
    if (leslie->is_stretched) {
        //
        // For LES tables with streched grid:
        //
        // dz(k) = a * r ^ 1.05
        //
        //  z(k) = a * ( 1 - r ^ k ) / ( 1 - r )
        //
        //     k = 1 / log ( r ) * log ( 1 - ( 1 - r ) / a * z [ k ] )
        //       = 1 / log ( r ) * log ( 1 + ( r - 1 ) / a * z [ k ] )
        //
        // For a = 2.7, r = 1.05, these values may be documented in the data files at some point
        //
        //     k = 20.495934314287851 * log1p ( 0.018518518518519 * z [ k ] )
        //
        // For a = 2.0, r = 1.0212
        //
        //     k = 47.6681 * log1p ( 0.0160000000 * z [ k ] )
        //
        table.spacing = RSTableSpacingStretchedX | RSTableSpacingStretchedY | RSTableSpacingStretchedZ;
        table.x_ = leslie->nx;    table.xm = 0.5f * (float)(leslie->nx - 1);    table.xs = 1.0f / log(leslie->rx);    table.xo = (leslie->rx - 1.0f) / leslie->ax;
        table.y_ = leslie->ny;    table.ym = 0.5f * (float)(leslie->ny - 1);    table.ys = 1.0f / log(leslie->ry);    table.yo = (leslie->ry - 1.0f) / leslie->ay;
        table.z_ = leslie->nz;    table.zm = 0.0f;                              table.zs = 1.0f / log(leslie->rz);    table.zo = (leslie->rz - 1.0f) / leslie->az;
        hmax = leslie->ax * (1.0f - powf(leslie->rx, table.xm)) / (1.0f - leslie->rx);
        zmax = leslie->az * (1.0f - powf(leslie->rz, (float)(leslie->nz - 1))) / (1.0f - leslie->rz);
        if (H->verb > 0 && H->vel_idx == 0) {
            rsprint("LES stretched x-grid using %.6f * log1p( %.6f * x )    Mid = %.2f m\n",
                    table.xs, table.xo, hmax);
            rsprint("LES stretched z-grid using %.6f * log1p( %.6f * z )    Max = %.2f m\n",
                    table.zs, table.zo, zmax);
            rsprint("GPU LES[%2d/%2d] (%d, %s MB)\n",
                    H->vel_idx, H->vel_count,
                    H->workers[0].les_id,
                    commaint(leslie->nn * sizeof(cl_float4) / 1024 / 1024));
        }
    } else {
        table.x_ = leslie->nx;    table.xm = (float)leslie->nx - 1.0f;    table.xs = 1.0f / leslie->rx;    table.xo = (float)(leslie->nx - 1) * 0.5f;
        table.y_ = leslie->ny;    table.ym = (float)leslie->ny - 1.0f;    table.ys = 1.0f / leslie->ry;    table.yo = (float)(leslie->ny - 1) * 0.5f;
        table.z_ = leslie->nz;    table.zm = (float)leslie->nz - 1.0f;    table.zs = 1.0f / leslie->rz;    table.zo = 0.0f;
        hmax = 0.5f * ((float)leslie->nx - 1.0) * leslie->rx;
        zmax = ((float)leslie->nz - 1.0) * leslie->rz;
        if (H->verb > 0 && H->vel_idx == 0) {
            rsprint("LES uniform grid spacing using %.2f, %.2f, %.2f m\n", leslie->rx, leslie->ry, leslie->rz);
            rsprint("GPU LES[%2d/%2d] (%d, %s MB)\n",
                    H->vel_idx, H->vel_count,
                    H->workers[0].les_id,
                    commaint(leslie->nn * sizeof(cl_float4) / 1024 / 1024));
        }
    }
    if (H->verb > 0 && H->vel_idx == 0) {
        printf(RS_INDENT "o X:[ %.2f - %.2f ] (%.2f) m\n"
               RS_INDENT "o Y:[ %.2f - %.2f ] (%.2f) m\n"
               RS_INDENT "o Z:[ %.2f - %.2f ] (%.2f) m\n",
               -hmax, hmax, 2.0f * hmax,
               -hmax, hmax, 2.0f * hmax,
               0.0, zmax, zmax);
    }
    
    // Some other parameters
    table.tr = leslie->tr;
    
    // There is a toll-free bridge: LESTable has a remapped data structure during background read so there is no need to copy, just reassign the pointer, gotta love C!
    void *uvwt_orig = table.uvwt;
    void *cpxx_orig = table.cpxx;
    table.uvwt = (cl_float4 *)leslie->uvwt;
    table.cpxx = (cl_float4 *)leslie->cpxx;

    // Now we call the function to upload to GPU memory
    RS_set_vel_data(H, table);
    
    // Restore the pointer so that it can be freed as expected.
    table.uvwt = uvwt_orig;
    table.cpxx = cpxx_orig;
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->vel_desc = *leslie;
    memset(&H->vel_desc.data, 0, sizeof(LESValue));

    RS_table3d_free(table);
}


void RS_set_vel_data_to_uniform(RSHandle *H, cl_float4 velocity) {
    
    RSTable3D table = RS_table3d_init(1);
    
    RSVolume domain = RS_get_domain(H);
    
    if (H->verb > 1) {
        rsprint("Uniform @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
                domain.origin.x, domain.origin.x + domain.size.x,
                domain.origin.y, domain.origin.y + domain.size.y,
                domain.origin.z, domain.origin.z + domain.size.z);
    }
    
    // Set up the mapping coefficients:
    table.x_ = 1;    table.xm = 0.0f;    table.xs = 1.0f / domain.size.x;    table.xo = 0.0f;
    table.y_ = 1;    table.ym = 0.0f;    table.ys = 1.0f / domain.size.y;    table.yo = 0.0f;
    table.z_ = 1;    table.zm = 0.0f;    table.zs = 1.0f / domain.size.z;    table.zo = 0.0f;
    
    table.tr = 1000.0f;
    
    table.uvwt[0].x = velocity.x;
    table.uvwt[0].y = velocity.y;
    table.uvwt[0].z = velocity.z;
    table.uvwt[0].w = 0.0f;
    
    RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube27(RSHandle *H) {
    
    int i;
    
    RSTable3D table = RS_table3d_init(27);
    
    RSVolume domain = RS_get_domain(H);
    
    if (H->verb > 1) {
        rsprint("Cube27 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
                domain.origin.x, domain.origin.x + domain.size.x,
                domain.origin.y, domain.origin.y + domain.size.y,
                domain.origin.z, domain.origin.z + domain.size.z);
    }
    
    // Set up the mapping coefficients: -table_start * table_xs
    table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / domain.size.x;    table.xo = 1.0f;
    table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / domain.size.y;    table.yo = 1.0f;
    table.z_ = 3;    table.zm = 2.0f;    table.zs = 3.0f / domain.size.z;    table.zo = 0.0f;
    
    table.tr = 1000.0f;
    
    //	printf(" %.2f x %.2f = %.2f\n", -domain.origin.x, H->physics_table.xs, -domain.origin.x / domain.size.x * 2.0f);
    //	printf("o = [%.2f, %.2f, %.2f]\n", table.xo, table.yo, table.zo);
    
    const float v = 10.0f;
    
    for (i = 0; i < 27; i++) {
        table.uvwt[i].x = (float) (i % 3)      * v - v;
        table.uvwt[i].y = (float)((i % 9) / 3) * v - v;
        table.uvwt[i].z = (float) (i / 9)      * v - v;
        table.uvwt[i].w = 0.0f;
    }
    
    RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube125(RSHandle *H) {
    
    int i;
    
    RSTable3D table = RS_table3d_init(125);
    
    RSVolume domain = RS_get_domain(H);
    
    if (H->verb > 1) {
        rsprint("Cube125 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]",
                domain.origin.x, domain.origin.x + domain.size.x,
                domain.origin.y, domain.origin.y + domain.size.y,
                domain.origin.z, domain.origin.z + domain.size.z);
    }
    
    // Set up the mapping coefficients
    table.x_ = 5;    table.xm = 4.0f;    table.xs = 5.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
    table.y_ = 5;    table.ym = 4.0f;    table.ys = 5.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
    table.z_ = 5;    table.zm = 4.0f;    table.zs = 5.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
    
    table.tr = 1000.0f;
    
    const float v = 0.5f;
    
    for (i = 0; i < 125; i++) {
        table.uvwt[i].x = (float) (i %  5)      * v - 2.0f * v;
        table.uvwt[i].y = (float)((i % 25) / 5) * v - 2.0f * v;
        table.uvwt[i].z = (float) (i / 25)      * v - 2.0f * v;
        table.uvwt[i].w = 0.0f;
    }
    
    RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
    
}


void RS_clear_vel_data(RSHandle *H) {
    // Technically the video RAM hasn't been freed but we will assume there is enough room and this memory gets freed when a new table comes in
    for (int i = 0; i < H->num_workers; i++) {
        cl_uint nx = (cl_uint)H->workers[i].les_desc.s[RSTable3DDescriptionMaximumX] + 1;
        cl_uint ny = (cl_uint)H->workers[i].les_desc.s[RSTable3DDescriptionMaximumY] + 1;
        cl_uint nz = (cl_uint)H->workers[i].les_desc.s[RSTable3DDescriptionMaximumZ] + 1;
        H->workers[i].mem_usage -= nx * ny * nz * sizeof(cl_float4);
    }
}


void RS_set_scan_pattern(RSHandle *H, const POSPattern *scan_pattern) {
    H->P = (POSHandle)scan_pattern;
    if (H->verb > 1) {
        POS_summary(H->P);
    }
}


void RS_set_scan_pattern_with_string(RSHandle *H, const char *scan_string) {
    POSPattern *scan_pattern = POS_init_with_string(scan_string);
    RS_set_scan_pattern(H, scan_pattern);
}


void RS_set_adm_data(RSHandle *H, const RSTable2D cd, const RSTable2D cm) {
    
    int i;
    
    const int t = H->adm_count;
    
    const size_t n = cd.x_ * cd.y_;
    if (cm.x_ * cm.y_ != n) {
        rsprint("WARNING. RS_set_adm_data() received inconsistent cd (%d x %d) & cm (%d x %d) dimensions", cd.x_, cd.y_, cm.x_, cm.y_);
        return;
    }
    
    if (H->verb > 2) {
        rsprint("ADM[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]", H->adm_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = cd.x_;
    desc.image_height = cd.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].adm_cd[t] != NULL && H->workers[i].adm_cm[t] != NULL) {
            
#if defined (_USE_GCL_)
            
            gcl_release_image(H->workers[i].adm_cd[t]);
            gcl_release_image(H->workers[i].adm_cm[t]);
            
#else
            
            clReleaseMemObject(H->workers[i].adm_cd[t]);
            clReleaseMemObject(H->workers[i].adm_cm[t]);
            
#endif
            
            H->workers[i].mem_usage -= ((cl_uint)(H->workers[i].adm_desc[t].s8 + 1.0f) * (H->workers[i].adm_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  adm_cd & adm_cm always have the same desc
        
        
#if defined (_USE_GCL_)
        
        H->workers[i].adm_cd[t] = gcl_create_image(&format, cd.x_, cd.y_, 1, H->workers[i].surf_adm_cd[t]);
        H->workers[i].adm_cm[t] = gcl_create_image(&format, cm.x_, cm.y_, 1, H->workers[i].surf_adm_cm[t]);
        
#elif defined (CL_VERSION_1_2)
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
        H->workers[i].adm_cd[t] = clCreateImage(H->workers[i].context, flags, &format, &desc, cd.data, &retd);
        H->workers[i].adm_cm[t] = clCreateImage(H->workers[i].context, flags, &format, &desc, cm.data, &retm);
        
#else
        
        H->workers[i].adm_cd[t] = clCreateImage2D(H->workers[i].context, flags, &format, cd.x_, cd.y_, cd.x_ * sizeof(cl_float4), cd.data, &retd);
        H->workers[i].adm_cm[t] = clCreateImage2D(H->workers[i].context, flags, &format, cm.x_, cm.y_, cm.x_ * sizeof(cl_float4), cm.data, &retm);

#endif
        if (H->workers[i].adm_cd[t] == NULL || H->workers[i].adm_cm[t] == NULL) {
            rsprint("ERROR: workers[%d] unable to create ADM tables on CL device(s).", i);
            return;
        } else if (H->verb > 2) {
            rsprint("workers[%d] created ADM tables adm_cd[%d] & adm_cd[%d] @ %p & %p", i, t, t, &H->workers[i].adm_cd[t], &H->workers[i].adm_cm[t]);
        }
        
#if defined (_USE_GCL_)
        
        dispatch_async(H->workers[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {cd.x_, cd.y_, 1};
            gcl_copy_ptr_to_image(H->workers[i].adm_cd[t], cd.data, origin, region);
            gcl_copy_ptr_to_image(H->workers[i].adm_cm[t], cm.data, origin, region);
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {
        
#if defined (_USE_GCL_)
        
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionScaleX] = cd.xs;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionScaleY] = cd.ys;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionOriginX] = cd.xo;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionOriginY] = cd.yo;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] = cd.xm;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] = cd.ym;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnX] = H->adm_desc[t].phys.inv_inln_x;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnY] = H->adm_desc[t].phys.inv_inln_y;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnZ] = H->adm_desc[t].phys.inv_inln_z;
        H->workers[i].adm_desc[t].s[RSTable3DDescriptionTachikawa] = H->adm_desc[t].phys.Ta;
        H->workers[i].mem_usage += ((cl_uint)(cd.xm + 1.0f) * (cd.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->adm_count++;
}


void RS_set_adm_data_to_ADM_table(RSHandle *H, const ADMTable *adam) {
    
    int i;
    
    RSTable2D cd = RS_table2d_init(adam->nn);
    RSTable2D cm = RS_table2d_init(adam->nn);
    
    if (cd.data == NULL || cm.data == NULL) {
        rsprint("ADM input data cannot be NULL.");
        return;
    }
    
    // Set up the mapping coefficients
    // Assumptions: maps are always in beta in [-180deg, +180deg] and alpha in [0, +180deg]
    cd.x_ = adam->nb;    cd.xm = (float)(cd.x_ - 1);    cd.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cd.xo = -(-M_PI) * cd.xs + 0.5f;
    cd.y_ = adam->na;    cd.ym = (float)(cd.y_ - 1);    cd.ys = (float)(adam->na - 1) / M_PI;             cd.yo = 0.5f;
    
    cm.x_ = adam->nb;    cm.xm = (float)(cm.x_ - 1);    cm.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cm.xo = -(-M_PI) * cm.xs + 0.5f;
    cm.y_ = adam->na;    cm.ym = (float)(cm.y_ - 1);    cm.ys = (float)(adam->na - 1) / M_PI;             cm.yo = 0.5f;
    
    // Arrange ADM values into float4, getting ready for GPU's global memory
    for (i = 0; i < adam->nn; i++) {
        cd.data[i].x = adam->data.cdx[i];
        cd.data[i].y = adam->data.cdy[i];
        cd.data[i].z = adam->data.cdz[i];
        cd.data[i].w = 0.0f;
        cm.data[i].x = adam->data.cmx[i];
        cm.data[i].y = adam->data.cmy[i];
        cm.data[i].z = adam->data.cmz[i];
        cm.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->adm_desc[H->adm_count] = *adam;
    memset(&H->adm_desc[H->adm_count].data, 0, sizeof(ADMData));
    
    if (H->verb > 1) {
        const int t = H->adm_count;
        rsprint("GPU ADM[%d]   Ta = %.4f  inv_inln = [%.4f %.4f %.4f]   mass = %.4f kg",
                t, H->adm_desc[t].phys.Ta, H->adm_desc[t].phys.inv_inln_x, H->adm_desc[t].phys.inv_inln_y, H->adm_desc[t].phys.inv_inln_z, H->adm_desc[t].phys.mass);
    }
    
    RS_set_adm_data(H, cd, cm);
    
    RS_table2d_free(cd);
    RS_table2d_free(cm);
}


void RS_set_adm_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table = RS_table2d_init(9);
    
    if (H->verb > 1) {
        rsprint("ADM to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]");
    }
    
    table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / (2.0f * M_PI);    table.xo = -(-M_PI) * table.xs;
    table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / M_PI;             table.yo = 0.0f;
    
    for (i = 0; i < 9; i++) {
        table.data[i].x = 1.0f;
        table.data[i].y = 1.0f;
        table.data[i].z = 1.0f;
        table.data[i].w = 0.0f;
    }
    
    RS_set_adm_data(H, table, table);
    
    RS_table2d_free(table);
}


void RS_clear_adm_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->adm_count; t++) {
            cl_uint nx = (cl_uint)H->workers[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->workers[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->workers[i].mem_usage -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->adm_count = 0;
}


void RS_set_rcs_data(RSHandle *H, const RSTable2D real, const RSTable2D imag) {
    
    int i;
    
    const int t = H->rcs_count;
    
    const size_t n = real.x_ * real.y_;
    if (imag.x_ * imag.y_ != n) {
        rsprint("WARNING. RS_set_rcs_data() received inconsistent real (%d x %d) & imag (%d x %d) dimensions", now(), real.x_, real.y_, imag.x_, imag.y_);
        return;
    }
    
    if (H->verb > 1) {
        rsprint("GPU RCS[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]", H->rcs_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = real.x_;
    desc.image_height = real.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->workers[i].rcs_real[t] != NULL && H->workers[i].rcs_imag[t] != NULL) {
            
#if defined (_USE_GCL_)
            
            gcl_release_image(H->workers[i].rcs_real[t]);
            gcl_release_image(H->workers[i].rcs_imag[t]);
            
#else
            
            clReleaseMemObject(H->workers[i].rcs_real[t]);
            clReleaseMemObject(H->workers[i].rcs_imag[t]);
            
#endif
            
            H->workers[i].mem_usage -= ((cl_uint)(H->workers[i].rcs_desc[t].s8 + 1.0f) * (H->workers[i].rcs_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  rcs_real & rcs_imag always have the same desc
        
        
#if defined (_USE_GCL_)
        
        H->workers[i].rcs_real[t] = gcl_create_image(&format, real.x_, real.y_, 1, H->workers[i].surf_rcs_real[t]);
        H->workers[i].rcs_imag[t] = gcl_create_image(&format, imag.x_, imag.y_, 1, H->workers[i].surf_rcs_imag[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->workers[i].rcs_real[t] = clCreateImage(H->workers[i].context, flags, &format, &desc, real.data, &retd);
        H->workers[i].rcs_imag[t] = clCreateImage(H->workers[i].context, flags, &format, &desc, imag.data, &retm);
        
#else
        
        H->workers[i].rcs_real[t] = clCreateImage2D(H->workers[i].context, flags, &format, real.x_, real.y_, real.x_ * sizeof(cl_float4), real.data, &retd);
        H->workers[i].rcs_imag[t] = clCreateImage2D(H->workers[i].context, flags, &format, imag.x_, imag.y_, imag.x_ * sizeof(cl_float4), imag.data, &retm);
        
#endif
        
#endif
        if (H->workers[i].rcs_real[t] == NULL || H->workers[i].rcs_imag[t] == NULL) {
            rsprint("ERROR: workers[%d] unable to create RCS tables on CL device(s).", i);
            return;
        } else if (H->verb > 2) {
            rsprint("workers[%d] created RCS tables rcs_real[%d] & rcs_imag[%d] @ %p & %p", i, t, t, &H->workers[i].rcs_real[t], &H->workers[i].rcs_imag[t]);
        }
        
#if defined (_USE_GCL_)
        
        dispatch_async(H->workers[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {real.x_, imag.y_, 1};
            gcl_copy_ptr_to_image(H->workers[i].rcs_real[t], real.data, origin, region);
            gcl_copy_ptr_to_image(H->workers[i].rcs_imag[t], imag.data, origin, region);
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {
        
#if defined (_USE_GCL_)
        
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionScaleX] = real.xs;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionScaleY] = real.ys;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionOriginX] = real.xo;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionOriginY] = real.yo;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] = real.xm;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] = real.ym;
        H->workers[i].rcs_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->workers[i].mem_usage += ((cl_uint)(real.xm + 1.0f) * (real.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->rcs_count++;
}


void RS_set_rcs_data_to_RCS_table(RSHandle *H, const RCSTable *rosie) {
    
    int i;
    
    RSTable2D real = RS_table2d_init(rosie->nn);
    RSTable2D imag = RS_table2d_init(rosie->nn);
    
    if (real.data == NULL || imag.data == NULL) {
        rsprint("ERROR: RCS input data cannot be NULL.");
        return;
    }
    // Set up the mapping coefficients
    // Assumptions: maps are always in alpha in [-180deg, +180deg] and beta in [0, +180deg]
    real.x_ = rosie->na;    real.xm = (float)(real.x_ - 1);    real.xs = (float)(rosie->na - 1) / (2.0f * M_PI);    real.xo = -(-M_PI) * real.xs;
    real.y_ = rosie->nb;    real.ym = (float)(real.y_ - 1);    real.ys = (float)(rosie->nb - 1) / M_PI;             real.yo = 0.0f;
    
    imag.x_ = rosie->na;    imag.xm = (float)(imag.x_ - 1);    imag.xs = (float)(rosie->na - 1) / (2.0f * M_PI);    imag.xo = -(-M_PI) * real.xs;
    imag.y_ = rosie->nb;    imag.ym = (float)(imag.y_ - 1);    imag.ys = (float)(rosie->nb - 1) / M_PI;             imag.yo = 0.0f;
    
    // Arrange RCS values into float4, getting ready for GPU's global memory
    for (i = 0; i < rosie->nn; i++) {
        real.data[i].x = rosie->data.hh_real[i];
        real.data[i].y = rosie->data.vv_real[i];
        real.data[i].z = rosie->data.hv_real[i];
        real.data[i].w = 0.0f;
        imag.data[i].x = rosie->data.hh_imag[i];
        imag.data[i].y = rosie->data.vv_imag[i];
        imag.data[i].z = rosie->data.hv_imag[i];
        imag.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->rcs_desc[H->rcs_count] = *rosie;
    memset(&H->rcs_desc[H->rcs_count].data, 0, sizeof(RCSData));
    
    if (H->verb > 1) {
        const int t = H->rcs_count;
        rsprint("GPU RCS[%d]   lambda = %.2f m",
                t, H->rcs_desc[t].lambda);
    }
    
    RS_set_rcs_data(H, real, imag);
    
    RS_table2d_free(real);
    RS_table2d_free(imag);
    
}


void RS_set_rcs_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table_real = RS_table2d_init(9);
    RSTable2D table_imag = RS_table2d_init(9);
    
    if (H->verb > 1) {
        rsprint("RCS to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]");
    }
    
    table_real.x_ = 3;    table_real.xm = 2.0f;    table_real.xs = 3.0f / (2.0f * M_PI);    table_real.xo = -(-M_PI) * table_real.xs;
    table_real.y_ = 3;    table_real.ym = 2.0f;    table_real.ys = 3.0f / M_PI;             table_real.yo = 0.0f;
    
    table_imag.x_ = 3;    table_imag.xm = 2.0f;    table_imag.xs = 3.0f / (2.0f * M_PI);    table_imag.xo = -(-M_PI) * table_imag.xs;
    table_imag.y_ = 3;    table_imag.ym = 2.0f;    table_imag.ys = 3.0f / M_PI;             table_imag.yo = 0.0f;
    
    for (i =  0; i < 9; i++) {
        table_real.data[i].x = 1.0f;
        table_real.data[i].y = 1.0f;
        table_real.data[i].z = 1.0f;
        table_real.data[i].w = 0.0f;
        
        table_imag.data[i].x = 0.0f;
        table_imag.data[i].y = 0.0f;
        table_imag.data[i].z = 0.0f;
        table_imag.data[i].w = 0.0f;
    }
    
    RS_set_rcs_data(H, table_real, table_imag);
    
    RS_table2d_free(table_real);
    RS_table2d_free(table_imag);
}


void RS_clear_rcs_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->rcs_count; t++) {
            cl_uint nx = (cl_uint)H->workers[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->workers[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->workers[i].mem_usage -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->rcs_count = 0;
}

// This method can be confusing. Don't use
void RS_set_obj_data_to_config(RSHandle *H, OBJConfig type) {
    OBJTable *obj_table = OBJ_get_table(H->O, type);
    
    RS_set_adm_data_to_ADM_table(H, obj_table->adm_table);
    RS_set_rcs_data_to_RCS_table(H, obj_table->rcs_table);
}


void RS_set_random_seed(RSHandle *H, const unsigned int seed) {
    if (H->verb) {
        rsprint("Random number generator set to use seed %s", commaint(seed));
    }
    H->random_seed = seed;
}

// Add debris to the simulation machine
void RS_add_debris(RSHandle *H, OBJConfig type, const size_t count) {

    int k = 1;

    if (H->O == NULL) {
        H->O = OBJ_init();
        if (H->O == NULL) {
            rsprint("ERROR: OBJ_init() failed.");
            exit(EXIT_FAILURE);
        }
    }

    while (H->counts[k] > 0 && k < RS_MAX_DEBRIS_TYPES) {
        k++;
    }

    if (k == RS_MAX_DEBRIS_TYPES || H->adm_count == RS_MAX_ADM_TABLES || H->rcs_count == RS_MAX_RCS_TABLES) {
        rsprint("Unable to add more debris type.");
        return;
    }

    OBJTable *obj_table = OBJ_get_table(H->O, type);
    RS_set_adm_data_to_ADM_table(H, obj_table->adm_table);
    RS_set_rcs_data_to_RCS_table(H, obj_table->rcs_table);
    H->counts[k] = count;
    H->num_types++;
    if (k != H->adm_count || k != H->rcs_count) {
        rsprint("WARNING: Inconsistent k = %d vs H->adm_count = %d vs H->rcs_count = %d.", k, H->adm_count, H->rcs_count);
        return;
    }
    if (H->verb) {
        rsprint("Total number of body types = %d (including meteorological scatterers)", (int)H->num_types);
    }
}

#pragma mark -
#pragma mark GUI Specific Functions

#if defined (GUI) || defined (_USE_GCL_)

// Compute auxiliary attributes: range, angular weight, etc.
// Users should not need to call this directly. It's either RS_make_pulse() or RS_update_colors()
// The framework will check the status to avoid redundant computations.
void RS_update_auxiliary_attributes(RSHandle *H) {
    
    int i;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("ERROR: Simulation domain not populated.");
        return;
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            scat_sig_aux_kernel(&H->workers[i].ndrange_scat_all,
                                (cl_float4 *)H->workers[i].scat_sig,
                                (cl_float4 *)H->workers[i].scat_aux,
                                (cl_float4 *)H->workers[i].scat_pos,
                                (cl_float4 *)H->workers[i].scat_rcs,
                                (cl_float *)H->workers[i].angular_weight,
                                H->workers[i].angular_weight_desc,
                                H->sim_desc);
            dispatch_semaphore_signal(H->workers[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE];
    memset(events, 0, sizeof(events));
    
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->workers[i];
        clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->workers[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, events);
        clReleaseEvent(events[i]);
    }
    
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
    
#endif
    
}

void RS_update_colors(RSHandle *H) {
    
    int i, k;
    int r, a;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("ERROR: Simulation domain not populated.");
        return;
    }
    
#if defined (_USE_GCL_)
    
    if (H->status & RSStatusScattererSignalNeedsUpdate) {
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->workers[i];
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    dispatch_async(C->que, ^{
                        db_rcs_kernel(&C->ndrange_scat[k],
                                      (cl_float4 *)C->scat_pos,
                                      (cl_float4 *)C->scat_ori,
                                      (cl_float4 *)C->scat_rcs,
                                      (cl_image)H->workers[i].rcs_real[r],
                                      (cl_image)H->workers[i].rcs_imag[r],
                                      H->workers[i].rcs_desc[r],
                                      H->sim_desc);
                        dispatch_semaphore_signal(C->sem);
                    });
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
                }
            }
            dispatch_async(C->que, ^{
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
                scat_clr_kernel(&C->ndrange_scat_all,
                                (cl_float4 *)C->scat_clr,
                                (cl_float4 *)C->scat_pos,
                                (cl_float4 *)C->scat_aux,
                                (cl_float4 *)C->scat_rcs,
                                H->draw_mode);
                dispatch_semaphore_signal(C->sem);
            });
            dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
        }
    } else {
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->workers[i];
            dispatch_async(H->workers[i].que, ^{
                // Set individual color based on draw mode
                scat_clr_kernel(&C->ndrange_scat_all,
                                (cl_float4 *)C->scat_clr,
                                (cl_float4 *)C->scat_pos,
                                (cl_float4 *)C->scat_aux,
                                (cl_float4 *)C->scat_rcs,
                                H->draw_mode);
                dispatch_semaphore_signal(C->sem);
            });
            dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
        }
    }
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE][H->num_types];
    memset(events, 0, sizeof(events));
    
    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        // Very similar to the RS_advance_time() function but only the debris RCS is updated
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->workers[i];
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
                    clEnqueueNDRangeKernel(C->que, C->kern_db_rcs, 1, &C->origins[k], &C->counts[k], NULL, 0, NULL, &events[i][k]);
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            clFlush(H->workers[i].que);
        }
        for (i = 0; i < H->num_workers; i++) {
            for (k = 1; k < H->num_types; k++) {
                if (H->workers[i].counts[k]) {
                    clWaitForEvents(1, &events[i][k]);
                    clReleaseEvent(events[i][k]);
                }
            }
        }
        H->status |= RSStatusScattererSignalNeedsUpdate;
    }
    for (i = 0; i < H->num_workers; i++) {
        if (H->status & RSStatusScattererSignalNeedsUpdate) {
            RSWorker *C = &H->workers[i];
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][0]);
            
            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 1, &events[i][0], &events[i][1]);
        } else {
            RSWorker *C = &H->workers[i];
            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][1]);
        }
    }
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->workers[i].que);
    }
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][1]);
        clReleaseEvent(events[i][1]);
        if (H->status & RSStatusScattererSignalNeedsUpdate) {
            clReleaseEvent(events[i][0]);
        }
    }
    
#endif
    
    H->status &= ~RSStatusDebrisRCSNeedsUpdate;
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
}

void RS_share_mem_with_vbo(RSHandle *H, const int n, unsigned int vbo[][n]) {
    if (H->verb) {
        if (H->num_workers == 1) {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2]);
        } else {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2],
                   vbo[1][0], vbo[1][1], vbo[1][2]);
        }
    }
    for (int i = 0; i < H->num_workers; i++) {
        H->workers[i].vbo_scat_pos = vbo[i][0];
        H->workers[i].vbo_scat_clr = vbo[i][1];
        H->workers[i].vbo_scat_ori = vbo[i][2];
    }
    H->has_vbo_from_gl = 1;
}

#endif

#if defined (_USE_GCL_)

void RS_derive_ndranges(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        
        RSWorker *C = &H->workers[i];
        
        C->ndrange_scat_all.work_dim = 1;
        C->ndrange_scat_all.global_work_offset[0] = 0;
        C->ndrange_scat_all.global_work_size[0] = C->num_scats;
        C->ndrange_scat_all.local_work_size[0] = 0;
        
        for (int k = 0; k < H->num_types; k++) {
            if (H->counts[k] == 0) {
                continue;
            }
            C->ndrange_scat[k].work_dim = 1;
            C->ndrange_scat[k].global_work_offset[0] = C->origins[k];
            C->ndrange_scat[k].global_work_size[0] = C->counts[k];
            C->ndrange_scat[k].local_work_size[0] = 0;
            if (C->verb > 2) {
                rsprint("work[%d] offset, size = %d, %d",
                        (int)C->name, (int)C->ndrange_scat[k].global_work_offset[0], (int)C->ndrange_scat[k].global_work_size[0]);
            }
        }
        
        C->ndrange_pulse_pass_1.work_dim = 1;
        C->ndrange_pulse_pass_1.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_1.global_work_size[0] = C->make_pulse_params.global[0];
        C->ndrange_pulse_pass_1.local_work_size[0] = C->make_pulse_params.local[0];
        
        C->ndrange_pulse_pass_2.work_dim = 1;
        C->ndrange_pulse_pass_2.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_2.global_work_size[0] = C->make_pulse_params.global[1];
        C->ndrange_pulse_pass_2.local_work_size[0] = C->make_pulse_params.local[1];
    }
}


#endif

#pragma mark -
#pragma mark Framework Functions

void RS_io_test(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            io_kernel(&H->workers[i].ndrange_scat[0],
                      (cl_float4 *)H->workers[i].scat_pos,
                      (cl_float4 *)H->workers[i].scat_aux);
            dispatch_semaphore_signal(H->workers[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->workers[i].que, H->workers[i].kern_io, 1, NULL, &H->workers[i].num_scats, NULL, 0, NULL, NULL);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->workers[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->workers[i].que);
    }
    
#endif
    
}


void RS_populate(RSHandle *H) {
    
    int i, k, n, w;
    
    if (H->verb > 1) {
        rsprint("RS_populate()   preferred_multiple = %s\n", commaint(H->preferred_multiple));
    }
    
    if (H->num_scats > RS_MAX_NUM_SCATS) {
        rsprint("Number of scatterers exceed the maximum allowed. (%s > %s).\n", commaint(H->num_scats), commaint(RS_MAX_NUM_SCATS));
        exit(EXIT_FAILURE);
    }
    
    size_t max_var_size;
    CL_CHECK(clGetDeviceInfo(H->workers[0].dev, CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(max_var_size), &max_var_size, NULL));
    if (H->workers[0].num_scats * sizeof(cl_float4) > max_var_size) {
        rsprint("ERROR: Every scatterer attribute occupies %s B > %s B.", commaint(H->workers[0].num_scats * sizeof(cl_float4)), commaint(max_var_size));
        exit(EXIT_FAILURE);
    }

    // Set an LES field if there isn't one set before
    if (H->L == NULL) {
        RS_set_vel_data_to_config(H, LESConfigSuctionVortices);
    }
    
    // Set a scanning strategy if none has been provided
    if (H->P == NULL) {
        rsprint("RS_populate() Scan pattern does not exist. Assume a PPI.\n");
        RS_set_scan_pattern(H, POS_init());
    }
    
    // Set a box if it has not been set
    if (H->num_anchors == 0) {
        if (H->verb) {
            rsprint("No scan box defined. Using scan strategy to derive the scan box.\n");
        }
        RSBox box = RS_suggest_scan_domain(H);
        //rsprint("Suggested box size = %.2f x %.2f x %.2f\n", box.size.r, box.size.a, box.size.e);
        RS_set_scan_box(H, box);
    }
    
    // These should be identical
    if (H->adm_count != H->rcs_count) {
        rsprint("ADM & RCS are not consistent. Unexpected behavior may happen.\n");
    }
    
    // Use some default tables if there aren't any set
    if (H->adm_count == 0) {
        RS_set_adm_data_to_unity(H);
    }
    if (H->rcs_count == 0) {
        RS_set_rcs_data_to_unity(H);
    }
    
    if (H->status & RSStatusDomainPopulated) {
        rsprint("WARNING. Simulation was populated.");
        exit(EXIT_FAILURE);
    }
    
    //
    // CPU memory allocation
    //
    if (H->scat_pos != NULL) {
        RS_free_scat_memory(H);
    }
    
    posix_memalign((void **)&H->scat_uid, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_uint4));
    posix_memalign((void **)&H->scat_pos, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_vel, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_ori, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_tum, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_aux, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rcs, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_sig, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rnd, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_uint4));
    posix_memalign((void **)&H->pulse, RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
    
    if (H->scat_uid == NULL ||
        H->scat_pos == NULL ||
        H->scat_vel == NULL ||
        H->scat_ori == NULL ||
        H->scat_tum == NULL ||
        H->scat_aux == NULL ||
        H->scat_rcs == NULL ||
        H->scat_sig == NULL ||
        H->scat_rnd == NULL ||
        H->pulse == NULL) {
        rsprint("ERROR: Unable to allocate memory space for scatterers.");
        return;
    }
    
    memset(H->scat_aux, 0, H->num_scats * sizeof(cl_float4));
    memset(H->scat_sig, 0, H->num_scats * sizeof(cl_float4));
    
    H->mem_size = H->num_scats * (8 * sizeof(cl_float4) + 2 * sizeof(cl_uint4)) + H->params.range_count * sizeof(cl_float4);
    
    char has_null = 0;
    for (i = 0; i < H->num_workers; i++) {
        posix_memalign((void **)&H->pulse_tmp[i], RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
        has_null |= H->pulse_tmp[i] == NULL;
        H->mem_size += H->params.range_count * sizeof(cl_float4);
    }
    if (has_null) {
        rsprint("ERROR: Unable to allocate memory space for pulses.");
        return;
    }
    
    // Get the available memory of the host
    
#if defined(_SC_PHYS_PAGES)
    
    long mem_pages = sysconf(_SC_PHYS_PAGES);
    long mem_page_size = sysconf(_SC_PAGE_SIZE);
    size_t host_mem = mem_pages * mem_page_size;
    
#else
    
    uint64_t mem;
    size_t len = sizeof(mem);
    sysctlbyname("hw.memsize", &mem, &len, NULL, 0);
    size_t host_mem = mem;
    
#endif
    
    if (H->mem_size > host_mem / 4 * 3) {
        rsprint("WARNING: High host memory usage: %s GB out of %s GB.", commafloat((float)H->mem_size * 1.0e-9f), commafloat((float)host_mem * 1.0e-9f));
    } else if (H->verb) {
        if (H->mem_size > (size_t)1.0e9f) {
            rsprint("CPU memory usage = %s GB out of %s GB", commafloat((float)H->mem_size * 1.0e-9f), commafloat((float)host_mem * 1.0e-9f));
        } else {
            rsprint("CPU memory usage = %s MB out of %s MB", commafloat((float)H->mem_size * 1.0e-6f), commafloat((float)host_mem * 1.0e-6f));
        }
    }
    
    // Update scatterer origin and offset of each worker
    RS_update_origins_offsets(H);
    
    // Initialize the scatter body positions on CPU, will upload to the GPU later
    srand(H->random_seed);
    
    RSVolume domain = RS_get_domain(H);
    
    uint32_t uid = 0;

    if (H->sim_concept & RSSimulationConceptFixedScattererPosition) {
        if (H->num_types > 1) {
            rsprint("WARNING. Debris particles are not emulated in RSSimulationConceptFixedScattererPosition mode.\n");
        }
        rsprint("RS_populate() num_workers = %d\n", H->num_workers);

        const RSfloat r_lo = sqrtf(H->anchor_pos[0].x * H->anchor_pos[0].x + H->anchor_pos[0].y * H->anchor_pos[0].y + H->anchor_pos[0].z * H->anchor_pos[0].z);

        // Anchor points alternate between the low and high. First plan can be retrieved from the lower portion
        i = 0;
        for (k = 0; k < H->num_anchors - 1; k++) {
            if (k % 2 == 0) {
                H->scat_pos[i].x = H->anchor_pos[k].x / r_lo * H->params.range_start;
                H->scat_pos[i].y = H->anchor_pos[k].y / r_lo * H->params.range_start;
                H->scat_pos[i].z = H->anchor_pos[k].z / r_lo * H->params.range_start;
                H->scat_pos[i].w = 0.0f;
                i++;
            }
        }
        if (i != (H->num_anchors - 1) / 2) {
            rsprint("WARNING. Inconsistency detected. H->num_anchors = %lu != %d\n", H->num_anchors, i);
        }
        const int anchors_per_layer = i;
        // Use the first plane and duplicate to the rest of the volume
        i = 0;
        for (n = 0; n < H->params.range_count; n++) {
            for (k = 0; k < anchors_per_layer; k++) {
                H->scat_uid[i].s0 = uid++;
                H->scat_uid[i].s1 = (cl_uint)H->num_scats;
                H->scat_uid[i].s2 = k;
                H->scat_uid[i].s3 = 0;
                
                H->scat_pos[i].x = H->scat_pos[k].x / H->params.range_start * (H->params.range_start + (float)n * H->params.range_delta);
                H->scat_pos[i].y = H->scat_pos[k].y / H->params.range_start * (H->params.range_start + (float)n * H->params.range_delta);
                H->scat_pos[i].z = H->scat_pos[k].z / H->params.range_start * (H->params.range_start + (float)n * H->params.range_delta);
                H->scat_pos[i].w = 0.0f;
                
                H->scat_aux[i].s0 = 0.0f;                                   // range
                H->scat_aux[i].s1 = (float)rand() / RAND_MAX;               // age
                H->scat_aux[i].s2 = 0.0f;                                   // dsd bin index
                H->scat_aux[i].s3 = 1.0f;                                   // angular weight [0.0, 1.0]
                
                H->scat_vel[i].x = 0.0f;                                    // u component of velocity
                H->scat_vel[i].y = 0.0f;                                    // v component of velocity
                H->scat_vel[i].z = 0.0f;                                    // w component of velocity
                H->scat_vel[i].w = 0.0f;                                    // n/a
                
                // At the reference
                H->scat_ori[i].x = 0.0f;                                    // x of quaternion
                H->scat_ori[i].y = 0.0f;                                    // y of quaternion
                H->scat_ori[i].z = 0.0f;                                    // z of quaternion
                H->scat_ori[i].w = 1.0f;                                    // w of quaternion

                // Tumbling vector for orientation update
                H->scat_tum[i].x = 0.0f;                                    // x of quaternion
                H->scat_tum[i].y = 0.0f;                                    // y of quaternion
                H->scat_tum[i].z = 0.0f;                                    // z of quaternion
                H->scat_tum[i].w = 1.0f;                                    // w of quaternion
                
                // Initial return from each point
                H->scat_rcs[i].s0 = 1.0e-10f;                               // sh_real of rcs
                H->scat_rcs[i].s1 = 0.0f;                                   // sh_imag of rcs
                H->scat_rcs[i].s2 = 1.0e-10f;                               // rcs.s2 = cn2
                H->scat_rcs[i].s3 = (float)rand() / RAND_MAX * 2.0 * M_PI;  // rcs.s3 = phi (accumulated phase)
                
                // Random seeds
                H->scat_rnd[i].s0 = rand();                                 // random seed
                H->scat_rnd[i].s1 = rand();                                 // random seed
                H->scat_rnd[i].s2 = rand();                                 // random seed
                H->scat_rnd[i].s3 = rand();                                 // random seed
                
                i++;
            }
        }
    } else {
        //
        // Initialize the scatter body positions & velocities
        //
        for (k = 0; k < H->num_types; k++) {
            for (w = 0; w < H->num_workers; w++) {
                
                i = (int)(H->offset[w] + H->workers[w].origins[k]);
                
                #ifdef DEBUG_HEAVY
                rsprint(RS_INDENT "type[%d]   workers[%d]   n = %d", k, w,  H->workers[w].counts[k]);
                #endif
                
                for (n = 0; n < H->workers[w].counts[k]; n++) {
                    H->scat_uid[i].s0 = uid++;
                    H->scat_uid[i].s1 = n;
                    H->scat_uid[i].s2 = k;
                    H->scat_uid[i].s3 = w;
                    
                    H->scat_pos[i].x = (float)rand() / RAND_MAX * domain.size.x + domain.origin.x;
                    H->scat_pos[i].y = (float)rand() / RAND_MAX * domain.size.y + domain.origin.y;
                    H->scat_pos[i].z = (float)rand() / RAND_MAX * domain.size.z + domain.origin.z;
                    H->scat_pos[i].w = 0.0f;                       // Use this to store drop radius in m
                    
                    H->scat_aux[i].s0 = 0.0f;                      // range
                    H->scat_aux[i].s1 = (float)rand() / RAND_MAX;  // age
                    H->scat_aux[i].s2 = 0.0f;                      // dsd bin index
                    H->scat_aux[i].s3 = 1.0f;                      // angular weight [0.0, 1.0]
                    
                    H->scat_vel[i].x = 0.0f;                       // u component of velocity
                    H->scat_vel[i].y = 0.0f;                       // v component of velocity
                    H->scat_vel[i].z = 0.0f;                       // w component of velocity
                    H->scat_vel[i].w = 0.0f;                       // n/a
                    
                    // At the reference
                    H->scat_ori[i].x = 0.0f;                       // x of quaternion
                    H->scat_ori[i].y = 0.0f;                       // y of quaternion
                    H->scat_ori[i].z = 0.0f;                       // z of quaternion
                    H->scat_ori[i].w = 1.0f;                       // w of quaternion
                    
                    #if defined(QUAT_INIT_FACE_SKY)
                    
                    // Facing the sky
                    H->scat_ori[i].x =  0.0f;                      // x of quaternion
                    H->scat_ori[i].y = -0.707106781186547f;        // y of quaternion
                    H->scat_ori[i].z =  0.0f;                      // z of quaternion
                    H->scat_ori[i].w =  0.707106781186548f;        // w of quaternion
                    
                    #elif defined(QUAT_INIT_OTHER)
                    
                    // Some other tests
                    H->scat_ori[i].x =  0.5f;                      // x of quaternion
                    H->scat_ori[i].y = -0.5f;                      // y of quaternion
                    H->scat_ori[i].z =  0.5f;                      // z of quaternion
                    H->scat_ori[i].w =  0.5f;                      // w of quaternion
                    
                    #elif defined(QUAT_INIT_ROTATE_THETA)
                    
                    // Rotate by theta
                    float theta = -70.0f / 180.0f * M_PI;
                    H->scat_ori[i].x = 0.0f;
                    H->scat_ori[i].y = sinf(0.5f * theta);
                    H->scat_ori[i].z = 0.0f;
                    H->scat_ori[i].w = cosf(0.5f * theta);
                    
                    #endif
                    
                    // Facing the beam
                    H->scat_ori[i].x =  0.5f;                      // x of quaternion
                    H->scat_ori[i].y = -0.5f;                      // y of quaternion
                    H->scat_ori[i].z = -0.5f;                      // z of quaternion
                    H->scat_ori[i].w =  0.5f;                      // w of quaternion
                    
                    // Tumbling vector for orientation update
                    H->scat_tum[i].x = 0.0f;                       // x of quaternion
                    H->scat_tum[i].y = 0.0f;                       // y of quaternion
                    H->scat_tum[i].z = 0.0f;                       // z of quaternion
                    H->scat_tum[i].w = 1.0f;                       // w of quaternion
                    
                    // Initial return from each point
                    H->scat_rcs[i].s0 = 1.0f;                      // sh_real of rcs
                    H->scat_rcs[i].s1 = 0.0f;                      // sh_imag of rcs
                    H->scat_rcs[i].s2 = 1.0f;                      // sv_real of rcs
                    H->scat_rcs[i].s3 = 0.0f;                      // sv_imag of rcs
                    
                    // Random seeds
                    H->scat_rnd[i].s0 = rand();                    // random seed
                    H->scat_rnd[i].s1 = rand();                    // random seed
                    H->scat_rnd[i].s2 = rand();                    // random seed
                    H->scat_rnd[i].s3 = rand();                    // random seed
                    
                    i++;
                }
            } // for (w = 0; w < H->num_workers; w++) ...
        } // for (k = 0; k < H->num_types; k++) ...
        
        // Volume of the simulation domain (m^3)
        float vol = H->sim_desc.s[RSSimulationDescriptionBoundSizeX] * H->sim_desc.s[RSSimulationDescriptionBoundSizeY] * H->sim_desc.s[RSSimulationDescriptionBoundSizeZ];
        
        // Re-initialize random seed
        srand(H->random_seed + H->random_seed);
        
        // Parameterized drop radius as scat_pos.w if DSD has been set
        // May want to add maximum relaxation time of each drop size
        // Potential places: vel.w, aux.s2
        float a;
        int bin;
        if (H->dsd_name != RSDropSizeDistributionUndefined) {
            float drops_per_scat = (vol * H->dsd_nd_sum) / H->counts[0];
            
            sprintf(H->summary + strlen(H->summary), "Drops / scatterer = %s  (%s / %s)\n", commafloat(drops_per_scat), commafloat((vol * H->dsd_nd_sum)), commaint(H->counts[0]));
            rsprint("Drops / scatterer = %s  (%s / %s)\n", commafloat(drops_per_scat), commafloat((vol * H->dsd_nd_sum)), commaint(H->counts[0]));
            
            // Store a copy of concentration scale in simulation description
            H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale] = sqrt(drops_per_scat);
            
            if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
                for (w = 0; w < H->num_workers; w++) {
                    i = (int)(H->offset[w] + H->workers[w].origins[0]);
                    for (n = 0; n < H->workers[w].counts[0]; n++) {
                        a = (float)rand() / RAND_MAX;
                        bin = (int)(a * (float)H->dsd_count);
                        H->dsd_pop[bin]++;
                        H->scat_pos[i].w = H->dsd_r[bin];                                  // set the drop radius
                        H->scat_aux[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // set the dsd bin index (temporary)
                        
                        i++;
                    }
                }
            } else {
                for (w = 0; w < H->num_workers; w++) {
                    i = (int)(H->offset[w] + H->workers[w].origins[0]);
                    for (n = 0; n < H->workers[w].counts[0]; n++) {
                        a = (float)rand() / RAND_MAX;
                        k = H->dsd_count;
                        bin = 0;
                        while (k > 0) {
                            k--;
                            if (a >= H->dsd_cdf[k]) {
                                bin = k;
                                break;
                            }
                        }
                        H->dsd_pop[bin]++;
                        H->scat_pos[i].w = H->dsd_r[bin];                                  // set the drop radius
                        H->scat_aux[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // set the dsd bin index
                        
                        i++;
                    }
                }
                
                #if defined(DEBUG_DSD)
                
                // Replace a few for debugging purpose
                H->scat_pos[0].w = 0.0025f;
                H->scat_pos[1].w = 0.001f;
                H->scat_pos[2].w = 0.0005f;
                
                #endif
                
            }
            
            sprintf(H->summary + strlen(H->summary),
                    "DSD specifications:\n");
            for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
                sprintf(H->summary + strlen(H->summary), "  o %.2f mm - P %.5f / %s particles\n", 2000.0f * H->dsd_r[i], (float)H->dsd_pop[i] / (float)H->counts[0], commaint(H->dsd_pop[i]));
            }
            if (H->dsd_count > 8) {
                sprintf(H->summary + strlen(H->summary), "  o  :      -      :     /  :     /\n");
                sprintf(H->summary + strlen(H->summary), "  o  :      -      :     /  :     /\n");
                i = MAX(4, H->dsd_count - 1);
            }
            for (; i < H->dsd_count; i++) {
                sprintf(H->summary + strlen(H->summary), "  o %.2f mm - P %.5f / %s particles\n", 2000.0f * H->dsd_r[i], (float)H->dsd_pop[i] / (float)H->counts[0], commaint(H->dsd_pop[i]));
            }
            
            if (H->verb) {
                rsprint("Actual DSD specifications:");
                for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
                    printf(RS_INDENT "o %.2f mm - PDF %.5f / %.5f / %s particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)H->dsd_pop[i] / (float)H->counts[0], commaint(H->dsd_pop[i]));
                }
                if (H->dsd_count > 8) {
                    printf(RS_INDENT "o  :      -      :     /  :     /\n");
                    printf(RS_INDENT "o  :      -      :     /  :     /\n");
                    i = MAX(4, H->dsd_count - 1);
                }
                for (; i < H->dsd_count; i++) {
                    printf(RS_INDENT "o %.2f mm - PDF %.5f / %.5f / %s particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)H->dsd_pop[i] / (float)H->counts[0], commaint(H->dsd_pop[i]));
                }
            }
        } else {
            rsprint("INFO: No DSD specified. The meteorological scatterers do not return any power.");
            float drops_per_scat = (vol * 1000.0f) / H->counts[0];
            
            sprintf(H->summary + strlen(H->summary), "Drops / scatterer = %s  (%s / %s)\n", commafloat(drops_per_scat), commafloat((vol * H->dsd_nd_sum)), commaint(H->counts[0]));
            rsprint("Drops / scatterer = %s  (%s / %s)\n", commafloat(drops_per_scat), commafloat((vol * H->dsd_nd_sum)), commaint(H->counts[0]));
        }
        
    } // if (H->sim_concept & RSSimulationConceptFixedScattererPosition) ...
    
    #if defined(DEBUG_RCS)

    // Replace a few points for debugging purpose.
    H->scat_pos[0].x = domain.origin.x + 0.5f * domain.size.x;
    H->scat_pos[0].y = domain.origin.y + 0.5f * domain.size.y;
    H->scat_pos[0].z = H->scat_pos[0].y * tanf(5.0f / 180.0f * M_PI);

    #endif
    
    #if defined(DEBUG_DEBRIS)

    // Replace the very first debris particle
    if (H->counts[1] > 0) {
        k = (int)H->counts[0];
        //printf("k = %d\n", k);
        H->scat_pos[k].x = 0.0f;
        H->scat_pos[k].y = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
        H->scat_pos[k].z = 0.5f * domain.size.z;
        
        H->scat_aux[k].s0 = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
    }

    #endif
    
    // Restore simulation time, default beam position at unit vector (0, 1, 0)
    H->sim_tic = 0.0f;
    H->sim_toc = H->vel_desc.tp;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = 1.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionTotalParticles] = H->num_scats;
    
    // Make a copy in float so we are maintaining all 32-bits
    float tmpf; memcpy(&tmpf, &H->sim_concept, sizeof(float));
    H->sim_desc.s[RSSimulationDescriptionConcept] = tmpf;
    
    // Propagate / duplicate some constants to other places for efficient kernel execution
    for (i = 0; i < H->num_workers; i++) {
        H->workers[i].range_weight_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionWaveNumber];
        H->workers[i].rcs_ellipsoid_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
    }
    
    // All tables must be ready at this point
    // - range weight table
    // - antenna weight table
    // - RCS of ellipsoid table
    // - RCS of debris table
    // - ADM of debris table
    // - 3D wind table
    RS_compute_rcs_ellipsoids(H);
    
    //
    // GPU memory allocation (probably should rename this to RS_worker_kernel_setup()
    //
    for (i = 0; i < H->num_workers; i++) {
        RS_worker_malloc(H, i);
    }
    
    #if defined (_USE_GCL_)
    
    CGLContextObj cgl_context = CGLGetCurrentContext();
    if (cgl_context == NULL) {
        rsprint("ERROR: No GL context yet.");
        return;
    }

    CGLShareGroupObj sharegroup = CGLGetShareGroup(cgl_context);
    if (sharegroup == NULL) {
        rsprint("ERROR: Sharegroup should have been set before.");
        return;
    }
    rsprint("RS_populate() - context %p   sharegroup %p", cgl_context, sharegroup);
    gcl_gl_set_sharegroup(sharegroup);
    rsprint("RS_populate() - gcl_gl_set_sharegroup() ... done");

    RS_derive_ndranges(H);
    
    #endif

    // Upload the particle parameters to the GPU
    RS_upload(H);
    
    if (H->verb) {
        rsprint("ADM / RCS count = %d / %d", H->adm_count, H->rcs_count);
        rsprint("CL domain synchronized.");
    }
    
    H->status |= RSStatusDomainPopulated;

    // Set initial scan position to be the very first position
    RS_advance_beam(H);

    // Advance time with 0 s so that all attributes kernels (bg_atts, fp_atts, el_atts, or db_atts) are called once but positions aren't updated.
    H->sim_desc.s[RSSimulationDescriptionPRT] = 0.0f;
    RS_advance_time(H);
    RS_make_pulse(H);
    if (H->verb > 2) {
        RS_download(H);
        RS_show_scat_att(H);
    }
    H->sim_desc.s[RSSimulationDescriptionPRT] = H->params.prt;

    // Now we undo that sim_tic counter due to RS_advance_time()
    H->sim_tic -= H->params.prt;
    H->sim_desc.s[RSSimulationDescriptionSimTic] = H->sim_tic;
    
    return;
}


void RS_download(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    //printf("%p <-----------------------\n", H->scat_ori);
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            gcl_memcpy(H->scat_pos + H->offset[i], H->workers[i].scat_pos, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_vel + H->offset[i], H->workers[i].scat_vel, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_ori + H->offset[i], H->workers[i].scat_ori, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_aux + H->offset[i], H->workers[i].scat_aux, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_rcs + H->offset[i], H->workers[i].scat_rcs, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_sig + H->offset[i], H->workers[i].scat_sig, H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->pulse_tmp[i], H->workers[i].pulse, H->params.range_count * sizeof(cl_float4));
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    int k;
    
    cl_event events[H->num_workers][7];
    
    // Non-blocking read, wait for events later when they are all queued up.
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_pos, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, &events[i][0]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_vel, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, &events[i][1]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_ori, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, &events[i][2]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_aux, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, &events[i][3]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_rcs, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_rcs + H->offset[i], 0, NULL, &events[i][4]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_sig, CL_FALSE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, &events[i][5]);
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].pulse, CL_FALSE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, &events[i][6]);
    }
    
    cl_int ret;
    
    for (i = 0; i < H->num_workers; i++) {
        ret = clWaitForEvents(7, events[i]);
        if (ret != CL_SUCCESS) {
            rsprint("ERROR: Unable to properly read back the values.");
        }
        for (k = 0; k < 7; k++) {
            clReleaseEvent(events[i][k]);
        }
    }
    
#endif
    
    RS_merge_pulse_tmp(H);
}


void RS_download_position_only(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            gcl_memcpy(H->scat_pos + H->offset[i], H->workers[i].scat_pos, H->workers[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_pos, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
    }
    
#endif
    
}

void RS_download_orientation_only(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            gcl_memcpy(H->scat_ori + H->offset[i], H->workers[i].scat_ori, H->workers[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].scat_ori, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
    }
    
#endif
    
}

void RS_merge_pulse_tmp(RSHandle *H) {
    memcpy(H->pulse, H->pulse_tmp[0], H->params.range_count * sizeof(cl_float4));
    for (int i = 1; i < H->num_workers; i++) {
        for (int k = 0; k < H->params.range_count; k++) {
            H->pulse[k].s0 += H->pulse_tmp[i][k].s0;
            H->pulse[k].s1 += H->pulse_tmp[i][k].s1;
            H->pulse[k].s2 += H->pulse_tmp[i][k].s2;
            H->pulse[k].s3 += H->pulse_tmp[i][k].s3;
        }
    }
    //
    // Scale the amplitude by antenna gain, tx power
    // Amplitude scaling, Ga = 10 ^ (Gt / 20) * 10 ^ (Gr / 20) * sqrt(Pt)
    // For dish antennas: Gt = Gr
    //
    //                  => g = 10 ^ (G / 20) * 10 ^ (G / 20) * sqrt(Pt)
    //                       = 10 ^ (G / 10) * sqrt(Pt)
    //
    // Amplitude scale to 1-km referece: sqrt(R ^ 4) = R ^ 2 = 1.0e6
    //
    float g = powf(10.0f, 0.1f * H->params.antenna_gain_dbi) * sqrtf(H->params.tx_power_watt) / (4.0f * M_PI) * 1.0e6f;
    //printf("** g = %.4e (linear unit)\n", g);
    for (int k = 0; k < H->params.range_count; k++) {
        H->pulse[k].s0 *= g;
        H->pulse[k].s1 *= g;
        H->pulse[k].s2 *= g;
        H->pulse[k].s3 *= g;
    }
}

void RS_download_pulse_only(RSHandle *H) {
    
    int i;
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            gcl_memcpy(H->pulse_tmp[i], H->workers[i].pulse, H->params.range_count * sizeof(cl_float4));
            dispatch_semaphore_signal(H->workers[i].sem);
        });
    }
    for (i = 0; i < H->num_workers; i++)
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    
#else
    
    // Blocking read since there is only one read
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->workers[i].que, H->workers[i].pulse, CL_TRUE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, NULL);
    }
    
#endif
    
    RS_merge_pulse_tmp(H);
}


void RS_upload(RSHandle *H) {
    
    int i;
    
    if (H->verb > 3) {
        for (i = 0; i < H->num_workers; i++) {
            rsprint("workers[%d].scat_pos @ %p\n", i, H->workers[i].scat_pos);
            rsprint("workers[%d].scat_vel @ %p\n", i, H->workers[i].scat_vel);
        }
        rsprint("scat_pos @ %p\n", H->scat_pos);
        rsprint("scat_vel @ %p\n", H->scat_vel);
    }
    
    if (H->num_scats == 0) {
        rsprint("Abort @ num_scats = 0 during RS_upload()\n");
        return;
    }
    
#if defined (_USE_GCL_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            gcl_memcpy(H->workers[i].scat_pos, H->scat_pos + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_vel, H->scat_vel + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_ori, H->scat_ori + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_tum, H->scat_tum + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_aux, H->scat_aux + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_rcs, H->scat_rcs + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_sig, H->scat_sig + H->offset[i], H->workers[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->workers[i].scat_rnd, H->scat_rnd + H->offset[i], H->workers[i].num_scats * sizeof(cl_uint4));
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    // Blocking write since there is no need to optimize this too much
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_pos, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_vel, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_ori, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_tum, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_tum + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_aux, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_rcs, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_rcs + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_sig, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->workers[i].que, H->workers[i].scat_rnd, CL_TRUE, 0, H->workers[i].num_scats * sizeof(cl_uint4),  H->scat_rnd + H->offset[i], 0, NULL, NULL);
    }
    
#endif
    
}


void RS_advance_time(RSHandle *H) {
    
    int i, k;
    int r, a;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("ERROR: Simulation domain not yet populated.");
        return;
    }
    
    // Advance to next wind table when the time comes
    if (H->sim_tic >= H->sim_toc) {
        H->sim_toc += H->vel_desc.tp;
        if (H->vel_idx == 0) {
            rsprint("Wind table restarted.");
        }
        for (i = 0; i < H->num_workers; i++) {
            H->workers[i].les_id = H->workers[i].les_id == 1 ? 0 : 1;
        }
        RS_set_vel_data_to_LES_table(H, LES_get_frame(H->L, H->vel_idx));
        H->vel_idx = H->vel_idx == H->vel_count - 1 ? 0 : H->vel_idx + 1;
        
        if (H->verb > 2) {
            rsprint("Wind table advanced. vel_idx = %d   ( tp = %.2f / prt = %.4f )  vel_id = %d", H->vel_idx, H->vel_desc.tp, H->params.prt, H->workers[0].les_id);
        }
    }
    
#if defined (_USE_GCL_)
    
#if defined (_DUMMY_)
    
    i = 0;
    k = 0;
    r = 0;
    a = 0;
    dispatch_async(H->workers[i].que, ^{
        dummy_kernel(&H->workers[i].ndrange_scat_all,
                     (cl_float4 *)H->workers[i].scat_pos,
                     (cl_float4 *)H->workers[i].scat_ori,
                     (cl_float4 *)H->workers[i].scat_rcs,
                     (cl_image)H->workers[i].rcs_real[r],
                     (cl_image)H->workers[i].rcs_imag[r],
                     H->workers[i].rcs_desc[r],
                     H->sim_desc);
        dispatch_semaphore_signal(H->workers[i].sem);
    });
    dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    
#elif defined (_ALL_DEBRIS_)
    
    i = 0;
    r = 0;
    a = 0;
    dispatch_async(H->workers[i].que, ^{
        db_atts_kernel(&H->workers[i].ndrange_scat_all,
                       (cl_float4 *)H->workers[i].scat_pos,
                       (cl_float4 *)H->workers[i].scat_ori,
                       (cl_float4 *)H->workers[i].scat_vel,
                       (cl_float4 *)H->workers[i].scat_tum,
                       (cl_float4 *)H->workers[i].scat_sig,
                       (cl_uint4 *)H->workers[i].scat_rnd,
                       (cl_image)H->workers[i].vel[H->workers[i].vel_id],
                       H->workers[i].vel_desc,
                       (cl_image)H->workers[i].adm_cd[a],
                       (cl_image)H->workers[i].adm_cm[a],
                       H->workers[i].adm_desc[a],
                       (cl_image)H->workers[i].rcs_real[r],
                       (cl_image)H->workers[i].rcs_imag[r],
                       H->workers[i].rcs_desc[r],
                       H->sim_desc);
        dispatch_semaphore_signal(H->workers[i].sem);
    });
    dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    
#else
    
    // These kernels are actually independent and, thus, can be parallelized.
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->workers[i].que, ^{
            if (H->sim_concept & RSSimulationConceptDraggedBackground) {
                el_atts_kernel(&H->workers[i].ndrange_scat[0],
                               (cl_float4 *)H->workers[i].scat_pos,
                               (cl_float4 *)H->workers[i].scat_vel,
                               (cl_float4 *)H->workers[i].scat_rcs,
                               (cl_uint4 *)H->workers[i].scat_rnd,
                               (cl_image)H->workers[i].les_uvwt[H->workers[i].les_id],
                               (cl_image)H->workers[i].les_cpxx[H->workers[i].les_id],
                               H->workers[i].les_desc,
                               (cl_float4 *)H->workers[i].rcs_ellipsoid,
                               H->workers[i].rcs_ellipsoid_desc,
                               H->sim_desc);
            } else {
                bg_atts_kernel(&H->workers[i].ndrange_scat[0],
                               (cl_float4 *)H->workers[i].scat_pos,
                               (cl_float4 *)H->workers[i].scat_vel,
                               (cl_float4 *)H->workers[i].scat_rcs,
                               (cl_uint4 *)H->workers[i].scat_rnd,
                               (cl_image)H->workers[i].les_uvwt[H->workers[i].les_id],
                               (cl_image)H->workers[i].les_cpxx[H->workers[i].les_id],
                               H->workers[i].les_desc,
                               (cl_float4 *)H->workers[i].rcs_ellipsoid,
                               H->workers[i].rcs_ellipsoid_desc,
                               H->sim_desc);
            }
            dispatch_semaphore_signal(H->workers[i].sem);
        });
        
        r = 0;
        a = 0;
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->workers[i].counts[k]) {
                dispatch_async(H->workers[i].que, ^{
                    db_atts_kernel(&H->workers[i].ndrange_scat[k],
                                   (cl_float4 *)H->workers[i].scat_pos,
                                   (cl_float4 *)H->workers[i].scat_ori,
                                   (cl_float4 *)H->workers[i].scat_vel,
                                   (cl_float4 *)H->workers[i].scat_tum,
                                   (cl_float4 *)H->workers[i].scat_rcs,
                                   (cl_uint4 *)H->workers[i].scat_rnd,
                                   (cl_image)H->workers[i].les_uvwt[H->workers[i].les_id],
                                   H->workers[i].les_desc,
                                   (cl_image)H->workers[i].adm_cd[a],
                                   (cl_image)H->workers[i].adm_cm[a],
                                   H->workers[i].adm_desc[a],
                                   (cl_image)H->workers[i].rcs_real[r],
                                   (cl_image)H->workers[i].rcs_imag[r],
                                   H->workers[i].rcs_desc[r],
                                   H->sim_desc);
                    dispatch_semaphore_signal(H->workers[i].sem);
                });
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->workers[i].counts[k]) {
                dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
            }
        }
    }
    
#endif
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE][H->num_types];
    memset(events, 0, sizeof(events));
    
    for (i = 0; i < H->num_workers; i++) {
        r = 0;
        a = 0;
        
        // A convenient pointer to reduce dereferencing
        RSWorker *C = &H->workers[i];
        
        // Need to refresh some parameters of the background at each time update
        if (H->sim_concept & RSSimulationConceptDraggedBackground) {
            clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->les_uvwt[C->les_id]);
            clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure, sizeof(cl_mem),     &C->les_cpxx[C->les_id]);
            clSetKernelArg(C->kern_el_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_el_atts, 1, &C->origins[0], &C->counts[0], NULL, 0, NULL, &events[i][0]);
        } else if (H->sim_concept & RSSimulationConceptFixedScattererPosition) {
            clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->les_uvwt[C->les_id]);
            clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure, sizeof(cl_mem),     &C->les_cpxx[C->les_id]);
            clSetKernelArg(C->kern_fp_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_fp_atts, 1, &C->origins[0], &C->counts[0], NULL, 0, NULL, &events[i][0]);
        } else {
            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->les_uvwt[C->les_id]);
            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundCn2Pressure, sizeof(cl_mem),     &C->les_cpxx[C->les_id]);
            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_bg_atts, 1, &C->origins[0], &C->counts[0], NULL, 0, NULL, &events[i][0]);
        }
        
        // Debris particles
        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->les_uvwt[C->les_id]);
        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        for (k = 1; k < H->num_types; k++) {
            if (C->counts[k]) {
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->origins[k], &C->counts[k], NULL, 0, NULL, &events[i][k]);
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->workers[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        for (k = 0; k < H->num_types; k++) {
            if (H->workers[i].counts[k]) {
                clWaitForEvents(1, &events[i][k]);
                clReleaseEvent(events[i][k]);
            }
        }
    }
    
#endif

    H->sim_tic += H->params.prt;
    H->sim_desc.s[RSSimulationDescriptionSimTic] = H->sim_tic;
    H->status |= RSStatusScattererSignalNeedsUpdate;
}


void RS_advance_beam(RSHandle *H) {
    POSPattern *scan = H->P;
    POS_get_next_angles(scan);
    RS_set_beam_pos(H, scan->az, scan->el);
}


void RS_make_pulse(RSHandle *H) {
    
    int i, k;
    int r, a;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        rsprint("ERROR: Simulation domain not populated.");
        return;
    }
    
#if defined (_USE_GCL_)
    
    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->workers[i];
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    dispatch_async(C->que, ^{
                        db_rcs_kernel(&C->ndrange_scat[k],
                                      (cl_float4 *)C->scat_pos,
                                      (cl_float4 *)C->scat_ori,
                                      (cl_float4 *)C->scat_rcs,
                                      (cl_image)H->workers[i].rcs_real[r],
                                      (cl_image)H->workers[i].rcs_imag[r],
                                      H->workers[i].rcs_desc[r],
                                      H->sim_desc);
                        dispatch_semaphore_signal(C->sem);
                    });
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->workers[i];
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    dispatch_semaphore_wait(C->sem, DISPATCH_TIME_FOREVER);
                }
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            RSWorker *C = &H->workers[i];
            dispatch_async(C->que, ^{
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
                dispatch_semaphore_signal(C->sem);
            });
        }
        for (i = 0; i < H->num_workers; i++) {
            dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
        }
    }
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->workers[i];
        dispatch_async(C->que, ^{
            if (H->status & RSStatusScattererSignalNeedsUpdate) {
                //printf("RS_make_pulse: kern_scat_sig_aux\n");
                scat_sig_aux_kernel(&C->ndrange_scat_all,
                                    (cl_float4 *)C->scat_sig,
                                    (cl_float4 *)C->scat_aux,
                                    (cl_float4 *)C->scat_pos,
                                    (cl_float4 *)C->scat_rcs,
                                    (cl_float *)C->angular_weight,
                                    C->angular_weight_desc,
                                    H->sim_desc);
            }
            make_pulse_pass_1_kernel(&C->ndrange_pulse_pass_1,
                                     (cl_float4 *)C->work,
                                     (cl_float4 *)C->scat_sig,
                                     (cl_float4 *)C->scat_aux,
                                     C->make_pulse_params.local_mem_size[0],
                                     (cl_float *)C->range_weight,
                                     C->range_weight_desc,
                                     C->make_pulse_params.range_start,
                                     C->make_pulse_params.range_delta,
                                     C->make_pulse_params.range_count,
                                     C->make_pulse_params.group_counts[0],
                                     C->make_pulse_params.entry_counts[0]);
            switch (C->make_pulse_params.cl_pass_2_method) {
                case RS_CL_PASS_2_IN_LOCAL:
                    make_pulse_pass_2_local_kernel(&C->ndrange_pulse_pass_2,
                                                   (cl_float4 *)C->pulse,
                                                   (cl_float4 *)C->work,
                                                   C->make_pulse_params.local_mem_size[1],
                                                   C->make_pulse_params.range_count,
                                                   C->make_pulse_params.entry_counts[1]);
                    break;
                case RS_CL_PASS_2_IN_RANGE:
                    make_pulse_pass_2_range_kernel(&C->ndrange_pulse_pass_2,
                                                   (cl_float4 *)C->pulse,
                                                   (cl_float4 *)C->work,
                                                   C->make_pulse_params.local_mem_size[1],
                                                   C->make_pulse_params.range_count,
                                                   C->make_pulse_params.entry_counts[1]);
                    break;
                default:
                    make_pulse_pass_2_group_kernel(&C->ndrange_pulse_pass_2,
                                                   (cl_float4 *)C->pulse,
                                                   (cl_float4 *)C->work,
                                                   C->make_pulse_params.local_mem_size[1],
                                                   C->make_pulse_params.range_count,
                                                   C->make_pulse_params.entry_counts[1]);
                    break;
            }
            dispatch_semaphore_signal(C->sem);
        });
    }
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->workers[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    cl_event events[H->num_workers][MAX(H->num_types, 3)];
    memset(events, 0, sizeof(events));
    
    // In this implementation, kern_make_pulse_pass_2 should point to kern_make_pulse_pass_2_group, kern_make_pulse_pass_2_local or kern_make_pulse_pass_2_range,
    // which had been selected based on the group size in RS_make_pulse_params()
    if (H->status & RSStatusDebrisRCSNeedsUpdate) {
        // Update all the debris RCS
        for (i = 0; i < H->num_workers; i++) {
            r = 0;
            a = 0;
            RSWorker *C = &H->workers[i];
            for (k = 1; k < H->num_types; k++) {
                if (C->counts[k]) {
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
                    clSetKernelArg(C->kern_db_rcs, RSDebrisRCSKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
                    clEnqueueNDRangeKernel(C->que, C->kern_db_rcs, 1, &C->origins[k], &C->counts[k], NULL, 0, NULL, &events[i][k]);
                }
                r = r == H->rcs_count - 1 ? 0 : r + 1;
                a = a == H->adm_count - 1 ? 0 : a + 1;
            }
        }
        for (i = 0; i < H->num_workers; i++) {
            clFlush(H->workers[i].que);
        }
        for (i = 0; i < H->num_workers; i++) {
            for (k = 1; k < H->num_types; k++) {
                if (H->workers[i].counts[k]) {
                    clWaitForEvents(1, &events[i][k]);
                    clReleaseEvent(events[i][k]);
                }
            }
        }
        H->status |= RSStatusScattererSignalNeedsUpdate;
    }
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->workers[i];
        if (H->status & RSStatusScattererSignalNeedsUpdate) {
            //printf("RS_make_pulse() kern_scat_sig_aux : %zu   sim_tic = %.4f\n", C->num_scats, H->sim_tic);
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][0]);
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 1, &events[i][0], &events[i][1]);
        } else {
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 0, NULL, &events[i][1]);
        }
        clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_2, 1, NULL, &C->make_pulse_params.global[1], &C->make_pulse_params.local[1], 1, &events[i][1], &events[i][2]);
    }
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->workers[i].que);
    }
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][2]);
        if (H->status & RSStatusScattererSignalNeedsUpdate)
            clReleaseEvent(events[i][0]);
        clReleaseEvent(events[i][1]);
        clReleaseEvent(events[i][2]);
    }
    
#endif
    
    H->status &= ~RSStatusDebrisRCSNeedsUpdate;
    H->status &= ~RSStatusScattererSignalNeedsUpdate;
}


#pragma mark -
#pragma mark Elements for table lookup

RSTable RS_table_init(size_t numel) {
    RSTable table = {0.0f, 1.0f, 1.0f, 0, NULL};
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(float))) {
        rsprint("ERROR: Unable to allocate an RSTable->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table_free(RSTable T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable2D RS_table2d_init(size_t numel) {
    RSTable2D table;
    
    table.xs = 1.0f;      table.ys = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        rsprint("ERROR: Unable to allocate an RSTable2D->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table2d_free(RSTable2D T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable3D RS_table3d_init(size_t numel) {
    RSTable3D table;
    
    table.spacing = RSTableSpacingUniform;
    
    table.xs = 1.0f;      table.ys = 1.0f;      table.zs = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;      table.zo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;      table.zm = 1.0f;
    
    if (posix_memalign((void **)&table.uvwt, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        rsprint("ERROR: Unable to allocate an RSTable3D->uvwt.\n", now());
        return table;
    }
    if (posix_memalign((void **)&table.cpxx, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        rsprint("ERROR: Unable to allocate an RSTable3D->cpxx.\n", now());
        return table;
    }

    return table;
}


void RS_table3d_free(RSTable3D T) {
    if (T.uvwt != NULL) {
        free(T.uvwt);
        T.uvwt = NULL;
    }
    if (T.cpxx != NULL) {
        free(T.cpxx);
        T.cpxx = NULL;
    }
}


#pragma mark -
#pragma mark Display

void RS_show_radar_params(RSHandle *H) {
    rsprint("Radar Parameters:\n");
    printf(RS_INDENT "o beamwidth = %4.2f deg      o dr = %.2f m\n", H->params.antenna_bw_deg, H->params.dr);
    printf(RS_INDENT "o lambda = %4.2f m           o PRT = %.2f ms      o va = %.2f m/s\n", H->params.lambda, H->params.prt * 1.0e3f, H->params.va);
}


static void RS_show_scat_i(RSHandle *H, const size_t i) {
    printf(" [%7d %7d %5d %d]   p( %9.2f, %9.2f, %9.2f, %4.1f )  v( %7.2f %7.2f %7.2f )   o( %7.4f %7.4f %7.4f %7.4f)\n",
           H->scat_uid[i].x, H->scat_uid[i].y, H->scat_uid[i].z, H->scat_uid[i].w,
           H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, 2000.0f * H->scat_pos[i].w,
           H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w);
}


static void RS_show_rcs_i(RSHandle *H, const size_t i) {
    printf(" [%7d %7d %5d %d]   s( %10.3e, %10.3e, %10.3e, %10.3e )   x( %10.3e %10.3e %10.3e %10.3e )   r = %.2f m  d = %.1f mm\n",
           H->scat_uid[i].x, H->scat_uid[i].y, H->scat_uid[i].z, H->scat_uid[i].w,
           H->scat_sig[i].x, H->scat_sig[i].y, H->scat_sig[i].z, H->scat_sig[i].w,
           H->scat_rcs[i].x, H->scat_rcs[i].y, H->scat_rcs[i].z, H->scat_rcs[i].w,
           H->scat_aux[i].s0, 2000.0f * H->scat_pos[i].w);
}


static void RS_show_att_i(RSHandle *H, const size_t i) {
    printf(" [%7d %7d %5d %4d]   p( %9.2f, %9.2f, %9.2f, %4.1f )   v( %7.2f %7.2f %7.2f )   o( %7.4f %7.4f %7.4f %7.4f)   s( %10.3e, %10.3e, %10.3e, %10.3e )   x( %10.3e %10.3e %10.3e %10.3e )   a( %10.3e %10.3e %10.3e %10.3e )\n",
           H->scat_uid[i].x, H->scat_uid[i].y, H->scat_uid[i].z, H->scat_uid[i].w,
           H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, 2000.0f * H->scat_pos[i].w,
           H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w,
           H->scat_sig[i].x, H->scat_sig[i].y, H->scat_sig[i].z, H->scat_sig[i].w,
           H->scat_rcs[i].x, H->scat_rcs[i].y, H->scat_rcs[i].z, H->scat_rcs[i].w,
           H->scat_aux[i].x, H->scat_aux[i].y, H->scat_aux[i].z, H->scat_aux[i].w);
}


void RS_show_scat_pos(RSHandle *H) {
    size_t i, w;
    printf("A subset of meteorological scatterer POS, VEL & ORI:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = H->workers[w].origins[0];
             i < H->workers[w].origins[0] + H->workers[w].counts[0];
             i += H->workers[w].counts[0] / RS_SHOW_DIV) {
            RS_show_scat_i(H, H->offset[w] + i);
        }
    }
    if (H->counts[1] == 0) {
        return;
    }
    printf("A subset of debris[1] POS, VEL & ORI:\n");
    for (w = 0; w < H->num_workers; w++) {
        if (H->workers[w].counts[1]) {
            for (i = H->workers[w].origins[1];
                 i < H->workers[w].origins[1] + H->workers[w].counts[1];
                 i += H->workers[w].counts[1] / RS_SHOW_DIV) {
                RS_show_scat_i(H, H->offset[w] + i);
            }
        }
    }
}


void RS_show_scat_sig(RSHandle *H) {
    size_t i, w;
    printf("A subset of meteorological scatterer SIG, RCS & AUX:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->workers[w].counts[0]; i += H->workers[w].counts[0] / RS_SHOW_DIV) {
            RS_show_rcs_i(H, H->offset[w] + H->workers[w].origins[0] + i);
        }
    }
    if (H->counts[1] == 0) {
        return;
    }
    printf("A subset of debris[1] scatterer SIG, RCS, & AUX:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->workers[w].counts[1]; i += H->workers[w].counts[1] / RS_SHOW_DIV) {
            RS_show_rcs_i(H, H->offset[w] + H->workers[w].origins[1] + i);
        }
    }
}


void RS_show_scat_att(RSHandle *H) {
    size_t i, w;
    printf("A subset of meteorological scatterer POS, VEL, ORI, SIG, RCS, and AUX:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->workers[w].counts[0]; i += H->workers[w].counts[0] / RS_SHOW_DIV) {
            RS_show_att_i(H, H->offset[w] + H->workers[w].origins[0] + i);
        }
    }
    if (H->counts[1] == 0) {
        return;
    }
    printf("A subset of debris[1] scatterer POS, VEL, ORI, SIG, RCS, and AUX:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->workers[w].counts[1]; i += H->workers[w].counts[1] / RS_SHOW_DIV) {
            RS_show_att_i(H, H->offset[w] + H->workers[w].origins[1] + i);
        }
    }
}


void RS_show_pulse(RSHandle *H) {
    unsigned int i;
    printf(" %7.5fs - [", H->sim_tic);
    for (i = 0; i < MIN(4, H->params.range_count); i++) {
        if (i > 0) {
            printf(",");
        }
        printf(" %9.2f", H->pulse[i].s0);
    }
    if (i < H->params.range_count) {
        printf(",  . . . , %9.2f", H->pulse[H->params.range_count - 1].s0);
    }
    printf(" ] (%d)\n", H->params.range_count);
}

#pragma mark -

RSBox RS_suggest_scan_domain(RSHandle *H) {
    RSBox box;
    memset(&box, 0, sizeof(RSBox));

    if (H->P == NULL) {
        rsprint("WARNING. No scanning pattern for RS_set_scan_pattern().\n");
        rsprint("WARNING. Using a default PPI scan pattern.\n");
        H->P = POS_init();
    }

    if (H->L == NULL) {
        RS_set_vel_data_to_config(H, LESConfigSuctionVortices);
    }
    
    if (H->verb > 1) {
        rsprint("RS_suggest_scan_domain()");
    }
    
    // Extremas of the domain
    float w = 0.0f, h = 0.0f;
    float na = 0.0f, ne = 0.0f, nr = 0.0f;

    POSPattern *scan = H->P;
    
    // Extremas of the domain
    if (H->vel_desc.is_stretched) {
        w = H->vel_desc.ax * (1.0f - powf(H->vel_desc.rx, 0.5f * (float)(H->vel_desc.nx - 3))) / (1.0f - H->vel_desc.rx);
        h = H->vel_desc.az * (1.0f - powf(H->vel_desc.rz,        (float)(H->vel_desc.nz - 1))) / (1.0f - H->vel_desc.rz);
    } else {
        w = 0.5f * H->vel_desc.nx * H->vel_desc.rx;
        h = H->vel_desc.nz * H->vel_desc.rz;
    }
    
    //if (POS_is_dbs(scan)) {
    if (H->sim_concept & RSSimulationConceptVerticallyPointingRadar) {

        //printf("range_delta = %.2f\n", H->params.range_delta);
        
        // Go through the DBS pattern
        float emin = 90.0f;
        float emax = 0.0f;
        float rmin = 100.0f;
        float rmax = ceilf((2000.0f - rmin) / (2.0f * H->params.range_delta)) * 2.0f * H->params.range_delta;
        
        int j = 0;
        while (j < scan->count) {
            emin = MIN(emin, scan->positions[j].el);
            emax = MAX(emax, scan->positions[j].el);
            j++;
        }
        //rsprint("scan_count = %d   emin = %.2f   emax = %.2f   rmin = %.2f   rmax = %.2f\n", scan->count, emin, emax, rmin, rmax);

        //w = rmax * cos(emin / 180.0f * M_PI);
        //h = rmax * sin(emax / 180.0f * M_PI);
        if (rmax * cos(emin / 180.0f * M_PI) > w) {
            rsprint("WARNING. Elevation %.2f at %.2f m exceeds the LES domain width = %.2f.\n", emin, rmax, w);
        }
        if (rmax * sin(emax / 180.0f * M_PI) > h) {
            rsprint("WARNING. Elevation %.2f at %.2f m exceeds the LES domain height = %.2f.\n", emax, rmax, h);
        }

        na = 360.0f;
        ne = ceilf((emax - emin) / H->params.antenna_bw_deg);
        nr = ceilf((rmax - rmin) / H->params.dr * 0.5f) * 2.0f;

        box.origin.a = 0.0f;
        box.size.a = 360.0f;
        
        box.origin.e = emin;
        box.size.e = emax - emin;
        
        box.origin.r = rmax - (nr + RS_DOMAIN_PAD - 1.0f) * H->params.dr;
        box.size.r = floorf(nr - RS_DOMAIN_PAD - 1.0f) * H->params.dr;

    } else {

        // TO DO:
        // Derive azimuth swath based on POSPattern
        //
        // ...
        
        const int nbeams = 16;
        
        // Maximum number of beams plus the padding on one side in azimuth
        na = 0.5f * (float)nbeams + RS_DOMAIN_PAD + 0.5f;
        
        // Maximum number of beams in elevation
        ne = 18.0f;
        
        // Maximum y of the emulation box: The range when the width is fully utilized; This is also rmax
        float rmax = w / sinf(na * H->params.antenna_bw_rad);
        
        // Minimum y of the emulation box: The range when the height is fully utilized
        float rmin = (rmax - 2.0f * w) / cosf(na * H->params.antenna_bw_rad) / cosf(ne * H->params.antenna_bw_rad);
        
        // If we cannot respect the padding on both sides
        // Maximum number of range cells minus the padding on both sides minus one radar cell
        nr = (rmax - rmin) / H->params.dr - 2.0f * RS_DOMAIN_PAD - 1.0f;
        nr = ceilf(nr * 0.5f) * 2.0f;
        if (rmax - rmin < 8.0f * H->params.dr) {
            rsprint("ERROR: Range resolution of the radar is too coarse!");
            rsprint("rmax = %.3f  rmin = %.3f   dr = %.2f", rmax, rmin, H->params.dr);
        }
        
        box.origin.a = ceilf(-0.5f * (float)nbeams) * H->params.antenna_bw_rad * 180.0f / M_PI;
        box.size.a = nbeams * H->params.antenna_bw_deg;
        
        box.origin.r = rmax - (nr + 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;
        box.size.r = floorf(nr - 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;
        
        box.origin.e = 0.0f;
        box.size.e = ne * H->params.antenna_bw_deg;

    }
    
    if (H->verb) {
        printf("%s : RS : Suggest scan box < [ 2w = %.1f m, h = %.1f m ]   nr = %.1f   na = %.1f   ne = %.1f\n"
               "%s : RS : Best fit with R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %6.2f ~ %6.2f ] deg\n",
               now(), 2.0f * w, h, nr, na, ne,
               now(), 1.0e-3f * box.origin.r, 1.0e-3f * (box.origin.r + box.size.r), box.origin.e, box.origin.e + box.size.e, box.origin.a, box.origin.a + box.size.a);
    }
    
    return box;
}


void RS_compute_rcs_ellipsoids(RSHandle *H) {
    
    int i;
    
    const cl_double k_0 = H->sim_desc.s[RSSimulationDescriptionWaveNumber] * 0.5f;
    const cl_double epsilon_0 = 8.85418782e-12f;
    const cl_double4 epsilon_r_minus_one = (cl_double4){{78.669, 18.2257, 78.669, 18.2257}};
    
    if (H->verb > 1) {
        rsprint("RS_compute_rcs_ellipsoids()\n");
    }
    
    //
    // Sc = k_0 ^ 2 / (4 * pi * epsilon_0)
    // Coefficient 1.0e-9 for scaling the volume to unit of m^3
    //
    if (H->verb) {
        rsprint("Drop concentration scaling = %s  (k_0 = %.4f)\n", commafloat(H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale]), k_0);
    }
    const cl_double sc = k_0 * k_0 / (4.0f * M_PI * epsilon_0) * 1.0e-9f * H->sim_desc.s[RSSimulationDescriptionDropConcentrationScale];
    
    // Make table with D = 0.5mm, 0.6mm, ... 10.0mm (96 entries)
    const size_t n = 96;
    
    cl_float4 *table = (cl_float4 *)malloc(n * sizeof(cl_float4));
    
    if (H->sim_concept & RSSimulationConceptTransparentBackground) {
        memset(table, 0, n * sizeof(cl_float4));
    } else {
        for (i = 0; i < n; i++) {
            // Diameter (mm) to be computed
            cl_double d = 0.5 + (cl_double)i * 0.1;
            cl_double d2 = d * d;
            cl_double d3 = d2 * d;
            cl_double d4 = d3 * d;
            cl_double rba = 1.0048 + (0.0057e-1 * d) - (2.628e-2 * d2) + (3.682e-3 * d3) - (1.677e-4 * d4);
            cl_double rab = 1.0f / rba;
            cl_double fsq = rab * rab - 1.0;
            cl_double f = sqrt(fsq);
            cl_double lz = (1.0 + fsq) / fsq * (1.0 - atan(f) / f);
            cl_double lx = (1.0 - lz) * 0.5;
            cl_double vol = M_PI * d3 / 6.0;
            cl_double4 numer = double_complex_multiply((cl_double4){{vol * epsilon_0, 0.0, vol * epsilon_0, 0.0}}, epsilon_r_minus_one);
            cl_double4 denom = {{
                lx * epsilon_r_minus_one.s0 + 1.0,
                lx * epsilon_r_minus_one.s1,
                lz * epsilon_r_minus_one.s2 + 1.0,
                lz * epsilon_r_minus_one.s3
            }};
            cl_double4 alxz = double_complex_divide(numer, denom);
            // Reduced precision at the very last step
            table[i].s0 = (cl_float)(sc * alxz.s0);
            table[i].s1 = (cl_float)(sc * alxz.s1);
            table[i].s2 = (cl_float)(sc * alxz.s2);
            table[i].s3 = (cl_float)(sc * alxz.s3);
            
#ifdef DEBUG_HEAVY

            rsprint("D = %.2fmm  rba %.4f  rab %.4f  lz %.4f  lx %.4f  numer = %.3e %.3e %.3e %.3e  denom = %.3f %.3f %.3f %.3f  alxz = %.3e %.3e %.3e %.3e  lx/lz = %.3e %.3e %.3e %.3e",
                    d, rba, rab, lz, lx, numer.s0, numer.s1, numer.s2, numer.s3, denom.s0, denom.s1, denom.s2, denom.s3, alxz.s0, alxz.s1, alxz.s2, alxz.s3, table[i].s0, table[i].s1, table[i].s2, table[i].s3);

#endif
        }
        
        // Each size has same probably of occurence, the return power is scaled by the ratio of the
        if (H->sim_concept & RSSimulationConceptUniformDSDScaledRCS) {
            
            int k;
            float s;
            const float p = 1.0f / (float)H->dsd_count;
            cl_float4 *table_copy = (cl_float4 *)malloc(n * sizeof(cl_float4));
            memcpy(table_copy, table, n * sizeof(cl_float4));
            memset(table, 0, n * sizeof(cl_float4));
            
            if (H->dsd_count) {
                snprintf(H->summary + strlen(H->summary), sizeof(H->summary), "Drop RCS Scaling:\n");
                for (i = 0; i < H->dsd_count; i++) {
                    k = (int)(H->dsd_r[i] * 20000.0f) - 5;
                    s = sqrtf(H->dsd_pdf[i] / p);
                    if (H->verb) {
                        printf(RS_INDENT "o %.2f mm scale by %.4f / %.4f = %.4f = %.2f dB  k = %d\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], p, s, 20.0f * log10f(s), k);
                    }
                    snprintf(H->summary + strlen(H->summary), sizeof(H->summary), "  o %.2f mm %.5f -> %.2f dB\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], 20.0f * log10f(s));
                    table[k].s0 = table_copy[k].s0 * s;
                    table[k].s1 = table_copy[k].s1 * s;
                    table[k].s2 = table_copy[k].s2 * s;
                    table[k].s3 = table_copy[k].s3 * s;
                }
            }
            
#ifdef DEBUG_HEAVY

            for (i = 0; i < n; i++) {
                cl_double d = 0.5 + (cl_double)i * 0.1;
                rsprint("D = %.2fmm  %.3e %.3e %.3e %.3e --> %.3e %.3e %.3e %.3e", d, table_copy[i].s0, table_copy[i].s1, table_copy[i].s2, table_copy[i].s3, table[i].s0, table[i].s1, table[i].s2, table[i].s3);
            }

#endif
            
            free(table_copy);
        }
    }
    
    // Set table lookup in radius in mm
    RS_set_rcs_ellipsoid_table(H, table, 0.25e-3f, 0.05e-3f, n);
    
    free(table);
}


char *RS_simulation_description(RSHandle *H) {
    char *c = H->summary + strlen(H->summary) - 1;
    if (*c == '\n') {
        *c = 0;
    }
    return H->summary;
}
