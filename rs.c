//
//  rs.c
//  Radar Simulation Framework
//
//  Created by Boon Leng Cheong.
//

#include "rs.h"
#include "rs_priv.h"

// The block declaration is automatically generated by XCode
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
#include "rs.cl.h"
#endif

#pragma mark -
#pragma mark Private Functions

void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, const char verb) {
	
    C->dev = dev;
    C->verb = verb;
    C->mem_size = 0;
    
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &C->num_cus, NULL);

#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    // A queue & semaphore for the CL work
    C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, C->dev);
    C->sem = dispatch_semaphore_create(0);
    
    if (C->sem == NULL) {
        fprintf(stderr, "%s : RS : Error creating semaphore for the CL worker.\n", now());
        return;
    }
    
    // Set all the surface to null
    int i;
    for (i = 0; i < RS_MAX_VEL_TABLES; i++) {
        C->surf_vel[i] = NULL;
    }
    for (i = 0; i < RS_MAX_ADM_TABLES; i++) {
        C->surf_adm_cd[i] = NULL;
        C->surf_adm_cm[i] = NULL;
    }
    for (i = 0; i < RS_MAX_RCS_TABLES; i++) {
        C->surf_rcs_real[i] = NULL;
        C->surf_rcs_imag[i] = NULL;
    }
    
#else
	
    cl_int ret;

    #if defined (GUI)

    CGLContextObj context = CGLGetCurrentContext();
    CGLShareGroupObj obj = CGLGetShareGroup(context);
    
    cl_context_properties prop[] = {
        CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE,
        (cl_context_properties)obj, 0
    };
    
    // Create a context from a CGL share group
    C->context = clCreateContext(prop, 1, &C->dev, &pfn_notify, NULL, &ret);

    #else

    // Create an independent OpenCL context
    C->context = clCreateContext(NULL, 1, &C->dev, &pfn_notify, NULL, &ret);

    #endif

    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL context.  ret = %d\n", now(), ret);
        exit(EXIT_FAILURE);
    } else if (verb) {
        printf("%s : RS : OpenCL context[%d] created (context @ %p, device_id @ %p).\n", now(), (int)C->name, C->context, dev);
    }
    

    // Program
    C->prog = clCreateProgramWithSource(C->context, src_size, (const char **)src_ptr, NULL, &ret);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL program.  ret = %d\n", now(), ret);
        clReleaseContext(C->context);
        return;
    }
    if (verb) {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", &pfn_prog_notify, NULL);
    } else {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", NULL, NULL);
    }

    if (ret != CL_SUCCESS) {
        char char_buf[RS_MAX_STR] = "";
        clGetProgramBuildInfo(C->prog, C->dev, CL_PROGRAM_BUILD_LOG, RS_MAX_STR, char_buf, NULL);
        fprintf(stderr, "%s : RS : CL Compilation failed:\n%s", now(), char_buf);
        clReleaseProgram(C->prog);
        clReleaseContext(C->context);
        return;
    } else if (verb) {
        printf("%s : RS : OpenCL program[%d] created (program @ %p).\n", now(), (int)C->name, C->prog);
    }
	
#define CHECK_CL_CREATE_KERNEL                                                               \
    if (ret != CL_SUCCESS) {                                                                 \
        fprintf(stderr, "%s : RS : Error creating OpenCL kernel.  ret = %d\n", now(), ret);  \
        clReleaseProgram(C->prog);                                                           \
        clReleaseContext(C->context);                                                        \
        return;                                                                              \
    }

    // Tie all kernels to the program
    C->kern_io = clCreateKernel(C->prog, "io", &ret);                                             CHECK_CL_CREATE_KERNEL
    C->kern_dummy = clCreateKernel(C->prog, "dummy", &ret);                                       CHECK_CL_CREATE_KERNEL
    C->kern_bg_atts = clCreateKernel(C->prog, "bg_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_el_atts = clCreateKernel(C->prog, "el_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_db_atts = clCreateKernel(C->prog, "db_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_scat_sig_dsd = clCreateKernel(C->prog, "scat_sig_dsd", &ret);                         CHECK_CL_CREATE_KERNEL
    C->kern_scat_clr_dsd = clCreateKernel(C->prog, "scat_clr_dsd", &ret);                         CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_1 = clCreateKernel(C->prog, "make_pulse_pass_1", &ret);               CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_group = clCreateKernel(C->prog, "make_pulse_pass_2_group", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_local = clCreateKernel(C->prog, "make_pulse_pass_2_range", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_range = clCreateKernel(C->prog, "make_pulse_pass_2_local", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
    
    if (verb) {
        printf("%s : RS : Kernels for program[%d] created.\n", now(), (int)C->name);
        if (verb > 2) {
            size_t pref_size;
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_db_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   db_atts()\n", now(), pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_el_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   el_atts()\n", now(), pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_1()\n", now(), pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_group, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_group()\n", now(), pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_local, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_local()\n", now(), pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_range, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_range()\n", now(), pref_size);
        }
    }

    // A queue for the CL work of each device
    C->que = clCreateCommandQueue(C->context, C->dev, 0, &ret);
    if (ret != CL_SUCCESS) {
        printf("%s : RS : Creating command queue[%d] failed  (ret = %d).\n", now(), C->name, ret);
    }
    
#endif

}


void RS_worker_free(RSWorker *C) {
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	dispatch_release(C->sem);
	dispatch_release(C->que);
	
#else
	
    clReleaseCommandQueue(C->que);
    
    clReleaseKernel(C->kern_io);
    clReleaseKernel(C->kern_dummy);
    clReleaseKernel(C->kern_bg_atts);
    clReleaseKernel(C->kern_el_atts);
    clReleaseKernel(C->kern_db_atts);
    clReleaseKernel(C->kern_scat_sig_dsd);
    clReleaseKernel(C->kern_scat_clr_dsd);
    clReleaseKernel(C->kern_make_pulse_pass_1);
    clReleaseKernel(C->kern_make_pulse_pass_2_group);
    clReleaseKernel(C->kern_make_pulse_pass_2_local);
    clReleaseKernel(C->kern_make_pulse_pass_2_range);
    
    clReleaseProgram(C->prog);
    
    clReleaseContext(C->context);
	
#endif
	
}


void RS_worker_malloc(RSHandle *H, const int worker_id, const size_t sub_num_scats, const size_t offset) {

    RSWorker *C = &H->worker[worker_id];
    
    if (C == NULL) {
        printf("%s : RS : Worker[%d] has not been initialized?\n", now(), worker_id);
        return;
    }
    
    // Copy the necessary parameters from host to compute workers
    C->num_scats = sub_num_scats;
    C->species_global_offset = offset;
    
    size_t work_items = RS_CL_GROUP_ITEMS;

#if !defined (_SHARE_OBJ_)
    
    clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(work_items), &work_items, NULL);

#endif

    if (work_items > RS_CL_GROUP_ITEMS) {
        printf("%s : RS : Potential memory leak. work_items(%d) > RS_CL_GROUP_ITEMS(%d).\n", now(), (int)work_items, RS_CL_GROUP_ITEMS);
        return;
    }
    
    size_t max_work_group_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    
    C->make_pulse_params = RS_make_pulse_params((cl_uint)C->num_scats,
                                                (cl_uint)work_items,
                                                (cl_uint)max_work_group_size,
                                                H->params.range_start,
                                                H->params.range_delta,
                                                H->params.range_count);
    
    const unsigned long work_numel = C->make_pulse_params.global[0] * C->make_pulse_params.local[0] * H->params.range_count;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
    // printf("Creating cl_mem from vbo ... %d %d %d \n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);
    C->scat_pos = gcl_gl_create_ptr_from_buffer(C->vbo_scat_pos);
    if (C->scat_pos == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_pos.\n", now());
        C->scat_pos = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_clr = gcl_gl_create_ptr_from_buffer(C->vbo_scat_clr);
    if (C->scat_clr == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_clr.\n", now());
        C->scat_clr = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_ori = gcl_gl_create_ptr_from_buffer(C->vbo_scat_ori);
    if (C->scat_ori == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_ori.\n", now());
        C->scat_ori = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    
    C->scat_vel = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_tum = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_att = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_sig = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->work = gcl_malloc(work_numel * sizeof(cl_float4), NULL, 0);
    C->pulse = gcl_malloc(H->params.range_count * sizeof(cl_float4), NULL, 0);
    
    C->scat_rnd = gcl_malloc(C->num_scats * sizeof(cl_int4), NULL, 0);
    
    C->mem_size += (cl_uint)( (7 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );

#else
	
#define CHECK_CL_CREATE_BUFFER                                                             \
    if (ret != CL_SUCCESS) {                                                               \
        fprintf(stderr, "%s : RS : Error in clCreateBuffer().  ret = %d\n", now(), ret);   \
        return;                                                                            \
    }
    
    cl_int ret;
    
    printf("shared_vbo: %d %d %d\n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);

    if (H->has_vbo_from_gl) {
        C->scat_pos = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_pos, &ret);
        C->scat_clr = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_clr, &ret);
        C->scat_ori = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_ori, &ret);
        if (C->scat_pos == NULL || C->scat_clr == NULL || C->scat_ori == NULL || ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error in clCreateFromGLBuffer().  ret = %d\n", now(), ret);
            C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
            C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
            C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        }
    } else {
        C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    }

    C->scat_vel = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    C->scat_tum = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
	C->scat_att = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
	C->scat_sig = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    C->scat_rnd = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_int4), NULL, &ret);                         CHECK_CL_CREATE_BUFFER
    C->work     = clCreateBuffer(C->context, CL_MEM_READ_WRITE, work_numel * sizeof(cl_float4), NULL, &ret);                         CHECK_CL_CREATE_BUFFER
	C->pulse    = clCreateBuffer(C->context, CL_MEM_READ_WRITE, H->params.range_count * sizeof(cl_float4), NULL, &ret);              CHECK_CL_CREATE_BUFFER
	
	C->mem_size += (cl_uint)( (6 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );
	
	//
	// Set up kernel's input / output arguments
	//
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_io, 0, sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_io, 1, sizeof(cl_mem), &C->scat_att);
    if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel io().\n", now());
		exit(EXIT_FAILURE);
	}
	
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_dummy, 0, sizeof(cl_mem), &C->scat_pos);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel dummy().\n", now());
        exit(EXIT_FAILURE);
    }
    
    cl_float16 sim_desc;
    sim_desc.s[RSSimulationParameterBeamUnitX]    = H->beam_pos.x;
    sim_desc.s[RSSimulationParameterBeamUnitY]    = H->beam_pos.y;
    sim_desc.s[RSSimulationParameterBeamUnitZ]    = H->beam_pos.z;
    sim_desc.s[RSSimulationParameterBoundSizeX]   = H->domain.size.x;
    sim_desc.s[RSSimulationParameterBoundSizeY]   = H->domain.size.y;
    sim_desc.s[RSSimulationParameterBoundSizeZ]   = H->domain.size.z;
    sim_desc.s[RSSimulationParameterBoundOriginX] = H->domain.origin.x;
    sim_desc.s[RSSimulationParameterBoundOriginY] = H->domain.origin.y;
    sim_desc.s[RSSimulationParameterBoundOriginZ] = H->domain.origin.z;
    sim_desc.s[RSSimulationParameterPRT]          = H->params.prt;
    sim_desc.s[RSSimulationParameterDebrisCount]  = 0.0f;
    sim_desc.s[RSSimulationParameterAgeIncrement] = H->params.prt / H->worker[0].vel_desc.s[RSTableDescriptionRefreshTime];

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentExtras,                        sizeof(cl_mem),     &C->scat_att);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentAngularWeight,                 sizeof(cl_mem),     &C->angular_weight);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentAngularWeightDescription,      sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_bg_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    //    ret |= clSetKernelArg(C->kern_el_atts, RSDraggedSpheroidAttributeKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    //    ret |= clSetKernelArg(C->kern_el_atts, RSDraggedSpheroidAttributeKernelArgumentTumble,                        sizeof(cl_mem),     &C->scat_tum);
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentExtras,                        sizeof(cl_mem),     &C->scat_att);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSignal,                        sizeof(cl_mem),     &C->scat_sig);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentAngularWeight,                 sizeof(cl_mem),     &C->angular_weight);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentAngularWeightDescription,      sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_el_atts().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentTumble,                        sizeof(cl_mem),     &C->scat_tum);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentExtras,                        sizeof(cl_mem),     &C->scat_att);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSignal,                        sizeof(cl_mem),     &C->scat_sig);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
	ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAngularWeight,                 sizeof(cl_mem),     &C->angular_weight);
	ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAngularWeightDescription,      sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_sig_dsd, RSScattererSignalDropSizeDistributionKernalArgumentSignal,    sizeof(cl_mem), &C->scat_sig);
    ret |= clSetKernelArg(C->kern_scat_sig_dsd, RSScattererSignalDropSizeDistributionKernalArgumentPosition,  sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_sig_dsd, RSScattererSignalDropSizeDistributionKernalArgumentAttribute, sizeof(cl_mem), &C->scat_att);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_sig_dsd().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_clr_dsd, RSScattererColorDropSizeDistributionKernalArgumentColor,     sizeof(cl_mem), &C->scat_clr);
    ret |= clSetKernelArg(C->kern_scat_clr_dsd, RSScattererColorDropSizeDistributionKernalArgumentPosition,  sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_clr_dsd, RSScattererColorDropSizeDistributionKernalArgumentAttribute, sizeof(cl_mem), &C->scat_att);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_clr_dsd().\n", now());
        exit(EXIT_FAILURE);
    }

    if (C->verb > 1) {
		printf("%s : RS : Pass 1   global =%6s   local = %3zu x %2d = %6s B   groups = %4d   N = %9s\n",
			   now(),
			   commaint(C->make_pulse_params.global[0]),
			   C->make_pulse_params.local[0],
			   C->make_pulse_params.range_count,
			   commaint(C->make_pulse_params.local_mem_size[0]),
			   C->make_pulse_params.group_counts[0],
			   commaint(C->make_pulse_params.entry_counts[0]));
	}
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 0, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 1, sizeof(cl_mem),                         &C->scat_sig);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 2, sizeof(cl_mem),                         &C->scat_att);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 3, C->make_pulse_params.local_mem_size[0], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 4, sizeof(cl_mem),                         &C->range_weight);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 5, sizeof(float),                          &C->range_weight_desc.s0);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 6, sizeof(float),                          &C->range_weight_desc.s1);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 7, sizeof(float),                          &C->range_weight_desc.s2);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 8, sizeof(float),                          &C->make_pulse_params.range_start);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 9, sizeof(float),                          &C->make_pulse_params.range_delta);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 10, sizeof(unsigned int),                  &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 11, sizeof(unsigned int),                  &C->make_pulse_params.group_counts[0]);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 12, sizeof(unsigned int),                  &C->make_pulse_params.entry_counts[0]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_1().\n", now());
		exit(EXIT_FAILURE);
	}
	
	if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_local;
	} else if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_range;
	} else {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
	}
	
	if (C->verb > 1) {
		printf("%s : RS : Pass 2   global =%6s   local = %3zu x %2lu = %6s B   groups = %3d%s   N = %9s\n",
			   now(),
			   commaint(C->make_pulse_params.global[1]),
			   C->make_pulse_params.local[1],
			   C->make_pulse_params.local_mem_size[1] / C->make_pulse_params.local[1] / sizeof(cl_float4),
			   commaint(C->make_pulse_params.local_mem_size[1]),
			   C->make_pulse_params.group_counts[1],
			   C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE ? "R" :
			   (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL ? "L" : "U"),
			   commaint(C->make_pulse_params.entry_counts[1]));
	}
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 0, sizeof(cl_mem),                         &C->pulse);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 1, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 2, C->make_pulse_params.local_mem_size[1], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 3, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 4, sizeof(unsigned int),                   &C->make_pulse_params.entry_counts[1]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_2().\n", now());
		exit(EXIT_FAILURE);
	}
	
#endif
	
    if (C->verb) {
        printf("%s : RS : worker[%d] memory usage = %s B\n", now(), C->name, commaint(C->mem_size));
    }
}

#pragma mark -
#pragma mark Convenient Functions

char *commaint(long long num) {
	static int i = 7;
	static char buf[8][64];
	
	// Might need a semaphore to protect the following line
	i = i == 7 ? 0 : i + 1;
	
	int b = i;
	snprintf(buf[b], 48, "%lld", num);
	if (num >= 1000) {
		int c = (int)(strlen(buf[b]) - 1) / 3; // Number of commans
		int p = (int)(strlen(buf[b])) + c;     // End position
		int d = 1;                             // Count of digits
		buf[b][p] = '\0';
		while (p > 0) {
			p--;
			buf[b][p] = buf[b][p - c];
			if (d > 3) {
				d = 0;
				buf[b][p] = ',';
				c--;
			}
			d++;
		}
	}
	return buf[b];
}


// Here is a nice reference: http://www.cplusplus.com/ref/ctime/time.html
char *now() {
	static char timestr[64];
	time_t utc;
	time(&utc);
	strftime(timestr, 63, "%H:%M:%S", localtime(&utc));
	return timestr;
}


char *nowlong() {
    static char timestr[64];
    time_t utc;
    time(&utc);
    strftime(timestr, 63, "%Y%m%d-%H%M%S", localtime(&utc));
    return timestr;
}


void rsprint(const char *format, ...) {
	
	char str[RS_MAX_STR] = "";
	sprintf(str, "%s : RS : ", now());
	size_t len = strlen(str);
	va_list args;
	
	va_start(args, format);
	vsnprintf(str + len, RS_MAX_STR - len, format, args);
	len = strlen(str);
	va_end(args);
	
	len = MIN(len, RS_MAX_STR - 2);
	if (str[len-1] != '\n') {
		str[len] = '\n';
		str[len+1] = '\0';
	}
	printf("%s", str);
}


void pfn_prog_notify(cl_program program, void *user_data) {
    if (user_data != NULL) {
        fprintf(stderr, "%s : RS : Program %p returned %p (via pfn_prog_notify)\n", now(), program, user_data);
    }
}


void pfn_notify(const char *errinfo, const void *private_info, size_t cb, void *user_data) {
	fprintf(stderr, "%s : RS : %s (via pfn_notify)\n", now(), errinfo);
}


// CL_DEVICE_TYPE_GPU
void get_device_info(cl_device_type device_type, cl_uint *num_devices, cl_device_id *devices, cl_uint *num_cus, cl_uint *vendors, cl_int detail_level) {
	
	int i = 0, j = 0;
	cl_uint num_platforms = 0;
	cl_uint platform_num_devices = 0;
	
	*num_devices = 0;
	
	cl_platform_id platforms[RS_MAX_GPU_PLATFORM];
	
	char buf_char[RS_MAX_STR];
	cl_uint buf_uint;
	cl_ulong buf_ulong;
	
	CL_CHECK(clGetPlatformIDs(RS_MAX_GPU_PLATFORM, platforms, &num_platforms));
	
	if (detail_level)
		printf("* Number of OpenCL platforms: %d\n", num_platforms);
	
	for (; i < num_platforms; i++) {
		
        CL_CHECK(clGetDeviceIDs(platforms[i], device_type, RS_MAX_GPU_DEVICE - *num_devices, &devices[*num_devices], &platform_num_devices));
		
		*num_devices += platform_num_devices;
		if (*num_devices >= RS_MAX_GPU_DEVICE) {
			fprintf(stderr, "%s : RS : Sweet. A lot of devices found. Upgrade! Upgrade!\n", now());
			*num_devices = RS_MAX_GPU_DEVICE;
			return;
		}
		
		if (detail_level) {
			printf("  > PLATFORM %d:\n", i);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, RS_MAX_STR, buf_char, NULL));
			printf("    * NAME = %s\n", buf_char);
			if (detail_level > 1) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, RS_MAX_STR, buf_char, NULL));
				printf("    * VENDOR = %s\n", buf_char);
			}
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_PROFILE, RS_MAX_STR, buf_char, NULL));
			printf("    * PROFILE = %s\n", buf_char);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, RS_MAX_STR, buf_char, NULL));
			printf("    * VERSION = %s\n", buf_char);
			if (detail_level > 2) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, RS_MAX_STR, buf_char, NULL));
				if (strlen(buf_char)) {
					char *b = buf_char;
					while (1) {
						char *e = strchr(b, ' ');
						if (e) {
							*e = '\0';
						}
						if (b == buf_char) {
							printf("    * EXTENSIONS = %s\n", b);
						} else {
							printf("                   %s\n", b);
						}
						if (e) {
							b = e + 1;
						} else {
							break;
						}
					}
				}
			}
			printf("    * Number of OpenCL devices = %d\n", *num_devices);
			
#define FMT "%-35s"
#define FMT2 "%-14s"
			
			for (j = 0; j < platform_num_devices; j++) {
				printf("      > DEVICE %d:\n", j);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_NAME, RS_MAX_STR, buf_char, NULL));
				printf("        - " FMT " = %s\n", "CL_DEVICE_NAME", buf_char);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VENDOR, RS_MAX_STR, buf_char, NULL));
                if (strcasestr(buf_char, "intel")) {
                    vendors[j] = RS_GPU_VENDOR_INTEL;
                } else if (strcasestr(buf_char, "nvidia")) {
                    vendors[j] = RS_GPU_VENDOR_NVIDIA;
                } else if (strcasestr(buf_char, "amd")) {
                    vendors[j] = RS_GPU_VENDOR_AMD;
                } else {
                    vendors[j] = RS_GPU_VENDOR_UNKNOWN;
                }
				printf("        - " FMT " = %s (%d)\n", "CL_DEVICE_VENDOR", buf_char, vendors[j]);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
				printf("        - " FMT " = %u\n", "CL_DEVICE_MAX_COMPUTE_UNITS", (unsigned int)num_cus[j]);
				if (detail_level > 1) {
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DEVICE_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DRIVER_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(buf_uint), &buf_uint, NULL));
					printf("        - " FMT " = %s MHz\n", "CL_DEVICE_MAX_CLOCK_FREQUENCY", commaint(buf_uint));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_GLOBAL_MEM_SIZE", commaint(buf_ulong));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_MAX_MEM_ALLOC_SIZE", commaint(buf_ulong));
					if (detail_level > 2) {
						size_t work_sizes[3];
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(work_sizes), &work_sizes, NULL);
						printf("        - " FMT " = %zu / %zu / %zu\n", "CL_DEVICE_MAX_WORK_ITEM_SIZES", work_sizes[0], work_sizes[1], work_sizes[2]);
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT " = %zu\n", "CL_DEVICE_MAX_WORK_GROUP_SIZE", work_sizes[0]);
						clGetDeviceInfo(devices[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n", "CL_DEVICE_LOCAL_MEM_SIZE", commaint(buf_ulong));
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n\n", "CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE", commaint(buf_ulong));
						
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT "   " FMT2 " %7s\n", "CL_DEVICE_IMAGE <dim>", "2D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "2D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_DEPTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n\n", "", "3D_MAX_DEPTH", commaint(work_sizes[0]));
					}
				}
			} // for (; j < platform_num_devices; j++)
		} else {
			for (; j < platform_num_devices; j++)
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
		}
	} // for (; i < num_platforms; i++)
}


cl_uint read_kernel_source_from_files(char *src_ptr[], ...) {
	
	static char char_buf[RS_MAX_KERNEL_SRC] = "";
	
	cl_uint count = 0, len = 0;
	
	va_list files;
	
	va_start(files, src_ptr);
	char *filename = va_arg(files, char *);
	while (filename != NULL && strlen(filename) > 0) {

#ifdef DEBUG_KERNEL_READ
		printf("%s : RS : src '%s' (%d)\n", now(), filename, (int)strlen(filename));
#endif

        // Read in the kernel source
		FILE *fid = fopen(filename, "r");
		if (fid == NULL) {
			fprintf(stderr, "%s : RS : Error opening kernel source %s.\n", now(), filename);
			break;
		}
		while (!feof(fid) && strlen(char_buf) < RS_MAX_KERNEL_SRC && count < RS_MAX_KERNEL_LINES) {
			src_ptr[count] = fgets(char_buf + len, RS_MAX_KERNEL_SRC - len, fid);
			if (src_ptr[count] != NULL) {
				len += strlen(src_ptr[count]) + 1;
				count++;
			}
		}
		fclose(fid);
		
		filename = va_arg(files, char *);
	}
	va_end(files);
	
	if (len >= RS_MAX_KERNEL_SRC * 8 / 10) {
		printf("%s : RS : \e[31mWARNING. Kernel source size = %s / %s (%.2f > 80%%)\e[0m\n",
			   now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), (float)len / RS_MAX_KERNEL_SRC * 100.0f);
	}
	
	if (len >= RS_MAX_KERNEL_SRC || count >= RS_MAX_KERNEL_LINES) {
		fprintf(stderr, "Kernel source exceeds buffer size constraints.  (len = %d / %d, count = %d / %d)\n", len, RS_MAX_KERNEL_SRC, count, RS_MAX_KERNEL_LINES);
		return 0;
	}
	
#ifdef DEBUG_KERNEL_READ
	printf("%d lines\n", count);
	for (int i = 0; i < count; i++) {
		printf("%d:%s", i, src_ptr[i]);
	}
#endif
	
	return count;
}


ReductionParams *make_reduction_params(cl_uint count, cl_uint user_max_groups, cl_uint user_max_work_items) {
	
	ReductionParams *params = (ReductionParams *)malloc(sizeof(ReductionParams));
	
	if (params == NULL) {
		fprintf(stderr, "%s : RS : Error creating ReductionParams.\n", now());
		return NULL;
	}
	
	// Copy these for housekeeping
	params->count = count;
	params->user_max_groups = user_max_groups;
	params->user_max_work_items = user_max_work_items;
	
	// Work items is only count / 2 for small counts
	int work_items = count > 2 * user_max_work_items ? user_max_work_items : count / 2;
	
	// Number of group of item-pairs
	int groups = count / (work_items * 2);
	if (groups > user_max_groups) {
		groups = user_max_groups;
	}
	
	cl_uint levels = 1;
	cl_uint numels = groups;
	
	// First pass to figure out how many levels
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		numels = numels / (work_items * 2);
		levels++;
	}
	
	params->pass_counts = levels;
	params->entry_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->group_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->work_item_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	
	params->entry_counts[0] = count;
	params->group_counts[0] = groups;
	params->work_item_counts[0] = work_items;
	
	int level = 1;
	
	numels = groups;
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		int groups = numels / (work_items * 2);
		if (groups > user_max_groups) {
			groups = user_max_groups;
		}
		
		params->entry_counts[level] = numels;
		params->group_counts[level] = groups;
		params->work_item_counts[level] = work_items;
		
		numels = numels / (work_items * 2);
		level++;
	}
	
	return params;
}


void free_reduction_params(ReductionParams *params) {
	free(params->entry_counts);
	free(params->group_counts);
	free(params->work_item_counts);
	free(params);
}


float read_table(const float *table, const float index_last, const float index) {
	float floor_index = floorf(index);
	float alpha = index - floor_index;
	if (index <= 0.0f) {
		//		printf("%.2f / %.2f --> i = %u  X0\n", index, index_last, 0);
		return table[0];
	} else if (floor_index >= index_last) {
		//		printf("%.2f / %.2f --> i = %u  XM\n", index, index_last, (unsigned int)index_last);
		return table[(unsigned int)index_last];
	}
	unsigned int i = (unsigned int)floor_index;
	//	printf("%.2f / %.2f --> i = %d, %d / %.2f, %.2f  alpha = %.2f  v = %.3f\n", index, index_last, i, i+1,
	//		   table[i], table[i + 1],
	//		   alpha,
	//		   table[i] + alpha * (table[i + 1] - table[i]);
	return table[i] + alpha * (table[i + 1] - table[i]);
}

#pragma mark -
#pragma mark RS Convenient functions

cl_uint RS_gpu_count(void) {
    cl_uint          num_devs;
    cl_device_id     devs[RS_MAX_GPU_DEVICE];
    cl_uint          num_cus[RS_MAX_GPU_DEVICE];
    cl_uint          vendors[RS_MAX_GPU_DEVICE];
    get_device_info(CL_DEVICE_TYPE_GPU, &num_devs, devs, num_cus, vendors, 0);
    return num_devs;
}

#pragma mark -
#pragma mark RS Initialization and Deallocation


RSHandle *RS_init_with_path(const char *bundle_path, RSMethod method, const char verb) {
	
    int i;
    
	RSHandle *H;
	
	// Allocate
	if (posix_memalign((void **)((uintptr_t)&H), RS_ALIGN_SIZE, sizeof(RSHandle))) {
		fprintf(stderr, "%s : RS : Error initializing RSHandle.\n", now());
		return NULL;
	}
	memset(H, 0, sizeof(RSHandle));
	
	// Default non-zero parameters
    H->sim_tic = 0;
	H->status = RS_STATUS_DOMAIN_NULL;
	H->params.c = 3.0e8f;
	H->params.body_per_cell = RS_BODY_PER_CELL;
	H->params.domain_pad_factor = RS_DOMAIN_PAD;
	H->params.prt = 0.0f;
	H->num_workers = 1;
    H->num_species = 1;
	H->method = method;
	
	for (i = 0; i < RS_MAX_GPU_DEVICE; i++) {
		H->worker[i].name = i;
	}
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        H->species_population[i] = 0;
    }
	
	// Set up some basic parameters to default values, H->verb is still 0 so no API message output
	RS_set_antenna_params(H, 1.0f, 50.0f);
	
	RS_set_tx_params(H, 1.0e-6f, 50.0e3f);
	
	RS_set_beam_pos(H, 5.0f, 1.0f);
	
	// Now, we are ready to set the verbose flag
	H->verb = verb;
	
	if (H->method == RS_METHOD_GPU) {
		if (verb) {
			rsprint("Getting CL devices ...");
		}
		// Get and show some device info
		get_device_info(CL_DEVICE_TYPE_GPU, &H->num_devs, H->devs, H->num_cus, H->vendors, H->verb);
	} else if (H->method == RS_METHOD_CPU) {
		// Run this to get the num_cus to the same values.
		get_device_info(CL_DEVICE_TYPE_CPU, &H->num_devs, H->devs, H->num_cus, H->vendors, 0);
	}
    if (H->num_devs == 0 || H->num_cus[0] == 0) {
        fprintf(stderr, "%s : RS : Error. No OpenCL devices found.\n", now());
        return NULL;
    }

    H->num_workers = H->num_devs;
    switch (H->vendors[0]) {
        case RS_GPU_VENDOR_INTEL:
            H->preferred_multiple = H->num_cus[0] * 16;
            break;
        default:
            H->preferred_multiple = H->num_cus[0] * 16;
            break;
    }

#if defined (GUI) || defined (_SHARE_OBJ_)
    
    // Force to one GPU at the moment. Seems like OpenGL context can be shared with only one OpenCL context
    H->num_workers = 1;
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->verb > 2) {
            printf("%s : RS : Initializing worker %d using %p\n", now(), i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], 0, NULL, H->verb);
    }
		
#else

    cl_uint count;
    char *src_ptr[RS_MAX_KERNEL_LINES];
    
    // Kernel source
    if (!strcmp(bundle_path, ".")) {
        count = read_kernel_source_from_files(src_ptr, "rs.cl", NULL);
    } else {
        #ifdef INCLUDE_TYPES_IN_KERNEL
        
        // This version combines special types along with the kernel functions
        char types_h_path[RS_MAX_STR];
        char kern_src_path[RS_MAX_STR];
        snprintf(types_h_path, RS_MAX_STR, "%s/rs_types.h", bundle_path);
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, types_h_path, kern_src_path, NULL);

        #else
        
        // This version does not depend on custom types
        char kern_src_path[RS_MAX_STR];
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, kern_src_path, NULL);
        
        #endif
    }
    
    if (count == 0) {
        return NULL;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->verb > 2) {
            printf("%s : RS : Initializing worker %d using %p\n", now(), i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], count, (const char **)src_ptr, H->verb);
    }
		
#endif
		
	// More parameters that need the CL context initialized
	char user_verb = H->verb;
	
	H->verb = 0;
	
	RS_set_scan_box(H,
					15.0e3f, 20.0e3f, 250.0f,                   // Range
					-12.0f, 12.0f, 1.0f,                        // Azimuth
					0.0f, 8.0f, 1.0f);                          // Elevation
	
	RS_set_range_weight_to_triangle(H, 250.0f);
	
	RS_set_angular_weight_to_standard(H, 2.0f / 180.0f * M_PI);
	//RS_set_angular_weight_to_double_cone(H, 2.0f / 180.0f * M_PI);

	RS_set_wind_data_to_cube27(H);

    RS_set_adm_data_to_unity(H);
    
    RS_set_rcs_data_to_unity(H);
	
	H->verb = user_verb;
	
	return H;
}


RSHandle *RS_init_for_cpu_verbose(const char verb) {
	return RS_init_with_path(".", RS_METHOD_CPU, verb);
}


RSHandle *RS_init_verbose(const char verb) {
    return RS_init_with_path(".", RS_METHOD_GPU, verb);
}


RSHandle *RS_init() {
    return RS_init_with_path(".", RS_METHOD_GPU, 0);
}


void RS_free_scat_memory(RSHandle *H) {
	int i;
	
	if (H->verb > 2) {
		printf("%s : RS : Freeing GPU memories ...\n", now());
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vbo_scat_pos == 0) {
			fprintf(stderr, "%s : RS : Unexpected error. VBO was not shared.\n", now());
			return;
		}
		gcl_free(H->worker[i].scat_pos);
		gcl_free(H->worker[i].scat_clr);  // Only the GUI version has this
		gcl_free(H->worker[i].scat_vel);
		gcl_free(H->worker[i].scat_ori);
        gcl_free(H->worker[i].scat_tum);
		gcl_free(H->worker[i].scat_att);
		gcl_free(H->worker[i].scat_sig);
		gcl_free(H->worker[i].work);
		gcl_free(H->worker[i].pulse);
		gcl_free(H->worker[i].scat_rnd);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].scat_pos);
        clReleaseMemObject(H->worker[i].scat_clr);
		clReleaseMemObject(H->worker[i].scat_vel);
		clReleaseMemObject(H->worker[i].scat_ori);
        clReleaseMemObject(H->worker[i].scat_tum);
		clReleaseMemObject(H->worker[i].scat_att);
		clReleaseMemObject(H->worker[i].scat_sig);
		clReleaseMemObject(H->worker[i].work);
		clReleaseMemObject(H->worker[i].pulse);
		clReleaseMemObject(H->worker[i].scat_rnd);
	}
	
#endif
	
	if (H->verb > 2) {
		printf("%s : RS : Freeing CPU memories ...\n", now());
	}
	
	free(H->scat_pos);
	free(H->scat_vel);
	free(H->scat_ori);
    free(H->scat_tum);
	free(H->scat_att);
	free(H->scat_sig);
    free(H->scat_rnd);

	free(H->pulse);
	
	for (i = 0; i < H->num_workers; i++) {
		free(H->pulse_tmp[i]);
	}
}


void RS_free(RSHandle *H) {
	
    int i;
    
	char v = H->verb;
	
	for (i = 0; i < H->num_workers; i++) {
		RS_worker_free(&H->worker[i]);
	}
	
	RS_free_scat_memory(H);
	
    int t = 0;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

	for (i = 0; i < H->num_workers; i++) {
		gcl_free(H->worker[i].range_weight);
		gcl_free(H->worker[i].angular_weight);
		gcl_release_image(H->worker[i].vel[t]);
        gcl_release_image(H->worker[i].adm_cd[t]);
        gcl_release_image(H->worker[i].adm_cm[t]);
        gcl_release_image(H->worker[i].rcs_real[t]);
        gcl_release_image(H->worker[i].rcs_imag[t]);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].range_weight);
		clReleaseMemObject(H->worker[i].angular_weight);
		clReleaseMemObject(H->worker[i].vel[t]);
        clReleaseMemObject(H->worker[i].adm_cd[t]);
        clReleaseMemObject(H->worker[i].adm_cm[t]);
        clReleaseMemObject(H->worker[i].rcs_real[t]);
        clReleaseMemObject(H->worker[i].rcs_imag[t]);
	}
	
#endif
	
    free(H->anchor_pos);
    free(H->anchor_lines);
    
    free(H);
    
    if (v) {
        printf("%s : RS : Resources released.\n", now());
    }
}


RSMakePulseParams RS_make_pulse_params(const cl_uint count, const cl_uint user_max_work_items, cl_uint user_max_groups,
									   const float range_start, const float range_delta, const unsigned int range_count) {
	RSMakePulseParams param;

	// Keep a copy for reference
	param.num_scats = count;
	param.user_max_groups = user_max_groups;
	param.user_max_work_items = user_max_work_items;
	param.range_start = range_start;
	param.range_delta = range_delta;
	param.range_count = MAX(1, range_count);
    
	// The 2nd pass kernel functions are only for work_items <= 1024.
	if (user_max_groups > 1024) {
		fprintf(stderr, "%s : RS : I'm not programmed to handle user_max_groups > 1024.\n", now());
		param.user_max_groups = 1024;
	}
	
	// Work items is at most count / 2
	unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : count / 2;
	
	// Number of group item-pairs
	unsigned int group_count = count <= work_items * 2 ? 1 : count / (work_items * 2);
	if (group_count > param.user_max_groups) {
		group_count = param.user_max_groups;
	}
	
	//printf("count=%d  work_items=%d  groups=%d/%d\n", count, work_items, group_count, param.user_max_groups);
	
	// 1st pass
	param.entry_counts[0] = count;
	param.group_counts[0] = group_count;
	param.global[0] = group_count * work_items;
	param.local[0] = work_items;
	param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
	
	// 2nd pass
	unsigned int work_count = group_count * param.range_count;
	
	param.entry_counts[1] = work_count;
    work_items = work_count / (param.range_count * 2);
    if (work_items < 1) {
        fprintf(stderr, "%s : RS : 2nd pass with CL work_items < 2?\n", now());
        work_items = 1;
    }

	if (param.local[0] % param.range_count == 0 && user_max_work_items >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_UNIVERSAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else if (group_count >= 2 * param.range_count && user_max_work_items >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_LOCAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_RANGE;
		param.group_counts[1] = 1;
		param.global[1] = param.range_count;
		param.local[1] = 1;
		param.local_mem_size[1] = sizeof(cl_float4);
		
	}
	if (param.entry_counts[1] > RS_MAX_GATES * work_items) {
		fprintf(stderr, "%s : RS : H->dev_work may not be large enough.\n", now());
	}
	return param;
}


void RS_init_scat_pos(RSHandle *H) {
    
    int counts[H->dsd_count];
    int i, k, bin;
    float a;
    
    memset(counts, 0, H->dsd_count * sizeof(int));
    
	//
	// Initialize the scatter body positions & velocities
	//
	for (i = 0; i < H->num_scats; i++) {
		H->scat_pos[i].x = (float)rand() / RAND_MAX * H->domain.size.x + H->domain.origin.x;
		H->scat_pos[i].y = (float)rand() / RAND_MAX * H->domain.size.y + H->domain.origin.y;
		H->scat_pos[i].z = (float)rand() / RAND_MAX * H->domain.size.z + H->domain.origin.z;
        H->scat_pos[i].w = 0.0f;                       // Use this to store drop radius
        
		H->scat_att[i].s0 = 0.0f;                      // Use this to store range
        H->scat_att[i].s1 = (float)rand() / RAND_MAX;  // Use this to store age
		H->scat_att[i].s2 = 0.0f;
		H->scat_att[i].s3 = 1.0f;                      // Use this to store angular weight
		
		H->scat_vel[i].x = 0.0f;
		H->scat_vel[i].y = 0.0f;
		H->scat_vel[i].z = 0.0f;
		H->scat_vel[i].w = 0.0f;

        // Facing the sky
        H->scat_ori[i].x =  0.0f;
        H->scat_ori[i].y = -0.707106781186547f;
        H->scat_ori[i].z =  0.0f;
        H->scat_ori[i].w =  0.707106781186548f;

        // Facing the beam
//        H->scat_ori[i].x =  0.5f;
//        H->scat_ori[i].y = -0.5f;
//        H->scat_ori[i].z = -0.5f;
//        H->scat_ori[i].w =  0.5f;
		
        // Tumbling vector for orientation update
        H->scat_tum[i].x = 0.0f;
        H->scat_tum[i].y = 0.0f;
        H->scat_tum[i].z = 0.0f;
        H->scat_tum[i].w = 1.0f;

        // Initial return from each point
        H->scat_sig[i].s0 = 0.0f;
		H->scat_sig[i].s1 = 0.0f;
		H->scat_sig[i].s2 = 0.0f;
		H->scat_sig[i].s3 = 0.0f;
        
        // Random seeds
        H->scat_rnd[i].s0 = rand();
        H->scat_rnd[i].s1 = rand();
        H->scat_rnd[i].s2 = rand();
        H->scat_rnd[i].s3 = rand();
	}
    
    // Parameterized drop radius as scat_pos.w if DSD has been set
    // May want to add maximum relaxation time of each drop size
    // Potential places: vel.w, aux.s2
    if (H->dsd_name != RSDropSizeDistributionUndefined) {
        for (i = 0; i < H->num_scats; i++) {
            a = (float)rand() / RAND_MAX;
            k = H->dsd_count;
            bin = 0;
            while (k > 0) {
                k--;
                if (a >= H->dsd_cdf[k]) {
                    bin = k;
                    break;
                }
            }
            counts[bin]++;
            H->scat_pos[i].w = H->dsd_r[bin];
            H->scat_att[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // temporary use this to store normalized bin index
        }
        
        if (H->verb > 1) {
            printf("%s : RS : Actual DSD Specifications:\n", now());
            for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
                printf("                 o %.2f mm - PDF %.5f / %.5f / %d particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)counts[i] / (float)H->num_scats, counts[i]);
            }
            if (H->dsd_count > 8) {
                printf("                 o  :      -      :     /  :     /\n");
                printf("                 o  :      -      :     /  :     /\n");
                i = MAX(4, H->dsd_count - 1);
            }
            for (; i < H->dsd_count; i++) {
                printf("                 o %.2f mm - PDF %.5f / %.5f / %d particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)counts[i] / (float)H->num_scats, counts[i]);
            }
        }
    }
	
	// Replace a few points for debugging purpose.
//	H->scat_pos[0].x = H->domain.origin.x + 0.5f * H->domain.size.x;
//	H->scat_pos[0].y = H->domain.origin.y + 0.5f * H->domain.size.y;
//	H->scat_pos[0].z = H->domain.origin.z + 0.5f * H->domain.size.z;
	
    if (H->species_population[1]) {
        k = (int)H->species_population[0] / H->num_workers;
        H->scat_pos[k].x = 0.0f;
        H->scat_pos[k].y = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
        H->scat_pos[k].z = 0.0f;
        
        H->scat_att[k].s0 = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
    }
	
	// Restore simulation time
	H->sim_tic = 0;
	H->sim_toc = 0;
	H->sim_time = 0.0f;
    H->sim_desc.s[RSSimulationParameterBeamUnitX] = H->beam_pos.x;
    H->sim_desc.s[RSSimulationParameterBeamUnitY] = H->beam_pos.y;
    H->sim_desc.s[RSSimulationParameterBeamUnitZ] = H->beam_pos.z;
    H->sim_desc.s[RSSimulationParameterBoundSizeX] = H->domain.size.x;
    H->sim_desc.s[RSSimulationParameterBoundSizeY] = H->domain.size.y;
    H->sim_desc.s[RSSimulationParameterBoundSizeZ] = H->domain.size.z;
    H->sim_desc.s[RSSimulationParameterBoundOriginX] = H->domain.origin.x;
    H->sim_desc.s[RSSimulationParameterBoundOriginY] = H->domain.origin.y;
    H->sim_desc.s[RSSimulationParameterBoundOriginZ] = H->domain.origin.z;
    H->sim_desc.s[RSSimulationParameterPRT] = H->params.prt;
    H->sim_desc.s[RSSimulationParameterDebrisCount] = H->species_population[0];
    H->sim_desc.s[RSSimulationParameterAgeIncrement] = H->params.prt / H->worker[0].vel_desc.s[RSTableDescriptionRefreshTime];

    // This part should be moved to setting ADM
    for (k = 0; k < H->adm_count; k++) {
        // Plate dimension in meters
        float v0 = 100.0f;
        const float rho = 1.21f;
        const float g = 9.8f;
        
        float len = 0.04f;
        float thi = 0.002f;
        float rhod = 1120.0f;
        float mass = len * len * thi * rhod;
        
        cl_float4 ii = {{
            (len * len + len * len) * mass / 12.0f,
            (len * len + thi * thi) * mass / 12.0f,
            (thi * thi + len * len) * mass / 12.0f,
            0.0f
        }};
        cl_float4 inln = {{
            ii.x * g * len / (mass * len * len * v0 * v0),
            ii.y * g * len / (mass * len * len * v0 * v0),
            ii.z * g * len / (mass * len * len * v0 * v0)
        }};
        H->inv_inln = (cl_float4) {{
            1.0f / inln.x,
            1.0f / inln.y,
            1.0f / inln.z,
            0.0f
        }};
        H->Ta = rho * (len * len * v0 * v0) / (2.0f * mass * g);
        
        // De-dimensionalize
        // Velocity should have v0 * v0 / g whenever velocity is retrieved but pre-done here
        // Angular momentum's len needs to be dimensionalized by v0 * v0 / g
        H->inv_inln.x = (mass * len) / (ii.x * g * g);
        H->inv_inln.y = (mass * len) / (ii.y * g * g);
        H->inv_inln.z = (mass * len) / (ii.z * g * g);
        H->Ta *= g / (v0 * v0);
        
        if (H->verb) {
            printf("%s : RS : ADM[%d]   Ta = %.4f  inv_inln = [%.4f %.4f %.4f]   mass = %.4f kg\n",
                   now(), k, H->Ta, H->inv_inln.x, H->inv_inln.y, H->inv_inln.z, mass);
        }
        
        for (i = 0; i < H->num_workers; i++) {
            H->worker[i].adm_desc[k].s[RSTableDescriptionRecipInLnX] = H->inv_inln.x;
            H->worker[i].adm_desc[k].s[RSTableDescriptionRecipInLnY] = H->inv_inln.y;
            H->worker[i].adm_desc[k].s[RSTableDescriptionRecipInLnZ] = H->inv_inln.z;
            H->worker[i].adm_desc[k].s[RSTableDescriptionTachikawa] = H->Ta;
        }
    }
}

#pragma mark -
#pragma mark Properties

void RS_set_prt(RSHandle *H, const float prt) {
	H->params.prt = prt;
	H->params.prf = 1.0f / prt;
//	for (int i = 0; i < H->num_scats; i++) {
//		H->scat_att[i].s1 = (float)rand() / RAND_MAX * 1000.0f;
//	}
//    H->sim_desc.s[RSSimulationParameterPRT] = H->params.prt;
//    H->sim_desc.s[RSSimulationParameterAgeIncrement] = H->sim_desc.s[RSSimulationParameterPRT] / H->worker[0].vel_desc.s[RSTableDescriptionRefreshTime];
}

void RS_set_density(RSHandle *H, const float density) {
	H->params.body_per_cell = density;
}


void RS_set_antenna_params(RSHandle *H, RSfloat beamwidth_deg, RSfloat gain_dbi) {
	H->params.antenna_bw_deg = beamwidth_deg;
	H->params.antenna_bw_rad = M_PI * H->params.antenna_bw_deg / 180.0f;
}


void RS_set_tx_params(RSHandle *H, RSfloat pulsewidth, RSfloat tx_power_watt) {
	H->params.tau = pulsewidth;
	H->params.dr = H->params.c * H->params.tau * 0.5f;
	H->params.tx_power_watt = tx_power_watt;
}


void RS_set_scan_box(RSHandle *H,
					 RSfloat range_start, RSfloat range_end, RSfloat range_delta,
					 RSfloat azimuth_start, RSfloat azimuth_end, RSfloat azimuth_delta,
					 RSfloat elevation_start, RSfloat elevation_end, RSfloat elevation_delta) {
	
	H->status &= !RS_STATUS_DOMAIN_POPULATED;
	H->params.range_start = range_start;
	H->params.range_end = range_end;
	H->params.range_delta = range_delta;
	H->params.azimuth_start_deg = azimuth_start;
	H->params.azimuth_end_deg = azimuth_end;
	H->params.azimuth_delta_deg = azimuth_delta;
	H->params.elevation_start_deg = elevation_start;
	H->params.elevation_end_deg = elevation_end;
	H->params.elevation_delta_deg = elevation_delta;
	
	const RSfloat r_lo = floor((H->params.range_start - H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat r_hi =  ceil((H->params.range_end   + H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat az_lo = floor((H->params.azimuth_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat az_hi =  ceil((H->params.azimuth_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat el_lo = MAX(0.0f, floor((H->params.elevation_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat el_hi = MIN(90.0f,  ceil((H->params.elevation_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat tiny = 1.0e-5;
	
	int nr = 0;
	int naz = 0;
	int nel = 0;
	
	RSfloat r;
	RSfloat az;
	RSfloat el;
	
	int ii = 0;
	
	// Number of range gates
	r = floor(H->params.range_start / H->params.range_delta) * H->params.range_delta;
	while (r <= ceil(H->params.range_end / H->params.range_delta) * H->params.range_delta) {
		r += H->params.range_delta;
		nr++;
	}
	H->params.range_count = MIN(RS_MAX_GATES, nr);
	
	// Evaluate the number of scatterers needed
	az = az_lo;
	while (az <= az_hi + tiny) {
		az += H->params.azimuth_delta_deg;
		if (az >= 360.0f) {
			az -= 360.0f;
		}
		naz++;
	}
	el = el_lo;
	while (el <= el_hi) {
		el += H->params.elevation_delta_deg;
		nel++;
    }
    // Zero volume
    if (naz == 0 || nel == 0) {
        printf("%s : RS : NEL = %d and/or NAZ = %d resulted in a zero volumne.\n", now(), naz, nel);
        return;
    }
	H->num_anchors  = 2 * naz * nel + 1;  // Save one for radar origin
	// printf("%s : RS : Number of anchors needed = %d  (naz = %d  nel = %d)\n", now(), (int)H->num_anchors, naz, nel);
	if (H->anchor_pos) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor memory.\n", now());
		}
		free(H->anchor_pos);
	}
	H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
	if (H->anchor_pos == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchors.\n", now());
		return;
	}
	
	// Domain size
	RSfloat
	xmin = INFINITY, xmax = -INFINITY,
	ymin = INFINITY, ymax = -INFINITY,
    zmin = INFINITY, zmax = -INFINITY;
	el = el_lo / 180.0f * M_PI;
	while (el <= el_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
		az = az_lo / 180.0f * M_PI;
		while (az <= az_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
			H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_lo * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_hi * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			az += azimuth_delta / 180.0f * M_PI;
		}
		el += elevation_delta / 180.0f * M_PI;
	}
	
	// Radar origin at (0, 0, 0)
	H->anchor_pos[ii].x = 0.0f;
	H->anchor_pos[ii].y = 0.0f;
	H->anchor_pos[ii].z = 0.0f;
	H->anchor_pos[ii].w = 5.0f;
	
	//printf("H->num_anchors = %zu   ii = %d\n", H->num_anchors, ii);
	
	// Volume of a single resolution cell
	r = 0.5f * (H->params.range_start + H->params.range_start);
	RSfloat vol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5f);
	RSfloat nvol = ((xmax - xmin) * (ymax - ymin) * (zmax - zmin)) / vol;
	
	H->domain.origin.x = xmin;
	H->domain.origin.y = ymin;
	H->domain.origin.z = zmin;
	H->domain.size.x = xmax - xmin;
	H->domain.size.y = ymax - ymin;
	H->domain.size.z = zmax - zmin;
	
	// Suggest a number of scatter bodies to use
	H->num_scats = (size_t)(H->params.body_per_cell * nvol);
	
	// Round to a GPU preferred number
	size_t mul = H->num_cus[0] * H->num_devs * 128;
	size_t preferred_n = (size_t)(H->num_scats / mul) * mul;
	while (preferred_n < H->params.body_per_cell * 9 / 10) {
		preferred_n += mul;
	}
	
	if (H->verb) {
		printf("%s : RS : nvol = %.4f\n", now(), nvol);
		printf("%s : RS : Box @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n", now(),
			   xmin, xmax,
			   ymin, ymax,
               zmin, zmax);
        printf("%s : RS : Box size: [ %.2f m x %.2f m x %.2f m ]\n", now(),
               xmax - xmin, ymax - ymin, zmax - zmin);
		printf("%s : RS : User domain @ R:[ %5.2f - %5.2f ] km    E:[ %5.2f - %5.2f ] deg   A:[ %+.2f - %+.2f ] deg\n", now(),
			   1e-3*H->params.range_start, 1e-3*H->params.range_end,
			   H->params.elevation_start_deg, H->params.elevation_end_deg,
			   H->params.azimuth_start_deg, H->params.azimuth_end_deg);
		
		printf("%s : RS : Work domain @ R:[ %5.2f - %5.2f ] km   E:[ %5.2f - %5.2f ] deg   A:[ %+.2f - %+.2f ] deg\n", now(),
			   1e-3*r_lo, 1e-3*r_hi,
			   el_lo, el_hi,
			   az_lo, az_hi);
		
		printf("%s : RS : Using suggested %s bodies\n", now(), commaint(H->num_scats));
		printf("%s : RS : Using GPU preferred %s (%.2f bodies / resolution cell)\n", now(), commaint(preferred_n), (float)preferred_n / nvol);
	}
	
	H->num_scats = preferred_n;
	
	// Anchor lines to show the volume of interest, which was set by the user. The number is well more than enough
	H->num_anchor_lines  = 8 * (naz + nel);
	
	if (H->anchor_lines) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor_line memory.\n", now());
		}
		free(H->anchor_lines);
	}
	H->anchor_lines = (cl_float4 *)malloc(H->num_anchor_lines * sizeof(cl_float4));
	if (H->anchor_lines == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchor_lines.\n", now());
		return;
	}
	ii = 0;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	// printf("num_anchor_lines = %zu  ii = %d\n", H->num_anchor_lines, ii);
	
	H->num_anchor_lines = ii;
	
	return;
}


void RS_set_beam_pos(RSHandle *H, RSfloat az_deg, RSfloat el_deg) {
	// Compute the unit vector of the pointing direction
	H->beam_pos.x = cosf(el_deg / 180.0f * M_PI) * sinf(az_deg / 180.0f * M_PI);
	H->beam_pos.y = cosf(el_deg / 180.0f * M_PI) * cosf(az_deg / 180.0f * M_PI);
	H->beam_pos.z = sinf(el_deg / 180.0f * M_PI);
	H->beam_pos.w = 0.0f;
    H->sim_desc.s[RSSimulationParameterBeamUnitX] = H->beam_pos.x;
    H->sim_desc.s[RSSimulationParameterBeamUnitY] = H->beam_pos.y;
    H->sim_desc.s[RSSimulationParameterBeamUnitZ] = H->beam_pos.z;
}


void RS_set_verbosity(RSHandle *H, const char verb) {
	H->verb = verb;
}


void RS_set_debris_count(RSHandle *H, const int species_id, const size_t count) {
    
    int i;
    
    if (species_id == 0) {
        printf("%s : RS : RS_set_debris_count() cannot have species = 0.\n", now());
        return;
    }

    H->species_population[species_id] = count;

    H->num_species = 0;
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->species_population[i] > 0) {
            H->num_species++;
        }
    }
    
    if (H->verb > 1) {
        printf("%s : RS : Total number of species = %d\n", now(), (int)H->num_species);
    }

    if (H->sim_tic > 0) {
        RS_update_debris_count(H);
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        RS_derive_ndranges(H);
        
#endif

    }
}


size_t RS_get_debris_count(RSHandle *H, const int species_id) {
    return H->species_population[species_id];
}


size_t RS_get_worker_debris_count(RSHandle *H, const int species_id, const int worker_id) {
    return H->worker[worker_id].species_population[species_id];
}


size_t RS_get_all_worker_debris_counts(RSHandle *H, const int species_id, size_t counts[]) {
    
    int i;
    
    for (i = 0; i < H->num_workers; i++) {
        counts[i] = H->worker[i].species_population[species_id];
    }
    return H->species_population[species_id];
}


void RS_update_debris_count(RSHandle *H) {
    
    int i, k;
    
    size_t count = H->num_scats;
    
    if (H->num_workers == 0) {
        printf("%s : RS : Expected. Number of workers = 0.\n", now());
        return;
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 1) {
        k--;
        count -= H->species_population[k];
    }
    H->species_population[0] = count;

    if (H->verb > 1) {
        printf("%s : RS : Population details:\n", now());
        for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            printf("                 o Global species_population[%d] = %s\n", k, commaint(H->species_population[k]));
        }
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 0) {
        k--;
        size_t species_count_left = H->species_population[k];
        if (species_count_left == 0) {
            H->worker[i].species_population[k] = 0;
            continue;
        }
        // Groups of debris types
        size_t round_up_down_toggle = H->num_workers > 1 ? k % H->num_workers : k;
        size_t sub_species_population = (H->species_population[k] + round_up_down_toggle) / H->num_workers;
        for (i = 0; i < H->num_workers-1; i++) {
            H->worker[i].species_population[k] = sub_species_population;
            species_count_left -= sub_species_population;
        }
        // The last worker gets all the remainders
        H->worker[i].species_population[k] = species_count_left;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        k = RS_MAX_DEBRIS_TYPES;
        size_t origin = H->worker[i].num_scats;
        while (k > 1) {
            k--;
            if (H->worker[i].species_population[k] == 0) {
                continue;
            }
            origin -= H->worker[i].species_population[k];
            H->worker[i].species_origin[k] = origin;
        }
    }
    
    if (H->verb > 2) {
        for (i = 0; i < H->num_workers; i++) {
            printf("%s : RS : worker[%d] with total population %s  offset %s\n", now(), i, commaint(H->worker[i].num_scats), commaint(H->worker[i].species_global_offset));
            for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
                printf("                 o species_population[%d] - [ %9s, %9s, %9s ]\n", k,
                       commaint(H->worker[i].species_origin[k]),
                       commaint(H->worker[i].species_population[k]),
                       commaint(H->worker[i].species_origin[k] + H->worker[i].species_population[k]));
            }
        }
    }
}


void RS_set_dsd(RSHandle *H, const float *pdf, const float *diameters, const int count, const char name) {
    
    int i;
    
    if (count == 0) {
        printf(" %s : RS : DSD bin count cannot be 0.\n", now());
        return;
    }
    
    H->dsd_name = name;
    H->dsd_count = count;
    
    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
    }
    H->dsd_r = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_cdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    if (H->dsd_r == NULL || H->dsd_pdf == NULL || H->dsd_cdf == NULL) {
        fprintf(stderr, "%s : RS : Error allocating resources for DSD parameterization.\n", now());
        return;
    }
    
    memset(H->dsd_r, 0, count * sizeof(RSfloat));
    memset(H->dsd_pdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_cdf, 0, count * sizeof(RSfloat));
    
    RSfloat lo = 0.0f;
    
    for (i = 0; i < count; i++) {
        H->dsd_r[i] = 0.5f * diameters[i];
        H->dsd_pdf[i] = pdf[i];
        H->dsd_cdf[i] = lo;
        lo += pdf[i];
    }
    
    if (H->verb) {
        printf("%s : RS : User set DSD specifications:\n", now());
        for (i = 0; i < MIN(MAX(count - 2, 1), 3); i++) {
            printf("                 o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
        if (count > 5) {
            printf("                 o  :      -      :     /     :\n");
            printf("                 o  :      -      :     /     :\n");
            i = MAX(4, count - 1);
        }
        for (; i < count; i++) {
            printf("                 o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
    }
}


void RS_set_dsd_to_mp(RSHandle *H) {
    
    int i;
    
    float d, sum = 0.0f;
    
    //float ds[] = {0.0001f, 0.0002f, 0.0005f, 0.001f, 0.002f, 0.003f, 0.004f, 0.005f};
    float ds[] = {0.001f, 0.003f};
    
    const int count = sizeof(ds) / sizeof(float);
    
    H->dsd_mu = 8000.0f;              // Brandes et al. 2006, mu = 8000 m^-3 m^-1
    H->dsd_lambda = 2.3f * 1000.0f;
    
    RSfloat *n = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    // Derive a concentration curve
    for (i = 0; i < count; i++) {
        d = ds[i];
        n[i] = H->dsd_mu * exp(-H->dsd_lambda * d);
        sum += n[i];
    }
    
    // Convert concentration to pdf
    for (i = 0; i < count; i++) {
        n[i] /= sum;
    }
    
    RS_set_dsd(H, n, ds, count, RSDropSizeDistributionMarshallPalmer);
    
    free(n);
}


#pragma mark -
#pragma mark Functions to set properties after RS_init()

void RS_set_range_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        printf("%s : RS : Host range weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n", now(),
               table.dx, table.x0, table.xm, table_size);
    }
		
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
		
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                printf("%s : RS : worker[%d] setting range weight.\n", now(), i);
            }
            gcl_free(H->worker[i].range_weight);
        }
        H->worker[i].range_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].range_weight == NULL) {
            fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
            return;
        }
        // Copy over to CL worker. I know it's a bit wasteful but the codes are easier to ready this way.
        H->worker[i].range_weight_desc.s0 = table.dx;
        H->worker[i].range_weight_desc.s1 = table.x0;
        H->worker[i].range_weight_desc.s2 = table.xm;
        H->worker[i].range_weight_desc.s3 = 0.0f;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }

#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                printf("%s : RS : worker[%d] setting range weight.\n", now(), i);
            }
            clReleaseMemObject(H->worker[i].range_weight);
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] creating range weight (cl_mem) & copying data from %p.\n", now(), i, table.data);
        }
        H->worker[i].range_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
            return;
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] created range weight @ %p.\n", now(), i, H->worker[i].range_weight);
        }
        // Copy over to CL worker. I know it's a bit wasteful but the codes are easier to ready this way.
        H->worker[i].range_weight_desc.s0 = table.dx;
        H->worker[i].range_weight_desc.s1 = table.x0;
        H->worker[i].range_weight_desc.s2 = table.xm;
        H->worker[i].range_weight_desc.s3 = 0.0f;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }

#endif

    RS_table_free(table);

}


void RS_set_range_weight_to_triangle(RSHandle *H, float pulse_width_m) {
	float w[3] = {0.0f, 1.0f, 0.0f};
	RS_set_range_weight(H, w, -pulse_width_m, pulse_width_m, 3);
}


void RS_set_angular_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
	memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        printf("%s : RS : Host angular weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n", now(),
               table.dx, table.x0, table.xm, table_size);
    }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                printf("%s : RS : worker[%d] setting angular weight.\n", now(), i);
            }
            gcl_free(H->worker[i].angular_weight);
        }
        H->worker[i].angular_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].angular_weight == NULL) {
            fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
            return;
        }
        // Copy over to CL worker. I know it's a bit wasteful but the codes are easier to ready this way.
        H->worker[i].angular_weight_desc.s0 = table.dx;
        H->worker[i].angular_weight_desc.s1 = table.x0;
        H->worker[i].angular_weight_desc.s2 = table.xm;
        H->worker[i].angular_weight_desc.s3 = 0.0f;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }
		
#else
		
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                printf("%s : RS : worker[%d] setting angular weight.\n", now(), i);
            }
            clReleaseMemObject(H->worker[i].angular_weight);
        }
        if (H->verb > 1) {
            printf("%s : RS : worker[%d] creating angular weight (cl_mem) & copying data from %p.\n", now(), i, table.data);
        }
        H->worker[i].angular_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
            return;
        }
        if (H->verb > 1) {
            printf("%s : RS : worker[%d] created angular weight.\n", now(), i);
        }
        // Copy over to CL worker. I know it's a bit wasteful but the codes are easier to ready this way.
        H->worker[i].angular_weight_desc.s0 = table.dx;
        H->worker[i].angular_weight_desc.s1 = table.x0;
        H->worker[i].angular_weight_desc.s2 = table.xm;
        H->worker[i].angular_weight_desc.s3 = 0.0f;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }
		
#endif

    RS_table_free(table);
}


void RS_set_angular_weight_to_double_cone(RSHandle *H, float beamwidth_rad) {
	float w[] = {1.0f, 0.0f, 0.8f, 0.0f};
	unsigned int n = sizeof(w) / sizeof(float);
	RS_set_angular_weight(H, w, 0.0f, 2.0f * beamwidth_rad, n);
}


void RS_set_angular_weight_to_standard(RSHandle *H, float beamwidth_rad) {
	unsigned int n = 40;
	float a;
	float b = 1.27f * M_PI / beamwidth_rad;
	float c;
	float w[n];
	
    float delta = 1.0f / 360.0f * M_PI;
    
	for (int i = 0; i < n; i++) {
		a = (float)i * delta;
		c = b * sinf(a);
		if (i == 0) {
			w[i] = 1.0f;
		} else if (i == (n - 1)) {
			w[i] = 0.0f;
		} else {
			w[i] = 8.0f * jn(2, c) / (c * c);
			w[i] *= w[i];
		}
		//printf("angle=%.4f deg  w[%d] = %.4f dB\n", a / M_PI * 180.0f, i, 10.0f * log10f(w[i]));
	}
	RS_set_angular_weight(H, w, 0.0f, delta, n);
}


void RS_set_wind_data(RSHandle *H, const RSTable3D table) {
	
	int i;
		
    int t = H->vel_count;
    
	cl_image_format format = {CL_RGBA, CL_FLOAT};
	
#if defined (CL_VERSION_1_2)

	cl_image_desc desc;
	desc.image_type = CL_MEM_OBJECT_IMAGE3D;
	desc.image_width  = table.x_;
	desc.image_height = table.y_;
	desc.image_depth  = table.z_;
	desc.image_array_size = 0;
	desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
	desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
	desc.num_mip_levels = 0;
	desc.num_samples = 0;
	desc.buffer = NULL;
	
#endif
	
    
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vel[t] != NULL) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

            gcl_release_image(H->worker[i].vel[t]);

#else
            
            clReleaseMemObject(H->worker[i].vel[t]);
            
#endif

        }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        H->worker[i].vel[t] = gcl_create_image(&format, desc.image_width, desc.image_height, desc.image_depth, H->worker[i].surf_vel[t]);

#else
        
        cl_int ret;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].vel[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, table.data, &ret);
        
#else
        
        H->worker[i].vel[t] = clCreateImage3D(H->worker[i].context, flags, &format, table.x_, table.y_, table.z_,
                                              table.x_ * sizeof(cl_float4), table.y_ * table.x_ * sizeof(cl_float4), table.data, &ret);
        
#endif
        
#endif
        
        if (H->worker[i].vel[t] == NULL) {
			fprintf(stderr, "%s : RS : worker[%d] encountered error creating wind table on CL device.\n", now(), i);
			return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created vel[%d] @ %p\n", now(), i, t, &H->worker[i].vel[t]);
        }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_async(H->worker[i].que, ^{
			size_t origin[3] = {0, 0, 0};
			size_t region[3] = {table.x_, table.y_, table.z_};
			gcl_copy_ptr_to_image(H->worker[i].vel[t], table.data, origin, region);
			dispatch_semaphore_signal(H->worker[i].sem);
		});

#endif

    }
	
	for (i = 0; i < H->num_workers; i++) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
#endif

        // Copy over to CL worker
        if (table.spacing & RSTableSpacingStretchedX) {
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionBaseChangeX] = table.xs;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionPositionScaleX] = table.xo;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionOffsetX] = table.xm;
        } else {
            H->worker[i].vel_desc.s[RSTableDescriptionScaleX] = table.xs;
            H->worker[i].vel_desc.s[RSTableDescriptionOriginX] = table.xo;
            H->worker[i].vel_desc.s[RSTableDescriptionMaximumX] = table.xm;
        }
        if (table.spacing & RSTableSpacingStretchedY) {
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionBaseChangeY] = table.ys;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionPositionScaleY] = table.yo;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionOffsetY] = table.ym;
        } else {
            H->worker[i].vel_desc.s[RSTableDescriptionScaleY] = table.ys;
            H->worker[i].vel_desc.s[RSTableDescriptionOriginY] = table.yo;
            H->worker[i].vel_desc.s[RSTableDescriptionMaximumY] = table.ym;
        }
        if (table.spacing & RSTableSpacingStretchedZ) {
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionBaseChangeZ] = table.zs;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionPositionScaleZ] = table.zo;
            H->worker[i].vel_desc.s[RSStaggeredTableDescriptionOffsetZ] = table.zm;
        } else {
            H->worker[i].vel_desc.s[RSTableDescriptionScaleZ] = table.zs;
            H->worker[i].vel_desc.s[RSTableDescriptionOriginZ] = table.zo;
            H->worker[i].vel_desc.s[RSTableDescriptionMaximumZ] = table.zm;
        }
        H->worker[i].vel_desc.s[RSTableDescriptionRefreshTime] = table.tr;

        H->worker[i].mem_size += (cl_uint)((table.xm + 1.0f) * (table.ym + 1.0f) * (table.zm + 1.0f)) * sizeof(cl_float4);
        
        //H->sim_desc.s[RSSimulationParameterAgeIncrement] = H->sim_desc.s[RSSimulationParameterPRT] / table.tr;
	}

    H->vel_count++;
}


void RS_set_wind_data_to_LES_table(RSHandle *H, const LESTable *leslie) {
	
	int i;
    float hmax, zmax;
	
	RSTable3D table = RS_table3d_init(leslie->nn);
    if (table.data == NULL) {
        printf("%s : RS : LES input data cannot be NULL.", now());
        return;
    }

	// Set up the mapping coefficients (old; left here for future reference)
    //	table.x_ = leslie->nx;    table.xm = (float)(table.x_ - 1);    table.xs = (float)leslie->nx / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
    //	table.y_ = leslie->ny;    table.ym = (float)(table.y_ - 1);    table.ys = (float)leslie->ny / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;

    // For LES tables:
    //
    // dz(k) = a * r ^ 1.05
    //
    //  z(k) = a * ( 1 - r ^ k ) / ( 1 - r )
    //
    //     k = 1 / log(r) * log( 1 - ( 1 - r ) / a * z( k ) )
    //       = 1 / log(r) * log( 1 + ( r - 1 ) / a * z( k ) )
    //
    // For a = 2.7, r = 1.05, these values may be documented in the data files at some point
    //
    //     k = 20.495934314287851 * log1p ( 0.018518518518519 * z( k ) )

    table.x_ = leslie->nx;    table.xm = 0.5f * (float)(leslie->nx - 1);    table.xs = 1.0f / log(leslie->rx);    table.xo = (leslie->rx - 1.0f) / leslie->ax;
    table.y_ = leslie->ny;    table.ym = 0.5f * (float)(leslie->ny - 1);    table.ys = 1.0f / log(leslie->ry);    table.yo = (leslie->ry - 1.0f) / leslie->ay;
    table.z_ = leslie->nz;    table.zm = 0.0f;                              table.zs = 1.0f / log(leslie->rz);    table.zo = (leslie->rz - 1.0f) / leslie->az;

    hmax = leslie->ax * (1.0f - powf(leslie->rx, table.xm)) / (1.0f - leslie->rx);
    zmax = leslie->az * (1.0f - powf(leslie->rz, (float)(leslie->nz - 1))) / (1.0f - leslie->rz);
    
    if (H->verb > 0 && H->vel_count == 0) {
        printf("%s : RS : LES stretched x-grid using %.6f * log1p( %.6f * x )    Mid = %.2f m\n",
               now(), table.xs, table.xo, hmax);
        printf("%s : RS : LES stretched z-grid using %.6f * log1p( %.6f * z )    Max = %.2f m\n",
               now(), table.zs, table.zo, zmax);
    }
    
    if (H->verb > 1) {
//        printf("%s : RS : LES[%2d] @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
//               now(),
//               H->vel_count,
//               H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
//               H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
//               H->domain.origin.z, H->domain.origin.z + H->domain.size.z);

        printf("%s : RS : LES[%2d] @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
               now(),
               H->vel_count,
               -hmax, hmax,
               -hmax, hmax,
              0.0, zmax);
    }
    
    // Some other parameters
    table.tr = leslie->tr;
    table.spacing = RSTableSpacingStretchedX | RSTableSpacingStretchedY | RSTableSpacingStretchedZ;

	// Need to arrange LES values into float4, then upload to GPU's global memory
	for (i = 0; i < leslie->nn; i++) {
		table.data[i].x = leslie->data.u[i];
		table.data[i].y = leslie->data.v[i];
		table.data[i].z = leslie->data.w[i];
		table.data[i].w = 0.0f;
        if (!(isfinite(table.data[i].x) &&
              isfinite(table.data[i].y) &&
              isfinite(table.data[i].z))) {
            printf("%s : RS : Some LES entries are not finite  (i = %d, vel = %.2f, %.2f, %.2f).\n", now(), i, table.data[i].x, table.data[i].y, table.data[i].z);
        }
	}

    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->vel_desc = *leslie;
    memset(&H->vel_desc.data, 0, sizeof(LESValue));

    RS_set_wind_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_wind_data_to_cube27(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(27);
	
	if (H->verb > 1) {
		printf("%s : RS : Cube27 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
			   H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
			   H->domain.origin.z, H->domain.origin.z + H->domain.size.z);
	}
	
	// Set up the mapping coefficients: -table_start * table_xs
	//	table.x_ = 3;    table.xm = 2.0f;    table.xs = 2.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs + 0.5f;
	//	table.y_ = 3;    table.ym = 2.0f;    table.ys = 2.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys + 0.5f;
	//	table.z_ = 3;    table.zm = 2.0f;    table.zs = 2.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs + 0.5f;
	
	table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
	table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;
	table.z_ = 3;    table.zm = 2.0f;    table.zs = 3.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	//	printf(" %.2f x %.2f = %.2f\n", -H->domain.origin.x, H->physics_table.xs, -H->domain.origin.x / H->domain.size.x * 2.0f);
	//	printf("o = [%.2f, %.2f, %.2f]\n", table.xo, table.yo, table.zo);
	
	const float v = 1.0f;
	
	for (i = 0; i < 27; i++) {
		table.data[i].x = (float) (i % 3)      * v - v;
		table.data[i].y = (float)((i % 9) / 3) * v - v;
		table.data[i].z = (float) (i / 9)      * v - v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_wind_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_wind_data_to_cube125(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(125);
	
	if (H->verb > 1) {
		printf("%s : RS : Cube125 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
			   H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
			   H->domain.origin.z, H->domain.origin.z + H->domain.size.z);
	}
	
	// Set up the mapping coefficients
	//	table.x_ = 5;    table.xm = 4.0f;    table.xs = 4.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs + 0.5f;
	//	table.y_ = 5;    table.ym = 4.0f;    table.ys = 4.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys + 0.5f;
	//	table.z_ = 5;    table.zm = 4.0f;    table.zs = 4.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs + 0.5f;
	
	table.x_ = 5;    table.xm = 4.0f;    table.xs = 5.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
	table.y_ = 5;    table.ym = 4.0f;    table.ys = 5.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;
	table.z_ = 5;    table.zm = 4.0f;    table.zs = 5.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	const float v = 0.5f;
	
	for (i = 0; i < 125; i++) {
		table.data[i].x = (float) (i %  5)      * v - 2.0f * v;
		table.data[i].y = (float)((i % 25) / 5) * v - 2.0f * v;
		table.data[i].z = (float) (i / 25)      * v - 2.0f * v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_wind_data(H, table);
    
    RS_table3d_free(table);
	
}


void RS_clear_wind_data(RSHandle *H) {
    // Technically the video RAM hasn't been freed but we will assume there is enough room and this memory gets freed when a new table comes in
    for (int i = 0; i < H->num_workers; i++) {
        cl_uint nx = (cl_uint)H->worker[i].vel_desc.s[RSTableDescriptionMaximumX] + 1;
        cl_uint ny = (cl_uint)H->worker[i].vel_desc.s[RSTableDescriptionMaximumY] + 1;
        cl_uint nz = (cl_uint)H->worker[i].vel_desc.s[RSTableDescriptionMaximumZ] + 1;
        H->worker[i].mem_size -= nx * ny * nz * H->vel_count * sizeof(cl_float4);
    }
    H->vel_count = 0;
}


void RS_set_adm_data(RSHandle *H, const RSTable2D cd, const RSTable2D cm) {
    
    int i;
    
    const int t = H->adm_count;
    
    const size_t n = cd.x_ * cd.y_;
    if (cm.x_ * cm.y_ != n) {
        fprintf(stderr, "%s : RS : RS_set_adm_data() received inconsistent cd (%d x %d) & cm (%d x %d) dimensions", now(), cd.x_, cd.y_, cm.x_, cm.y_);
        return;
    }
    
    if (H->verb > 1) {
        printf("%s : RS : ADM[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]\n", now(), H->adm_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = cd.x_;
    desc.image_height = cd.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].adm_cd[t] != NULL && H->worker[i].adm_cm[t] != NULL) {
            
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
            
            gcl_release_image(H->worker[i].adm_cd[t]);
            gcl_release_image(H->worker[i].adm_cm[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].adm_cd[t]);
            clReleaseMemObject(H->worker[i].adm_cm[t]);
            
#endif
            
            H->worker[i].mem_size -= ((cl_uint)(H->worker[i].adm_desc[t].s8 + 1.0f) * (H->worker[i].adm_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  adm_cd & adm_cm always have the same desc
        
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        H->worker[i].adm_cd[t] = gcl_create_image(&format, cd.x_, cd.y_, 1, H->worker[i].surf_adm_cd[t]);
        H->worker[i].adm_cm[t] = gcl_create_image(&format, cm.x_, cm.y_, 1, H->worker[i].surf_adm_cm[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].adm_cd[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cm.data, &retm);
        
#else
        
        H->worker[i].adm_cd[t] = clCreateImage2D(H->worker[i].context, flags, &format, cd.x_, cd.y_, cd.x_ * sizeof(cl_float4), cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage2D(H->worker[i].context, flags, &format, cm.x_, cm.y_, cm.x_ * sizeof(cl_float4), cm.data, &retm);
        
#endif
        
#endif
        if (H->worker[i].adm_cd[t] == NULL || H->worker[i].adm_cm[t] == NULL) {
            fprintf(stderr, "%s : RS : worker[%d] encountered error creating ADM tables on CL device(s).\n", now(), i);
            return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created adm_cd[%d] & adm_cd[%d] @ %p & %p\n", now(), i, t, t, &H->worker[i].adm_cd[t], &H->worker[i].adm_cm[t]);
        }
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {cd.x_, cd.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].adm_cd[t], cd.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].adm_cm[t], cm.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].adm_desc[t].s[RSTableDescriptionScaleX] = cd.xs;
        H->worker[i].adm_desc[t].s[RSTableDescriptionScaleY] = cd.ys;
        H->worker[i].adm_desc[t].s[RSTableDescriptionScaleZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTableDescriptionOriginX] = cd.xo;
        H->worker[i].adm_desc[t].s[RSTableDescriptionOriginY] = cd.yo;
        H->worker[i].adm_desc[t].s[RSTableDescriptionOriginZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTableDescriptionMaximumX] = cd.xm;
        H->worker[i].adm_desc[t].s[RSTableDescriptionMaximumY] = cd.ym;
        H->worker[i].adm_desc[t].s[RSTableDescriptionMaximumZ] = 0.0f;
        H->worker[i].mem_size += ((cl_uint)(cd.xm + 1.0f) * (cd.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->adm_count++;
}


void RS_set_adm_data_to_ADM_table(RSHandle *H, const ADMTable *adam) {
    
    int i;
    
    RSTable2D cd = RS_table2d_init(adam->nn);
    RSTable2D cm = RS_table2d_init(adam->nn);
    
    if (cd.data == NULL || cm.data == NULL) {
        printf("%s : RS : ADM input data cannot be NULL.", now());
        return;
    }

    // Set up the mapping coefficients
    // Assumptions: maps are always in beta in [-180deg, +180deg] and alpha in [0, +180deg]
    cd.x_ = adam->nb;    cd.xm = (float)(cd.x_ - 1);    cd.xs = (float)adam->nb / (2.0f * M_PI);    cd.xo = -(-M_PI) * cd.xs;
    cd.y_ = adam->na;    cd.ym = (float)(cd.y_ - 1);    cd.ys = (float)adam->na / M_PI;             cd.yo = 0.0f;

    cm.x_ = adam->nb;    cm.xm = (float)(cm.x_ - 1);    cm.xs = (float)adam->nb / (2.0f * M_PI);    cm.xo = -(-M_PI) * cd.xs;
    cm.y_ = adam->na;    cm.ym = (float)(cm.y_ - 1);    cm.ys = (float)adam->na / M_PI;             cm.yo = 0.0f;

    // Arrange ADM values into float4, getting ready for GPU's global memory
    for (i = 0; i < adam->nn; i++) {
        cd.data[i].x = adam->data.cdx[i];
        cd.data[i].y = adam->data.cdy[i];
        cd.data[i].z = adam->data.cdz[i];
        cd.data[i].w = 0.0f;
        cm.data[i].x = adam->data.cmx[i];
        cm.data[i].y = adam->data.cmy[i];
        cm.data[i].z = adam->data.cmz[i];
        cm.data[i].w = 0.0f;
    }
    
    RS_set_adm_data(H, cd, cm);
    
    RS_table2d_free(cd);
    RS_table2d_free(cm);
}

void RS_set_adm_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table = RS_table2d_init(9);
    
    if (H->verb > 1) {
        printf("%s : RS : ADM to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]\n", now());
    }
    
    table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / (2.0f * M_PI);    table.xo = -(-M_PI) * table.xs;
    table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / M_PI;             table.yo = 0.0f;

    for (i = 0; i < 9; i++) {
        table.data[i].x = 1.0f;
        table.data[i].y = 1.0f;
        table.data[i].z = 1.0f;
        table.data[i].w = 0.0f;
    }
    
    RS_set_adm_data(H, table, table);
    
    RS_table2d_free(table);
}


void RS_clear_adm_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->adm_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].adm_desc[t].s[RSTableDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].adm_desc[t].s[RSTableDescriptionMaximumY] + 1;
            H->worker[i].mem_size -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->adm_count = 0;
}


void RS_set_rcs_data(RSHandle *H, const RSTable2D real, const RSTable2D imag) {
    
    int i;
    
    const int t = H->rcs_count;

    const size_t n = real.x_ * real.y_;
    if (imag.x_ * imag.y_ != n) {
        fprintf(stderr, "%s : RS : RS_set_rcs_data() received inconsistent real (%d x %d) & imag (%d x %d) dimensions", now(), real.x_, real.y_, imag.x_, imag.y_);
        return;
    }

    if (H->verb > 1) {
        printf("%s : RS : RCS[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]\n", now(), H->rcs_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = real.x_;
    desc.image_height = real.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].rcs_real[t] != NULL && H->worker[i].rcs_imag[t] != NULL) {
            
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
            
            gcl_release_image(H->worker[i].rcs_real[t]);
            gcl_release_image(H->worker[i].rcs_imag[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].rcs_real[t]);
            clReleaseMemObject(H->worker[i].rcs_imag[t]);
            
#endif
            
            H->worker[i].mem_size -= ((cl_uint)(H->worker[i].rcs_desc[t].s8 + 1.0f) * (H->worker[i].rcs_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  rcs_real & rcs_imag always have the same desc
        
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        H->worker[i].rcs_real[t] = gcl_create_image(&format, real.x_, real.y_, 1, H->worker[i].surf_rcs_real[t]);
        H->worker[i].rcs_imag[t] = gcl_create_image(&format, imag.x_, imag.y_, 1, H->worker[i].surf_rcs_imag[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].rcs_real[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, imag.data, &retm);
        
#else
        
        H->worker[i].rcs_real[t] = clCreateImage2D(H->worker[i].context, flags, &format, real.x_, real.y_, real.x_ * sizeof(cl_float4), real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage2D(H->worker[i].context, flags, &format, imag.x_, imag.y_, imag.x_ * sizeof(cl_float4), imag.data, &retm);
        
#endif
        
#endif
        if (H->worker[i].rcs_real[t] == NULL || H->worker[i].rcs_imag[t] == NULL) {
            fprintf(stderr, "%s : RS : worker[%d] encountered error creating RCS tables on CL device(s).\n", now(), i);
            return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created rcs_real[%d] & rcs_imag[%d] @ %p & %p\n", now(), i, t, t, &H->worker[i].rcs_real[t], &H->worker[i].rcs_imag[t]);
        }
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {real.x_, imag.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].rcs_real[t], real.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].rcs_imag[t], imag.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].rcs_desc[t].s[RSTableDescriptionScaleX] = real.xs;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionScaleY] = real.ys;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionScaleZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionOriginX] = real.xo;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionOriginY] = real.yo;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionOriginZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionMaximumX] = real.xm;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionMaximumY] = real.ym;
        H->worker[i].rcs_desc[t].s[RSTableDescriptionMaximumZ] = 0.0f;
        H->worker[i].mem_size += ((cl_uint)(real.xm + 1.0f) * (real.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->rcs_count++;
}


void RS_set_rcs_data_to_RCS_table(RSHandle *H, const RCSTable *rosie) {
    int i;
    
    RSTable2D real = RS_table2d_init(rosie->nn);
    RSTable2D imag = RS_table2d_init(rosie->nn);
    
    if (real.data == NULL || imag.data == NULL) {
        printf("%s : RS : RCS input data cannot be NULL.", now());
        return;
    }
    // Set up the mapping coefficients
    // Assumptions: maps are always in alpha in [-180deg, +180deg] and beta in [0, +180deg]
    real.x_ = rosie->na;    real.xm = (float)(real.x_ - 1);    real.xs = (float)rosie->na / (2.0f * M_PI);    real.xo = -(-M_PI) * real.xs;
    real.y_ = rosie->nb;    real.ym = (float)(real.y_ - 1);    real.ys = (float)rosie->nb / M_PI;             real.yo = 0.0f;
    
    imag.x_ = rosie->na;    imag.xm = (float)(imag.x_ - 1);    imag.xs = (float)rosie->na / (2.0f * M_PI);    imag.xo = -(-M_PI) * real.xs;
    imag.y_ = rosie->nb;    imag.ym = (float)(imag.y_ - 1);    imag.ys = (float)rosie->nb / M_PI;             imag.yo = 0.0f;
    
    // Arrange RCS values into float4, getting ready for GPU's global memory
    for (i = 0; i < rosie->nn; i++) {
        real.data[i].x = rosie->data.hh_real[i];
        real.data[i].y = rosie->data.vv_real[i];
        real.data[i].z = rosie->data.hv_real[i];
        real.data[i].w = 0.0f;
        imag.data[i].x = rosie->data.hh_imag[i];
        imag.data[i].y = rosie->data.vv_imag[i];
        imag.data[i].z = rosie->data.hv_imag[i];
        imag.data[i].w = 0.0f;
    }
    
    RS_set_rcs_data(H, real, imag);
    
    RS_table2d_free(real);
    RS_table2d_free(imag);

}


void RS_set_rcs_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table_real = RS_table2d_init(9);
    RSTable2D table_imag = RS_table2d_init(9);
    
    if (H->verb > 1) {
        printf("%s : RS : RCS to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]\n", now());
    }
    
    table_real.x_ = 3;    table_real.xm = 2.0f;    table_real.xs = 3.0f / (2.0f * M_PI);    table_real.xo = -(-M_PI) * table_real.xs;
    table_real.y_ = 3;    table_real.ym = 2.0f;    table_real.ys = 3.0f / M_PI;             table_real.yo = 0.0f;

    table_imag.x_ = 3;    table_imag.xm = 2.0f;    table_imag.xs = 3.0f / (2.0f * M_PI);    table_imag.xo = -(-M_PI) * table_imag.xs;
    table_imag.y_ = 3;    table_imag.ym = 2.0f;    table_imag.ys = 3.0f / M_PI;             table_imag.yo = 0.0f;
    
    for (i =  0; i < 9; i++) {
        table_real.data[i].x = 1.0f;
        table_real.data[i].y = 1.0f;
        table_real.data[i].z = 1.0f;
        table_real.data[i].w = 0.0f;

        table_imag.data[i].x = 0.0f;
        table_imag.data[i].y = 0.0f;
        table_imag.data[i].z = 0.0f;
        table_imag.data[i].w = 0.0f;
    }
    
    RS_set_rcs_data(H, table_real, table_imag);
    
    RS_table2d_free(table_real);
    RS_table2d_free(table_imag);
}


void RS_clear_rcs_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->rcs_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].rcs_desc[t].s[RSTableDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].rcs_desc[t].s[RSTableDescriptionMaximumY] + 1;
            H->worker[i].mem_size -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->rcs_count = 0;
}


#pragma mark -
#pragma mark GUI Specific Functions

#if defined (GUI) || defined (_SHARE_OBJ_)

void RS_update_colors_only(RSHandle *H) {
    
//    int i;
//    
//    for (i = 0; i < H->num_workers; i++) {
//        dispatch_async(H->worker[i].que, ^{
//            scat_clr2_kernel(&H->worker[i].ndrange_scat[0],
//                             (cl_float4 *)H->worker[i].scat_clr,
//                             (cl_float4 *)H->worker[i].scat_pos,
//                             (cl_float4 *)H->worker[i].scat_att,
//                             (cl_float *)H->worker[i].angular_weight,
//                             H->worker[i].angular_weight_desc,
//                             H->beam_pos,
//                             (unsigned int)H->worker[i].num_scats);
//            dispatch_semaphore_signal(H->worker[i].sem);
//        });
//    }
//    for (i = 0; i < H->num_workers; i++)
//        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
}


void RS_share_mem_with_vbo(RSHandle *H, const int n, unsigned int vbo[][n]) {
    if (H->verb) {
        if (H->num_workers == 1) {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2]);
        } else {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2],
                   vbo[1][0], vbo[1][1], vbo[1][2]);
        }
    }
    for (int i = 0; i < H->num_workers; i++) {
        H->worker[i].vbo_scat_pos = vbo[i][0];
        H->worker[i].vbo_scat_clr = vbo[i][1];
        H->worker[i].vbo_scat_ori = vbo[i][2];
    }
    H->has_vbo_from_gl = 1;
}

#endif

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

void RS_derive_ndranges(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {

        RSWorker *C = &H->worker[i];
        
        for (int k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->species_population[k] == 0) {
                continue;
            }
            C->ndrange_scat[k].work_dim = 1;
            C->ndrange_scat[k].global_work_offset[0] = C->species_origin[k];
            C->ndrange_scat[k].global_work_size[0] = C->species_population[k];
            C->ndrange_scat[k].local_work_size[0] = 0;
            if (C->verb > 2) {
                printf("%s : RS : work[%d] offset, size = %d, %d\n",
                       now(), (int)C->name, (int)C->ndrange_scat[k].global_work_offset[0], (int)C->ndrange_scat[k].global_work_size[0]);
            }
        }
        
        C->ndrange_pulse_pass_1.work_dim = 1;
        C->ndrange_pulse_pass_1.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_1.global_work_size[0] = C->make_pulse_params.global[0];
        C->ndrange_pulse_pass_1.local_work_size[0] = C->make_pulse_params.local[0];
        
        C->ndrange_pulse_pass_2.work_dim = 1;
        C->ndrange_pulse_pass_2.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_2.global_work_size[0] = C->make_pulse_params.global[1];
        C->ndrange_pulse_pass_2.local_work_size[0] = C->make_pulse_params.local[1];
    }
}


#endif

#pragma mark -
#pragma mark Framework Functions

void RS_io_test(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			io_kernel(&H->worker[i].ndrange_scat[0],
                      (cl_float4 *)H->worker[i].scat_pos,
                      (cl_float4 *)H->worker[i].scat_att);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
    
#else
    
	for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_io, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
	}
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
	
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }

#endif
	
}


void RS_dummy_test(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            dummy_kernel(&H->worker[i].ndrange_scat[0],
                         (cl_float4 *)H->worker[i].scat_pos);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    //	cl_event events[RS_MAX_GPU_DEVICE];
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_dummy, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }
    
#endif

}


void RS_populate(RSHandle *H) {
	if (H->num_scats > RS_MAX_NUM_SCATS) {
		printf("%s : RS : Exceed the maximum allowed. (%ld > %d).\n", now(), (unsigned long)H->num_scats, RS_MAX_NUM_SCATS);
	}
	
    if (H->verb) {
        printf("%s : RS : RS_populate()\n", now());
    }
    
    if (H->adm_count != H->rcs_count) {
        printf("%s : RS : ADM & RCS are not consistent. Unexpected behavior may happen.\n", now());
    }

    //
	// CPU memory allocation
	//
	if (H->scat_pos != NULL) {
		RS_free_scat_memory(H);
	}

	posix_memalign((void **)&H->scat_pos, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_vel, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_ori, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_tum, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_att, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_sig, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rnd, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_uint4));

	posix_memalign((void **)&H->pulse, RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
	
	if (H->scat_pos == NULL ||
		H->scat_vel == NULL ||
		H->scat_ori == NULL ||
        H->scat_tum == NULL ||
		H->scat_att == NULL ||
		H->scat_sig == NULL ||
        H->scat_rnd == NULL ||
		H->pulse == NULL) {
		fprintf(stderr, "%s : RS : Error allocating memory space for scatterers.\n", now());
		return;
	}
	
	int i;
	char has_null = 0;
	for (i = 0; i < H->num_workers; i++) {
		posix_memalign((void **)&H->pulse_tmp[i], RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
		has_null |= H->pulse_tmp[i] == NULL;
	}
	if (has_null) {
		fprintf(stderr, "%s : RS : Error allocating memory space for pulses.\n", now());
		return;
	}
	
	//
	// GPU memory allocation
	//
	
	size_t offset = 0;
	
	// Divide the scatter bodies into (num_workers) chunks
	size_t sub_num_scats = H->num_scats / MAX(1, H->num_workers);
	
    for (i = 0; i < H->num_workers; i++) {
        H->offset[i] = offset;
        if (H->verb > 1) {
            printf("%s : RS : worker[%d] num_scats = %s   offset = %s\n", now(), i, commaint(sub_num_scats), commaint(offset));
        }
        RS_worker_malloc(H, i, sub_num_scats, offset);
        offset += sub_num_scats;
    }
	
    RS_update_debris_count(H);
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    CGLContextObj cobj = CGLGetCurrentContext();
    if (cobj == NULL) {
        fprintf(stderr, "No GL context yet.\n");
        return;
    }
    
    gcl_gl_set_sharegroup(CGLGetShareGroup(cobj));
    
    RS_derive_ndranges(H);

#endif

    // Initialize the scatter body positions on CPU, then upload to the GPU
	RS_init_scat_pos(H);
    RS_upload(H);

    if (H->verb) {
        printf("%s : RS : VEL / ADM / RCS count = %d / %d / %d\n", now(), H->vel_count, H->adm_count, H->rcs_count);
        printf("%s : RS : CL domain synchronized.\n", now());
    }

#if !(defined (__APPLE__) && defined (_SHARE_OBJ_))

    // Update kernel arguments
    cl_int ret = CL_SUCCESS;
    const int a = 0;
    const int r = 0;
    for (i = 0; i < H->num_workers; i++) {
        ret |= clSetKernelArg(H->worker[i].kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocityDescription,      sizeof(cl_float16), &H->worker[i].vel_desc);
        ret |= clSetKernelArg(H->worker[i].kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,              sizeof(cl_float16), &H->sim_desc);
        
        ret |= clSetKernelArg(H->worker[i].kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocityDescription,       sizeof(cl_float16), &H->worker[i].vel_desc);
        ret |= clSetKernelArg(H->worker[i].kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription,               sizeof(cl_float16), &H->sim_desc);
        
        ret |= clSetKernelArg(H->worker[i].kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocityDescription,     sizeof(cl_float16), &H->worker[i].vel_desc);
        ret |= clSetKernelArg(H->worker[i].kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,           sizeof(cl_float16), &H->worker[i].adm_desc[a]);
        ret |= clSetKernelArg(H->worker[i].kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,      sizeof(cl_float16), &H->worker[i].rcs_desc[r]);
        ret |= clSetKernelArg(H->worker[i].kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription,             sizeof(cl_float16), &H->sim_desc);
        
        // Need to add DSD kernel? No, not really
//        ret |= clSetKernelArg(H->worker[i].kern_scat_sig, ...)
    }
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to update kernel arguments in RS_populate().\n", now());
        exit(EXIT_FAILURE);
    }

#endif
    
//    if (H->dsd_name != RSDropSizeDistributionUndefined) {
//        RS_sig_from_dsd(H);
//        if (H->verb) {
//            printf("%s : RS : Drop-size derived RCS computed.\n", now());
//        }
//    }
    
	H->status = RS_STATUS_DOMAIN_POPULATED;
	
	return;
}


void RS_download(RSHandle *H) {
	
	int i;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

//    printf("%p <-----------------------\n", H->scat_ori);
    
    for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy((void *)(H->scat_pos + H->offset[i]), H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy((void *)(H->scat_vel + H->offset[i]), H->worker[i].scat_vel, H->worker[i].num_scats * sizeof(cl_float4));
            //gcl_memcpy((void *)(H->scat_ori + H->offset[i]), H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy((void *)(H->scat_att + H->offset[i]), H->worker[i].scat_att, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy((void *)(H->scat_sig + H->offset[i]), H->worker[i].scat_sig, H->worker[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
		});
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

//    for (i = 0; i < H->num_workers; i++) {
//        dispatch_async(H->worker[i].que, ^{
//            gcl_memcpy((void *)(H->scat_ori + H->offset[i]), H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
//            dispatch_semaphore_signal(H->worker[i].sem);
//        });
//        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
//    }

#else

    int k;
    
    cl_event events[H->num_workers][6];
    
    // Non-blocking read, wait for events later when they are queue up.
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, &events[i][0]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, &events[i][1]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, &events[i][2]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_att, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_att + H->offset[i], 0, NULL, &events[i][3]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, &events[i][4]);
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_FALSE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, &events[i][5]);
	}

    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(6, events[i]);
        for (k = 0; k < 6; k++) {
            clReleaseEvent(events[i][k]);
        }
    }

#endif

    RS_merge_pulse_tmp(H);
}


void RS_download_position_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL,NULL);
	}
	
#endif
	
}

void RS_download_orientation_only(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL,NULL);
    }
    
#endif
    
}

void RS_merge_pulse_tmp(RSHandle *H) {
	memcpy(H->pulse, H->pulse_tmp[0], H->params.range_count * sizeof(cl_float4));
	for (int i = 1; i < H->num_workers; i++) {
		for (int k = 0; k < H->params.range_count; k++) {
			H->pulse[k].s0 += H->pulse_tmp[i][k].s0;
			H->pulse[k].s1 += H->pulse_tmp[i][k].s1;
			H->pulse[k].s2 += H->pulse_tmp[i][k].s2;
			H->pulse[k].s3 += H->pulse_tmp[i][k].s3;
		}
	}
}

void RS_download_pulse_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	for (i = 0; i < H->num_workers; i++)
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	
#else
	
    // Blocking read since there is only one read
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_TRUE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, NULL);
	}
	
#endif
	
	RS_merge_pulse_tmp(H);
}


void RS_upload(RSHandle *H) {
	
	int i;
	
	if (H->verb > 3) {
		for (i = 0; i < H->num_workers; i++) {
			printf("%s : RS : worker[%d].scat_pos @ %p\n", now(), i, H->worker[i].scat_pos);
			printf("%s : RS : worker[%d].scat_vel @ %p\n", now(), i, H->worker[i].scat_vel);
		}
		printf("%s : RS : scat_pos @ %p\n", now(), H->scat_pos);
		printf("%s : RS : scat_vel @ %p\n", now(), H->scat_vel);
	}
	
    if (H->num_scats == 0) {
        printf("%s : RS : Abort @ num_scats = 0 during RS_upload()\n", now());
        return;
    }
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->worker[i].scat_pos, H->scat_pos + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_vel, H->scat_vel + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_ori, H->scat_ori + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->worker[i].scat_tum, H->scat_tum + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_att, H->scat_att + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_sig, H->scat_sig + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_rnd, H->scat_rnd + H->offset[i], H->worker[i].num_scats * sizeof(cl_uint4));
            
            // Set individual color based on drop size
            scat_clr_dsd_kernel(&H->worker[i].ndrange_scat[0],
                                (cl_float4 *)H->worker[i].scat_clr,
                                (cl_float4 *)H->worker[i].scat_pos,
                                (cl_float4 *)H->worker[i].scat_att);

            dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

    // Blocking write since there is no need to optimize this too much
    for (i = 0; i < H->num_workers; i++) {
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_tum, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_tum + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_att, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_att + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rnd, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_uint4),  H->scat_rnd + H->offset[i], 0, NULL, NULL);
	}
    
    size_t local_item_size = 1;

    cl_event events[RS_MAX_GPU_DEVICE];

    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_clr_dsd, 1, &H->worker[i].species_origin[0], &H->worker[i].species_population[0], &local_item_size, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i]);
        clReleaseEvent(events[i]);
    }

#endif
	
}


// Signal strength as a function of drop size
void RS_sig_from_dsd(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            scat_sig_dsd_kernel(&H->worker[i].ndrange_scat[0],
                                (cl_float4 *)H->worker[i].scat_sig,
                                (cl_float4 *)H->worker[i].scat_pos,
                                (cl_float4 *)H->worker[i].scat_att);
            
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else

    size_t local_item_size = 1;
    
    cl_event events[RS_MAX_GPU_DEVICE];
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_sig_dsd, 1, &H->worker[i].species_origin[0], &H->worker[i].species_population[0], &local_item_size, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i]);
        clReleaseEvent(events[i]);
    }
    
#endif

}


void RS_advance_time(RSHandle *H) {
	
	int i, k;
    int r, a;

	if (!(H->status & RS_STATUS_DOMAIN_POPULATED)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}

    const int v = H->vel_idx;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(5.0f / H->params.prt);
        H->vel_idx = H->vel_idx == H->vel_count - 1 ? 0 : H->vel_idx + 1;
        if (H->verb > 2) {
            printf("%s : RS : Wind table advanced. vel_idx = %d\n", now(), H->vel_idx);
        }
    }

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{

//            bg_atts_kernel(&H->worker[i].ndrange_scat[0],
//                           (cl_float4 *)H->worker[i].scat_pos,
//                           (cl_float4 *)H->worker[i].scat_vel,
//                           (cl_float4 *)H->worker[i].scat_att,
//                           (cl_uint4 *)H->worker[i].scat_rnd,
//                           (cl_image)H->worker[i].vel[v],
//                           H->worker[i].vel_desc,
//                           (cl_float *)H->worker[i].angular_weight,
//                           H->worker[i].angular_weight_desc,
//                           H->sim_desc);

            el_atts_kernel(&H->worker[i].ndrange_scat[0],
                           (cl_float4 *)H->worker[i].scat_pos,
                           (cl_float4 *)H->worker[i].scat_vel,
                           (cl_float4 *)H->worker[i].scat_att,
                           (cl_float4 *)H->worker[i].scat_sig,
                           (cl_uint4 *)H->worker[i].scat_rnd,
                           (cl_image)H->worker[i].vel[v],
                           H->worker[i].vel_desc,
                           (cl_float *)H->worker[i].angular_weight,
                           H->worker[i].angular_weight_desc,
                           H->sim_desc);


//            scat_clr_kernel(&H->worker[i].ndrange_scat[0],
//							(cl_float4 *)H->worker[i].scat_clr,
//							(cl_float4 *)H->worker[i].scat_att,
//							(unsigned int)H->worker[i].num_scats);
//
            dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

    for (i = 0; i < H->num_workers; i++) {
        r = 0;
        a = 0;
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                dispatch_async(H->worker[i].que, ^{
                    db_atts_kernel(&H->worker[i].ndrange_scat[k],
                                   (cl_float4 *)H->worker[i].scat_pos,
                                   (cl_float4 *)H->worker[i].scat_ori,
                                   (cl_float4 *)H->worker[i].scat_vel,
                                   (cl_float4 *)H->worker[i].scat_tum,
                                   (cl_float4 *)H->worker[i].scat_att,
                                   (cl_float4 *)H->worker[i].scat_sig,
                                   (cl_uint4 *)H->worker[i].scat_rnd,
                                   (cl_image)H->worker[i].vel[v],
                                   H->worker[i].vel_desc,
                                   (cl_image)H->worker[i].adm_cd[a],
                                   (cl_image)H->worker[i].adm_cm[a],
                                   H->worker[i].adm_desc[a],
                                   (cl_image)H->worker[i].rcs_real[r],
                                   (cl_image)H->worker[i].rcs_imag[r],
                                   H->worker[i].rcs_desc[r],
                                   (cl_float *)H->worker[i].angular_weight,
                                   H->worker[i].angular_weight_desc,
                                   H->sim_desc);
                    
                    dispatch_semaphore_signal(H->worker[i].sem);
                });
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
    }

    for (i = 0; i < H->num_workers; i++) {
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
            }
        }
    }

#else

    cl_event events[RS_MAX_GPU_DEVICE][RS_MAX_DEBRIS_TYPES];
    memset(events, 0, sizeof(events));
	
	if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(1.0f / H->params.prt);
	}
    
    size_t local_item_size = 1;
    
	for (i = 0; i < H->num_workers; i++) {
        r = 0;
        a = 0;

        RSWorker *C = &H->worker[i];

        // Need to refresh some parameters at each time update
        //clSetKernelArg(H->worker[i].kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &H->worker[i].vel[v]);
        //clSetKernelArg(H->worker[i].kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        
        clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
        clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);

        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        
        // Background
        //printf("H->worker[%d].species_population[0] = %d from %d --> background\n", i, (int)H->worker[i].species_population[0], (int)H->worker[i].species_origin[0]);
        //clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_bg_atts, 1, &H->worker[i].species_origin[0], &H->worker[i].species_population[0], &local_item_size, 0, NULL, &events[i][0]);
        clEnqueueNDRangeKernel(C->que, C->kern_el_atts, 1, &C->species_origin[0], &C->species_population[0], &local_item_size, 0, NULL, &events[i][0]);
        
        // Debris type
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (C->species_population[k]) {
                printf("r = %d  a = %d\n", r, a);
                //printf("H->worker[%d].species_population[%d] = %d from %d --> debris\n", i, k, (int)H->worker[i].species_population[k], (int)H->worker[i].species_origin[k]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[a]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);

                clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->species_origin[k], &C->species_population[k], &local_item_size, 0, NULL, &events[i][k]);
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
    }

    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, events[i]);
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                clWaitForEvents(1, &events[i][k]);
            }
        }
    }
	
    for (i = 0; i < H->num_workers; i++) {
        for (k=0; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                clReleaseEvent(events[i][k]);
            }
        }
    }
	
#endif
	
    H->sim_desc.s[RSSimulationParameterSimTic] = ++H->sim_tic;
    H->sim_time = H->sim_tic * H->params.prt;
}


void RS_make_pulse(RSHandle *H) {
	
	int i;
	
	if (!(H->status & RS_STATUS_DOMAIN_POPULATED)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
            make_pulse_pass_1_kernel(&H->worker[i].ndrange_pulse_pass_1,
                                     (cl_float4 *)H->worker[i].work,
                                     (cl_float4 *)H->worker[i].scat_sig,
                                     (cl_float4 *)H->worker[i].scat_att,
                                     H->worker[i].make_pulse_params.local_mem_size[0],
                                     (cl_float *)H->worker[i].range_weight,
                                     H->worker[i].range_weight_desc.s0,
                                     H->worker[i].range_weight_desc.s1,
                                     H->worker[i].range_weight_desc.s2,
                                     H->worker[i].make_pulse_params.range_start,
                                     H->worker[i].make_pulse_params.range_delta,
                                     H->worker[i].make_pulse_params.range_count,
                                     H->worker[i].make_pulse_params.group_counts[0],
                                     H->worker[i].make_pulse_params.entry_counts[0]);

            switch (H->worker[i].make_pulse_params.cl_pass_2_method) {
				case RS_CL_PASS_2_IN_LOCAL:
					make_pulse_pass_2_local_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				case RS_CL_PASS_2_IN_RANGE:
					make_pulse_pass_2_range_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				default:
					make_pulse_pass_2_group_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
			}
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
    cl_event pass_1_events[H->num_workers];
	cl_event pass_2_events[H->num_workers];
	for (i = 0; i < H->num_workers; i++) {
		RSWorker *C = &H->worker[i];
		clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 0, NULL, &pass_1_events[i]);
		clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_2, 1, NULL, &C->make_pulse_params.global[1], &C->make_pulse_params.local[1], 1, &pass_1_events[i], &pass_2_events[i]);
        clFlush(C->que);
	}
	
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &pass_2_events[i]);
		clReleaseEvent(pass_1_events[i]);
		clReleaseEvent(pass_2_events[i]);
    }
	
#endif
	
}


#pragma mark -
#pragma mark Elements for table lookup

RSTable RS_table_init(size_t numel) {
    RSTable table = {0.0f, 1.0f, 1.0f, 0, NULL};
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(float))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table_free(RSTable T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


RSTable2D RS_table2d_init(size_t numel) {
    RSTable2D table;
    
    table.xs = 1.0f;      table.ys = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        fprintf(stderr, "%s : RS : Error allocating an RSTable2D->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table2d_free(RSTable2D T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable3D RS_table3d_init(size_t numel) {
	RSTable3D table;
	
    table.spacing = RSTableSpacingUniform;
    
	table.xs = 1.0f;      table.ys = 1.0f;      table.zs = 1.0f;
	table.xo = 0.0f;      table.yo = 0.0f;      table.zo = 0.0f;
	table.xm = 1.0f;      table.ym = 1.0f;      table.zm = 1.0f;
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable3D->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table3d_free(RSTable3D T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


#pragma mark -
#pragma mark Display

static void RS_show_scat_i(RSHandle *H, const size_t i) {
	printf(" %7lu - ( %9.2f, %9.2f, %9.2f, %4.2f )  %7.2f %7.2f %7.2f   %7.4f %7.4f %7.4f %7.4f\n", i,
		   H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, H->scat_pos[i].w,
		   H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w);
}


static void RS_show_rcs_i(RSHandle *H, const size_t i) {
    printf(" %7lu - ( %9.2f, %9.2f, %9.2f )  %7.4f %7.4f %7.4f %7.4f  [ %7.2f %7.2f %7.2f %7.2f ] %.2f\n", i,
           H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w,
           H->scat_sig[i].x, H->scat_sig[i].y, H->scat_sig[i].z, H->scat_sig[i].w,
           H->scat_att[i].s0);
}


void RS_show_scat_pos(RSHandle *H) {
	size_t i, w;
    for (w = 0; w < H->num_workers; w++) {
        for (i = H->worker[w].species_origin[0];
             i < H->worker[w].species_origin[0] + H->worker[w].species_population[0];
             i += H->worker[w].species_population[0] / 9) {
            RS_show_scat_i(H, i);
        }
    }
	i = H->worker[w].species_origin[0] + H->worker[w].species_population[0] - 1;
	RS_show_scat_i(H, i);
}


void RS_show_scat_sig(RSHandle *H) {
    size_t i, w;
    printf("background:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].species_population[0]; i += H->worker[w].species_population[0] / 9) {
            RS_show_rcs_i(H, H->worker[w].species_global_offset + H->worker[w].species_origin[0] + i);
        }
    }
    if (H->species_population[1] == 0) {
        return;
    }
    // Show the debris
    //i = (int)H->species_population[0] / H->num_workers;
    printf("debris type #1:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].species_population[1]; i++) {
            RS_show_rcs_i(H, H->worker[w].species_global_offset + H->worker[w].species_origin[1] + i);
        }
    }
}

void RS_show_pulse(RSHandle *H) {
	unsigned int i;
	printf(" %7zu - [", H->sim_tic);
	for (i = 0; i < MIN(4, H->params.range_count); i++) {
		if (i > 0) {
			printf(",");
		}
		printf(" %9.2f", H->pulse[i].s0);
	}
	if (i < H->params.range_count) {
		printf(",  . . . , %9.2f", H->pulse[H->params.range_count - 1].s0);
	}
	printf(" ] (%d)\n", H->params.range_count);
}

#pragma mark -

RSBox RS_suggest_scan_doamin(RSHandle *H, const int nbeams) {
    RSBox box;

    // Extremas of the domain
    float w = H->vel_desc.ax * (1.0f - powf(H->vel_desc.rx, 0.5f * (float)(H->vel_desc.nx - 3))) / (1.0f - H->vel_desc.rx);
    float h = H->vel_desc.az * (1.0f - powf(H->vel_desc.rz,        (float)(H->vel_desc.nz - 1))) / (1.0f - H->vel_desc.rz);
    
    // Maximum number of beams plus the padding on one side in azimuth
    float na = 0.5f * (float)nbeams + RS_DOMAIN_PAD + 0.5f;
    
    // Maximum number of beams in elevation
    float ne = 20.0f;
    
    // Maximum y of the emulation box: The range when the width is fully utilized; This is also rmax
    float rmax = w / sinf(na * H->params.antenna_bw_rad);
    
    // Minimum y of the emulation box: The range when the height is fully utilized
    float rmin = (rmax - 2.0f * w) / cosf(na * H->params.antenna_bw_rad) / cosf(ne * H->params.antenna_bw_rad);
    
    // Maximum number of range cells minus the padding on both sides minus one radar cell
    float nr = (rmax - rmin) / H->params.dr - 2.0f * RS_DOMAIN_PAD - 1.0f;
    
    box.origin.a = ceilf(-0.5f * (float)nbeams) * H->params.antenna_bw_rad * 180.0f / M_PI;
    box.size.a = nbeams * H->params.antenna_bw_deg;

    box.origin.r = rmax - (nr + 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;
    box.size.r = floorf(nr - 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;

    box.origin.e = 0.0f;
    box.size.e = ne * H->params.antenna_bw_deg;

    if (H->verb) {
        printf("%s : RS : Suggest scan box based on [ 2w = %.1f m, h = %.1f m ] : nr = %.1f   na = %.1f   ne = %.1f\n"
               "%s : RS : Best fit with R: [ %.3f - %.3f ] km   E: [ %.3f - %.3f ]   A: [ %.3f - %.3f ]\n",
               now(), 2.0f * w, h, nr, na, ne,
               now(), box.origin.r, box.origin.r + box.size.r, box.origin.e, box.origin.e + box.size.e, box.origin.a, box.origin.a + box.size.a);
    }
    
    return box;
}