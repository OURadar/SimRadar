//
//  rs.c
//  Radar Simulation Framework
//
//  Created by Boon Leng Cheong.
//  Copyright (c) 2015-2016 Boon Leng Cheong. All rights reserved.
//

#include "rs.h"
#include "rs_priv.h"

// The block declaration is automatically generated by XCode
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
#include "rs.cl.h"
#endif

#pragma mark -
#pragma mark Private Functions

void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, cl_context_properties sharegroup, const char verb) {
	
    C->dev = dev;
    C->verb = verb;
    C->mem_size = 0;
    
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &C->num_cus, NULL);

#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    // A queue & semaphore for the CL work
    C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, C->dev);
    C->sem = dispatch_semaphore_create(0);
    
    if (C->sem == NULL) {
        fprintf(stderr, "%s : RS : Error creating semaphore for the CL worker.\n", now());
        return;
    }
    
    // Set all the surface to null
    int i;
    for (i = 0; i < RS_MAX_VEL_TABLES; i++) {
        C->surf_vel[i] = NULL;
    }
    for (i = 0; i < RS_MAX_ADM_TABLES; i++) {
        C->surf_adm_cd[i] = NULL;
        C->surf_adm_cm[i] = NULL;
    }
    for (i = 0; i < RS_MAX_RCS_TABLES; i++) {
        C->surf_rcs_real[i] = NULL;
        C->surf_rcs_imag[i] = NULL;
    }
    
#else
	
    cl_int ret;

    if (sharegroup) {
        
        rsprint("shareGroup = %p   verb = %d\n", sharegroup, verb);
        
        cl_context_properties prop[] = {
            CL_CONTEXT_PROPERTY_USE_CGL_SHAREGROUP_APPLE, (cl_context_properties)sharegroup,
            0
        };
        
        // Create a context from a CGL share group
        C->context = clCreateContext(prop, 1, &C->dev, &pfn_notify, NULL, &ret);
        C->sharegroup = sharegroup;
    } else {
        // Create an independent OpenCL context
        C->context = clCreateContext(NULL, 1, &C->dev, &pfn_notify, NULL, &ret);
    }

    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL context.  ret = %d\n", now(), ret);
        exit(EXIT_FAILURE);
    } else if (verb) {
        rsprint("OpenCL context[%d] created (context @ %p, device_id @ %p).\n", (int)C->name, C->context, dev);
    }
    

    // Program
    C->prog = clCreateProgramWithSource(C->context, src_size, (const char **)src_ptr, NULL, &ret);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error creating OpenCL program.  ret = %d\n", now(), ret);
        clReleaseContext(C->context);
        return;
    }
    if (verb) {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", &pfn_prog_notify, NULL);
    } else {
        ret = clBuildProgram(C->prog, 1, &C->dev, "", NULL, NULL);
    }

    if (ret != CL_SUCCESS) {
        char char_buf[RS_MAX_STR] = "";
        clGetProgramBuildInfo(C->prog, C->dev, CL_PROGRAM_BUILD_LOG, RS_MAX_STR, char_buf, NULL);
        fprintf(stderr, "%s : RS : CL Compilation failed:\n%s", now(), char_buf);
        clReleaseProgram(C->prog);
        clReleaseContext(C->context);
        return;
    } else if (verb) {
        rsprint("OpenCL program[%d] created (program @ %p).\n", (int)C->name, C->prog);
    }
	
#define CHECK_CL_CREATE_KERNEL                                                               \
    if (ret != CL_SUCCESS) {                                                                 \
        fprintf(stderr, "%s : RS : Error creating OpenCL kernel.  ret = %d\n", now(), ret);  \
        clReleaseProgram(C->prog);                                                           \
        clReleaseContext(C->context);                                                        \
        return;                                                                              \
    }

    // Tie all kernels to the program
    C->kern_io = clCreateKernel(C->prog, "io", &ret);                                             CHECK_CL_CREATE_KERNEL
    C->kern_dummy = clCreateKernel(C->prog, "dummy", &ret);                                       CHECK_CL_CREATE_KERNEL
    C->kern_bg_atts = clCreateKernel(C->prog, "bg_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_el_atts = clCreateKernel(C->prog, "el_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_db_atts = clCreateKernel(C->prog, "db_atts", &ret);                                   CHECK_CL_CREATE_KERNEL
    C->kern_scat_clr = clCreateKernel(C->prog, "scat_clr", &ret);                                 CHECK_CL_CREATE_KERNEL
    C->kern_scat_rcs = clCreateKernel(C->prog, "scat_rcs", &ret);                                 CHECK_CL_CREATE_KERNEL
    C->kern_scat_sig_aux = clCreateKernel(C->prog, "scat_sig_aux", &ret);                         CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_1 = clCreateKernel(C->prog, "make_pulse_pass_1", &ret);               CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_group = clCreateKernel(C->prog, "make_pulse_pass_2_group", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_local = clCreateKernel(C->prog, "make_pulse_pass_2_range", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2_range = clCreateKernel(C->prog, "make_pulse_pass_2_local", &ret);   CHECK_CL_CREATE_KERNEL
    C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
    
    if (verb) {
        rsprint("Kernels for program[%d] created.\n", (int)C->name);
        if (verb > 2) {
            size_t pref_size;
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_db_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   db_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_el_atts, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   el_atts()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_1()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_group, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_group()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_local, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_local()\n", pref_size);
            
            CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_range, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
            rsprint("KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_range()\n", pref_size);
        }
    }

    // A queue for the CL work of each device
    C->que = clCreateCommandQueue(C->context, C->dev, 0, &ret);
    if (ret != CL_SUCCESS) {
        rsprint("Creating command queue[%d] failed  (ret = %d).\n", C->name, ret);
    }
    
#endif

}


void RS_worker_free(RSWorker *C) {
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	dispatch_release(C->sem);
	dispatch_release(C->que);
	
#else
	
    clReleaseCommandQueue(C->que);
    
    clReleaseKernel(C->kern_io);
    clReleaseKernel(C->kern_dummy);
    clReleaseKernel(C->kern_bg_atts);
    clReleaseKernel(C->kern_el_atts);
    clReleaseKernel(C->kern_db_atts);
    clReleaseKernel(C->kern_scat_clr);
    clReleaseKernel(C->kern_scat_rcs);
    clReleaseKernel(C->kern_scat_sig_aux);
    clReleaseKernel(C->kern_make_pulse_pass_1);
    clReleaseKernel(C->kern_make_pulse_pass_2_group);
    clReleaseKernel(C->kern_make_pulse_pass_2_local);
    clReleaseKernel(C->kern_make_pulse_pass_2_range);
    
    clReleaseProgram(C->prog);
    
    clReleaseContext(C->context);
	
#endif

}


void RS_worker_malloc(RSHandle *H, const int worker_id, const size_t sub_num_scats, const size_t offset) {

    RSWorker *C = &H->worker[worker_id];
    
    if (C == NULL) {
        rsprint("Worker[%d] has not been initialized?\n", worker_id);
        return;
    }
    
    // Copy the necessary parameters from host to compute workers
    C->num_scats = sub_num_scats;
    C->species_global_offset = offset;
    
    size_t work_items = RS_CL_GROUP_ITEMS;

#if !defined (_SHARE_OBJ_)
    
    clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(work_items), &work_items, NULL);

#endif

    if (work_items > RS_CL_GROUP_ITEMS) {
        rsprint("Potential memory leak. work_items(%d) > RS_CL_GROUP_ITEMS(%d).\n", now(), (int)work_items, RS_CL_GROUP_ITEMS);
        return;
    }
    
    size_t max_work_group_size;
    clGetDeviceInfo(C->dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    
    C->make_pulse_params = RS_make_pulse_params((cl_uint)C->num_scats,
                                                (cl_uint)work_items,
                                                (cl_uint)max_work_group_size,
                                                H->params.range_start,
                                                H->params.range_delta,
                                                H->params.range_count);
    
    const unsigned long work_numel = C->make_pulse_params.global[0] * C->make_pulse_params.local[0] * H->params.range_count;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
    // printf("Creating cl_mem from vbo ... %d %d %d \n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);
    C->scat_pos = gcl_gl_create_ptr_from_buffer(C->vbo_scat_pos);
    if (C->scat_pos == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_pos.\n", now());
        C->scat_pos = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_clr = gcl_gl_create_ptr_from_buffer(C->vbo_scat_clr);
    if (C->scat_clr == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_clr.\n", now());
        C->scat_clr = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    C->scat_ori = gcl_gl_create_ptr_from_buffer(C->vbo_scat_ori);
    if (C->scat_ori == NULL) {
        fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer() for scat_ori.\n", now());
        C->scat_ori = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    }
    
    C->scat_vel = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_tum = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_aux = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_rcs = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->scat_sig = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
    C->work = gcl_malloc(work_numel * sizeof(cl_float4), NULL, 0);
    C->pulse = gcl_malloc(H->params.range_count * sizeof(cl_float4), NULL, 0);
    
    C->scat_rnd = gcl_malloc(C->num_scats * sizeof(cl_int4), NULL, 0);
    
    C->mem_size += (cl_uint)( (8 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );

#else
	
#define CHECK_CL_CREATE_BUFFER                                                             \
    if (ret != CL_SUCCESS) {                                                               \
        fprintf(stderr, "%s : RS : Error in clCreateBuffer().  ret = %d\n", now(), ret);   \
        return;                                                                            \
    }
    
    cl_int ret;
    
    //printf("shared_vbo: %d %d %d\n", C->vbo_scat_pos, C->vbo_scat_clr, C->vbo_scat_ori);

    if (H->has_vbo_from_gl) {

#if defined (CL_VERSION_1_2)

        C->scat_pos = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_pos, &ret);
        C->scat_clr = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_clr, &ret);
        C->scat_ori = clCreateFromGLBuffer(C->context, CL_MEM_READ_WRITE, C->vbo_scat_ori, &ret);
        if (C->scat_pos == NULL || C->scat_clr == NULL || C->scat_ori == NULL || ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error in clCreateFromGLBuffer().  ret = %d\n", now(), ret);
            C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
            C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
            C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        }
        
#endif

    } else {
        C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        C->scat_clr = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
        C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    }

    C->scat_vel = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    C->scat_tum = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
	C->scat_aux = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    C->scat_rcs = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
	C->scat_sig = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                       CHECK_CL_CREATE_BUFFER
    C->scat_rnd = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_int4), NULL, &ret);                         CHECK_CL_CREATE_BUFFER
    C->work     = clCreateBuffer(C->context, CL_MEM_READ_WRITE, work_numel * sizeof(cl_float4), NULL, &ret);                         CHECK_CL_CREATE_BUFFER
	C->pulse    = clCreateBuffer(C->context, CL_MEM_READ_WRITE, H->params.range_count * sizeof(cl_float4), NULL, &ret);              CHECK_CL_CREATE_BUFFER
	
	C->mem_size += (cl_uint)( (7 * C->num_scats + work_numel + H->params.range_count) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );
	
	//
	// Set up kernel's input / output arguments
	//
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_io, 0, sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_io, 1, sizeof(cl_mem), &C->scat_aux);
    if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel io().\n", now());
		exit(EXIT_FAILURE);
	}
	
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_dummy, 0, sizeof(cl_mem), &C->scat_pos);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel dummy().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_bg_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_el_atts().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentPosition,                      sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentOrientation,                   sizeof(cl_mem),     &C->scat_ori);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentVelocity,                      sizeof(cl_mem),     &C->scat_vel);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentTumble,                        sizeof(cl_mem),     &C->scat_tum);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSection,             sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRandomSeed,                    sizeof(cl_mem),     &C->scat_rnd);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,            sizeof(cl_mem),     &C->vel[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocityDescription, sizeof(cl_float16), &C->vel_desc);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[0]);
    ret |= clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription,         sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_db_atts().\n", now());
        exit(EXIT_FAILURE);
    }

    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_rcs, RSScattererSignalDropSizeDistributionKernalArgumentRadarCrossSection, sizeof(cl_mem), &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_rcs, RSScattererSignalDropSizeDistributionKernalArgumentPosition,          sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_rcs, RSScattererSignalDropSizeDistributionKernalArgumentAuxiliary,         sizeof(cl_mem), &C->scat_aux);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_rcs().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentColor,     sizeof(cl_mem),   &C->scat_clr);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentPosition,  sizeof(cl_mem),   &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentAuxiliary, sizeof(cl_mem),   &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode,  sizeof(cl_uint4), &H->draw_mode);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_clr().\n", now());
        exit(EXIT_FAILURE);
    }
    
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSignal,                 sizeof(cl_mem),     &C->scat_sig);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentAuxiliary,              sizeof(cl_mem),     &C->scat_aux);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentPosition,               sizeof(cl_mem),     &C->scat_pos);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentRadarCrossSection,      sizeof(cl_mem),     &C->scat_rcs);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTable,            sizeof(cl_mem),     &C->angular_weight);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentWeightTableDescription, sizeof(cl_float4),  &C->angular_weight_desc);
    ret |= clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription,  sizeof(cl_float16), &H->sim_desc);
    if (ret != CL_SUCCESS) {
        fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_sig_aux().\n", now());
        exit(EXIT_FAILURE);
    }
    
    if (C->verb > 1) {
		rsprint("Pass 1   global =%7s   local = %3zu x %2d = %6s B   groups = %4d   N = %9s\n",
			   commaint(C->make_pulse_params.global[0]),
			   C->make_pulse_params.local[0],
			   C->make_pulse_params.range_count,
			   commaint(C->make_pulse_params.local_mem_size[0]),
			   C->make_pulse_params.group_counts[0],
			   commaint(C->make_pulse_params.entry_counts[0]));
	}
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 0, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 1, sizeof(cl_mem),                         &C->scat_sig);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 2, sizeof(cl_mem),                         &C->scat_aux);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 3, C->make_pulse_params.local_mem_size[0], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 4, sizeof(cl_mem),                         &C->range_weight);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 5, sizeof(cl_float4),                      &C->range_weight_desc);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 6, sizeof(float),                          &C->make_pulse_params.range_start);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 7, sizeof(float),                          &C->make_pulse_params.range_delta);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 8, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 9, sizeof(unsigned int),                   &C->make_pulse_params.group_counts[0]);
    ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 10, sizeof(unsigned int),                  &C->make_pulse_params.entry_counts[0]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_1().\n", now());
		exit(EXIT_FAILURE);
	}
	
	if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_local;
	} else if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_range;
	} else {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
	}
	
	if (C->verb > 1) {
		rsprint("Pass 2   global =%7s   local = %3zu x %2lu = %6s B   groups = %3d%s   N = %9s\n",
			   commaint(C->make_pulse_params.global[1]),
			   C->make_pulse_params.local[1],
			   C->make_pulse_params.local_mem_size[1] / C->make_pulse_params.local[1] / sizeof(cl_float4),
			   commaint(C->make_pulse_params.local_mem_size[1]),
			   C->make_pulse_params.group_counts[1],
			   C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE ? "R" :
			   (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL ? "L" : "U"),
			   commaint(C->make_pulse_params.entry_counts[1]));
	}
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 0, sizeof(cl_mem),                         &C->pulse);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 1, sizeof(cl_mem),                         &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 2, C->make_pulse_params.local_mem_size[1], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 3, sizeof(unsigned int),                   &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 4, sizeof(unsigned int),                   &C->make_pulse_params.entry_counts[1]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_2().\n", now());
		exit(EXIT_FAILURE);
	}
	
#endif
	
    if (C->verb) {
        rsprint("worker[%d] memory usage = %s B\n", C->name, commaint(C->mem_size));
    }
}

#pragma mark -
#pragma mark Convenient Functions

char *commaint(long long num) {
	static int i = 7;
	static char buf[8][64];
	
	// Might need a semaphore to protect the following line
	i = i == 7 ? 0 : i + 1;
	
	int b = i;
	snprintf(buf[b], 48, "%lld", num);
	if (num >= 1000) {
		int c = (int)(strlen(buf[b]) - 1) / 3; // Number of commans
		int p = (int)(strlen(buf[b])) + c;     // End position
		int d = 1;                             // Count of digits
		buf[b][p] = '\0';
		while (p > 0) {
			p--;
			buf[b][p] = buf[b][p - c];
			if (d > 3) {
				d = 0;
				buf[b][p] = ',';
				c--;
			}
			d++;
		}
	}
	return buf[b];
}


// Here is a nice reference: http://www.cplusplus.com/ref/ctime/time.html
char *now() {
	static char timestr[64];
	time_t utc;
	time(&utc);
	strftime(timestr, 63, "%H:%M:%S", localtime(&utc));
	return timestr;
}


char *nowlong() {
    static char timestr[64];
    time_t utc;
    time(&utc);
    strftime(timestr, 63, "%Y%m%d-%H%M%S", localtime(&utc));
    return timestr;
}


void rsprint(const char *format, ...) {
	
	char str[RS_MAX_STR] = "";
	sprintf(str, "%s : RS : ", now());
	size_t len = strlen(str);
	va_list args;
	
	va_start(args, format);
	vsnprintf(str + len, RS_MAX_STR - len, format, args);
	len = strlen(str);
	va_end(args);
	
	len = MIN(len, RS_MAX_STR - 2);
	if (str[len-1] != '\n') {
		str[len] = '\n';
		str[len+1] = '\0';
	}
	printf("%s", str);
}


void pfn_prog_notify(cl_program program, void *user_data) {
    if (user_data != NULL) {
        fprintf(stderr, "%s : RS : Program %p returned %p (via pfn_prog_notify)\n", now(), program, user_data);
    }
}


void pfn_notify(const char *errinfo, const void *private_info, size_t cb, void *user_data) {
	fprintf(stderr, "%s : RS : %s (via pfn_notify)\n", now(), errinfo);
}


// CL_DEVICE_TYPE_GPU
void get_device_info(cl_device_type device_type, cl_uint *num_devices, cl_device_id *devices, cl_uint *num_cus, cl_uint *vendors, cl_int detail_level) {
	
	int i = 0, j = 0;
	cl_uint num_platforms = 0;
	cl_uint platform_num_devices = 0;
	
	*num_devices = 0;
	
	cl_platform_id platforms[RS_MAX_GPU_PLATFORM];
	
	char buf_char[RS_MAX_STR];
	cl_uint buf_uint;
	cl_ulong buf_ulong;
	
	CL_CHECK(clGetPlatformIDs(RS_MAX_GPU_PLATFORM, platforms, &num_platforms));
	
	if (detail_level)
		printf("* Number of OpenCL platforms: %d\n", num_platforms);
	
	for (; i < num_platforms; i++) {
		
        CL_CHECK(clGetDeviceIDs(platforms[i], device_type, RS_MAX_GPU_DEVICE - *num_devices, &devices[*num_devices], &platform_num_devices));
		
		*num_devices += platform_num_devices;
		if (*num_devices >= RS_MAX_GPU_DEVICE) {
			fprintf(stderr, "%s : RS : Sweet. A lot of devices found. Upgrade! Upgrade!\n", now());
			*num_devices = RS_MAX_GPU_DEVICE;
			return;
		}
		
		if (detail_level) {
			printf("  > PLATFORM %d:\n", i);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, RS_MAX_STR, buf_char, NULL));
			printf("    * NAME = %s\n", buf_char);
			if (detail_level > 1) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, RS_MAX_STR, buf_char, NULL));
				printf("    * VENDOR = %s\n", buf_char);
			}
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_PROFILE, RS_MAX_STR, buf_char, NULL));
			printf("    * PROFILE = %s\n", buf_char);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, RS_MAX_STR, buf_char, NULL));
			printf("    * VERSION = %s\n", buf_char);
			if (detail_level > 2) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, RS_MAX_STR, buf_char, NULL));
				if (strlen(buf_char)) {
					char *b = buf_char;
					while (1) {
						char *e = strchr(b, ' ');
						if (e) {
							*e = '\0';
						}
						if (b == buf_char) {
							printf("    * EXTENSIONS = %s\n", b);
						} else {
							printf("                   %s\n", b);
						}
						if (e) {
							b = e + 1;
						} else {
							break;
						}
					}
				}
			}
			printf("    * Number of OpenCL devices = %d\n", *num_devices);
			
#define FMT "%-35s"
#define FMT2 "%-14s"
			
			for (j = 0; j < platform_num_devices; j++) {
				printf("      > DEVICE %d:\n", j);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_NAME, RS_MAX_STR, buf_char, NULL));
				printf("        - " FMT " = %s\n", "CL_DEVICE_NAME", buf_char);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VENDOR, RS_MAX_STR, buf_char, NULL));
                if (strcasestr(buf_char, "intel")) {
                    vendors[j] = RS_GPU_VENDOR_INTEL;
                } else if (strcasestr(buf_char, "nvidia")) {
                    vendors[j] = RS_GPU_VENDOR_NVIDIA;
                } else if (strcasestr(buf_char, "amd")) {
                    vendors[j] = RS_GPU_VENDOR_AMD;
                } else {
                    vendors[j] = RS_GPU_VENDOR_UNKNOWN;
                }
				printf("        - " FMT " = %s (%d)\n", "CL_DEVICE_VENDOR", buf_char, vendors[j]);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
				printf("        - " FMT " = %u\n", "CL_DEVICE_MAX_COMPUTE_UNITS", (unsigned int)num_cus[j]);
				if (detail_level > 1) {
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DEVICE_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DRIVER_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(buf_uint), &buf_uint, NULL));
					printf("        - " FMT " = %s MHz\n", "CL_DEVICE_MAX_CLOCK_FREQUENCY", commaint(buf_uint));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_GLOBAL_MEM_SIZE", commaint(buf_ulong));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_MAX_MEM_ALLOC_SIZE", commaint(buf_ulong));
					if (detail_level > 2) {
						size_t work_sizes[3];
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(work_sizes), &work_sizes, NULL);
						printf("        - " FMT " = %zu / %zu / %zu\n", "CL_DEVICE_MAX_WORK_ITEM_SIZES", work_sizes[0], work_sizes[1], work_sizes[2]);
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT " = %zu\n", "CL_DEVICE_MAX_WORK_GROUP_SIZE", work_sizes[0]);
						clGetDeviceInfo(devices[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n", "CL_DEVICE_LOCAL_MEM_SIZE", commaint(buf_ulong));
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n\n", "CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE", commaint(buf_ulong));
						
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT "   " FMT2 " %7s\n", "CL_DEVICE_IMAGE <dim>", "2D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "2D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_DEPTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n\n", "", "3D_MAX_DEPTH", commaint(work_sizes[0]));
					}
				}
			} // for (; j < platform_num_devices; j++)
		} else {
			for (; j < platform_num_devices; j++)
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
		}
	} // for (; i < num_platforms; i++)
}


cl_uint read_kernel_source_from_files(char *src_ptr[], ...) {
	
	static char char_buf[RS_MAX_KERNEL_SRC] = "";
	
	cl_uint count = 0, len = 0;
	
	va_list files;
	
	va_start(files, src_ptr);
	char *filename = va_arg(files, char *);
	while (filename != NULL && strlen(filename) > 0) {

#ifdef DEBUG_KERNEL_READ
		rsprint("src '%s' (%d)\n", filename, (int)strlen(filename));
#endif

        // Read in the kernel source
		FILE *fid = fopen(filename, "r");
		if (fid == NULL) {
			fprintf(stderr, "%s : RS : Error opening kernel source %s.\n", now(), filename);
			break;
		}
		while (!feof(fid) && strlen(char_buf) < RS_MAX_KERNEL_SRC && count < RS_MAX_KERNEL_LINES) {
			src_ptr[count] = fgets(char_buf + len, RS_MAX_KERNEL_SRC - len, fid);
			if (src_ptr[count] != NULL) {
				len += strlen(src_ptr[count]) + 1;
				count++;
			}
		}
		fclose(fid);
		
		filename = va_arg(files, char *);
	}
	va_end(files);
	
	if (len >= RS_MAX_KERNEL_SRC * 8 / 10) {
		printf("%s : RS : \e[31mWARNING. Kernel source size = %s / %s (%.2f > 80%%)\e[0m\n",
			   now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), (float)len / RS_MAX_KERNEL_SRC * 100.0f);
	}
	
	if (len >= RS_MAX_KERNEL_SRC || count >= RS_MAX_KERNEL_LINES) {
		fprintf(stderr, "%s : RS : Kernel source exceeds buffer size constraints.  (len = %s / %s, count = %s / %s)\n",
                now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), commaint(count), commaint(RS_MAX_KERNEL_LINES));
		return 0;
	}
	
#ifdef DEBUG_KERNEL_READ
	printf("%d lines\n", count);
	for (int i = 0; i < count; i++) {
		printf("%d:%s", i, src_ptr[i]);
	}
#endif
	
	return count;
}


ReductionParams *make_reduction_params(cl_uint count, cl_uint user_max_groups, cl_uint user_max_work_items) {
	
	ReductionParams *params = (ReductionParams *)malloc(sizeof(ReductionParams));
	
	if (params == NULL) {
		fprintf(stderr, "%s : RS : Error creating ReductionParams.\n", now());
		return NULL;
	}
	
	// Copy these for housekeeping
	params->count = count;
	params->user_max_groups = user_max_groups;
	params->user_max_work_items = user_max_work_items;
	
	// Work items is only count / 2 for small counts
	int work_items = count > 2 * user_max_work_items ? user_max_work_items : count / 2;
	
	// Number of group of item-pairs
	int groups = count / (work_items * 2);
	if (groups > user_max_groups) {
		groups = user_max_groups;
	}
	
	cl_uint levels = 1;
	cl_uint numels = groups;
	
	// First pass to figure out how many levels
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		numels = numels / (work_items * 2);
		levels++;
	}
	
	params->pass_counts = levels;
	params->entry_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->group_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->work_item_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	
	params->entry_counts[0] = count;
	params->group_counts[0] = groups;
	params->work_item_counts[0] = work_items;
	
	int level = 1;
	
	numels = groups;
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		int groups = numels / (work_items * 2);
		if (groups > user_max_groups) {
			groups = user_max_groups;
		}
		
		params->entry_counts[level] = numels;
		params->group_counts[level] = groups;
		params->work_item_counts[level] = work_items;
		
		numels = numels / (work_items * 2);
		level++;
	}
	
	return params;
}


void free_reduction_params(ReductionParams *params) {
	free(params->entry_counts);
	free(params->group_counts);
	free(params->work_item_counts);
	free(params);
}


float read_table(const float *table, const float index_last, const float index) {
	float floor_index = floorf(index);
	float alpha = index - floor_index;
	if (index <= 0.0f) {
		//		printf("%.2f / %.2f --> i = %u  X0\n", index, index_last, 0);
		return table[0];
	} else if (floor_index >= index_last) {
		//		printf("%.2f / %.2f --> i = %u  XM\n", index, index_last, (unsigned int)index_last);
		return table[(unsigned int)index_last];
	}
	unsigned int i = (unsigned int)floor_index;
	//	printf("%.2f / %.2f --> i = %d, %d / %.2f, %.2f  alpha = %.2f  v = %.3f\n", index, index_last, i, i+1,
	//		   table[i], table[i + 1],
	//		   alpha,
	//		   table[i] + alpha * (table[i + 1] - table[i]);
	return table[i] + alpha * (table[i + 1] - table[i]);
}

#pragma mark -
#pragma mark RS Convenient functions

cl_uint RS_gpu_count(void) {
    cl_uint          num_devs;
    cl_device_id     devs[RS_MAX_GPU_DEVICE];
    cl_uint          num_cus[RS_MAX_GPU_DEVICE];
    cl_uint          vendors[RS_MAX_GPU_DEVICE];
    get_device_info(CL_DEVICE_TYPE_GPU, &num_devs, devs, num_cus, vendors, 0);
    return num_devs;
}

#pragma mark -
#pragma mark RS Initialization and Deallocation


RSHandle *RS_init_with_path(const char *bundle_path, RSMethod method, cl_context_properties sharegroup, const char verb) {
	
    int i;
    
	RSHandle *H;
	
	// Allocate
	if (posix_memalign((void **)((uintptr_t)&H), RS_ALIGN_SIZE, sizeof(RSHandle))) {
		fprintf(stderr, "%s : RS : Error initializing RSHandle.\n", now());
		return NULL;
	}
	memset(H, 0, sizeof(RSHandle));
	
	// Default non-zero parameters
    H->sim_tic = 0;
	H->status = RSStatusDomainNull;
	H->params.c = 3.0e8f;
	H->params.body_per_cell = RS_BODY_PER_CELL;
	H->params.domain_pad_factor = RS_DOMAIN_PAD;
    H->params.lambda = 0.1f;
	H->params.prt = 0.0f;
	H->num_workers = 1;
    H->num_species = 1;
	H->method = method;
	
	for (i = 0; i < RS_MAX_GPU_DEVICE; i++) {
		H->worker[i].name = i;
	}
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        H->species_population[i] = 0;
    }
	
	if (H->method == RS_METHOD_GPU) {
		if (verb) {
			rsprint("Getting CL devices ...");
		}
		// Get and show some device info
		get_device_info(CL_DEVICE_TYPE_GPU, &H->num_devs, H->devs, H->num_cus, H->vendors, verb);
	} else if (H->method == RS_METHOD_CPU) {
		// Run this to get the num_cus to the same values.
		get_device_info(CL_DEVICE_TYPE_CPU, &H->num_devs, H->devs, H->num_cus, H->vendors, 0);
	}
    if (H->num_devs == 0 || H->num_cus[0] == 0) {
        fprintf(stderr, "%s : RS : Error. No OpenCL devices found.\n", now());
        return NULL;
    }

    H->num_workers = H->num_devs;
    switch (H->vendors[0]) {
        case RS_GPU_VENDOR_AMD:
        case RS_GPU_VENDOR_INTEL:
            H->preferred_multiple = H->num_cus[0] * 16;
            break;
        case RS_GPU_VENDOR_NVIDIA:
            H->preferred_multiple = H->num_cus[0] * 64;
            break;
        default:
            H->preferred_multiple = H->num_cus[0] * 256;
            break;
    }

#if defined (GUI)
    // Force to one GPU at the moment. Seems like OpenGL context can be shared with only one OpenCL context
    H->num_workers = 1;
#endif

#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    H->num_workers = 1;
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], 0, NULL, 0, verb);
    }

#else

    cl_uint count;
    char *src_ptr[RS_MAX_KERNEL_LINES];
    
    // Kernel source
    if (!strcmp(bundle_path, ".")) {
        count = read_kernel_source_from_files(src_ptr, "rs.cl", NULL);
    } else {
        #ifdef INCLUDE_TYPES_IN_KERNEL
        
        // This version combines special types along with the kernel functions
        char types_h_path[RS_MAX_STR];
        char kern_src_path[RS_MAX_STR];
        snprintf(types_h_path, RS_MAX_STR, "%s/rs_types.h", bundle_path);
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, types_h_path, kern_src_path, NULL);

        #else
        
        // This version does not depend on custom types
        char kern_src_path[RS_MAX_STR];
        snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
        count = read_kernel_source_from_files(src_ptr, kern_src_path, NULL);
        
        #endif
    }
    
    if (count == 0) {
        rsprint("Empty kernel source.");
        return NULL;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        if (verb > 2) {
            rsprint("Initializing worker %d using %p\n", i, H->devs[i]);
        }
        RS_worker_init(&H->worker[i], H->devs[i], count, (const char **)src_ptr, sharegroup, verb);
    }
	
#endif
		
    // Temporary supress the verbose output for setting default values
	H->verb = 0;
	
    // Set up some basic parameters to default values, H->verb is still 0 so no API message output
    RS_set_antenna_params(H, 1.0f, 50.0f);

    RS_set_tx_params(H, 1.0e-6f, 50.0e3f);
    
    RS_set_beam_pos(H, 5.0f, 1.0f);
    
	RS_set_scan_box(H,
					15.0e3f, 20.0e3f, 250.0f,                   // Range
					-12.0f, 12.0f, 1.0f,                        // Azimuth
					0.0f, 8.0f, 1.0f);                          // Elevation
		
	//RS_set_angular_weight_to_double_cone(H, 2.0f / 180.0f * M_PI);
	
	H->verb = verb;
	
	return H;
}


RSHandle *RS_init_for_cpu_verbose(const char verb) {
	return RS_init_with_path(".", RS_METHOD_CPU, 0, verb);
}


RSHandle *RS_init_verbose(const char verb) {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, verb);
}


RSHandle *RS_init() {
    return RS_init_with_path(".", RS_METHOD_GPU, 0, 0);
}


void RS_free_scat_memory(RSHandle *H) {
	int i;
	
	if (H->verb > 2) {
		rsprint("Freeing GPU memories ...");
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vbo_scat_pos == 0) {
			fprintf(stderr, "%s : RS : Unexpected error. VBO was not shared.\n", now());
			return;
		}
		gcl_free(H->worker[i].scat_pos);
		gcl_free(H->worker[i].scat_clr);  // Only the GUI version has this
		gcl_free(H->worker[i].scat_vel);
		gcl_free(H->worker[i].scat_ori);
        gcl_free(H->worker[i].scat_tum);
		gcl_free(H->worker[i].scat_aux);
        gcl_free(H->worker[i].scat_rcs);
		gcl_free(H->worker[i].scat_sig);
		gcl_free(H->worker[i].work);
		gcl_free(H->worker[i].pulse);
		gcl_free(H->worker[i].scat_rnd);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].scat_pos);
        clReleaseMemObject(H->worker[i].scat_clr);
		clReleaseMemObject(H->worker[i].scat_vel);
		clReleaseMemObject(H->worker[i].scat_ori);
        clReleaseMemObject(H->worker[i].scat_tum);
		clReleaseMemObject(H->worker[i].scat_aux);
        clReleaseMemObject(H->worker[i].scat_rcs);
		clReleaseMemObject(H->worker[i].scat_sig);
		clReleaseMemObject(H->worker[i].work);
		clReleaseMemObject(H->worker[i].pulse);
		clReleaseMemObject(H->worker[i].scat_rnd);
	}
	
#endif
	
	if (H->verb > 2) {
		rsprint("Freeing CPU memories ...");
	}
	
	free(H->scat_pos);
	free(H->scat_vel);
	free(H->scat_ori);
    free(H->scat_tum);
	free(H->scat_aux);
    free(H->scat_rcs);
	free(H->scat_sig);
    free(H->scat_rnd);

	free(H->pulse);
	
	for (i = 0; i < H->num_workers; i++) {
		free(H->pulse_tmp[i]);
	}
}


void RS_free(RSHandle *H) {
	
    int i;
    
	char v = H->verb;
	
	for (i = 0; i < H->num_workers; i++) {
		RS_worker_free(&H->worker[i]);
	}
	
	RS_free_scat_memory(H);
	
    int t = 0;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

	for (i = 0; i < H->num_workers; i++) {
		gcl_free(H->worker[i].range_weight);
		gcl_free(H->worker[i].angular_weight);
		gcl_release_image(H->worker[i].vel[t]);
        gcl_release_image(H->worker[i].adm_cd[t]);
        gcl_release_image(H->worker[i].adm_cm[t]);
        gcl_release_image(H->worker[i].rcs_real[t]);
        gcl_release_image(H->worker[i].rcs_imag[t]);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].range_weight);
		clReleaseMemObject(H->worker[i].angular_weight);
		clReleaseMemObject(H->worker[i].vel[t]);
        clReleaseMemObject(H->worker[i].adm_cd[t]);
        clReleaseMemObject(H->worker[i].adm_cm[t]);
        clReleaseMemObject(H->worker[i].rcs_real[t]);
        clReleaseMemObject(H->worker[i].rcs_imag[t]);
	}
	
#endif
	
    free(H->anchor_pos);
    free(H->anchor_lines);
    
    free(H);
    
    if (v) {
        rsprint("Resources released.");
    }
}


RSMakePulseParams RS_make_pulse_params(const cl_uint count, const cl_uint user_max_work_items, cl_uint user_max_groups,
									   const float range_start, const float range_delta, const unsigned int range_count) {
	RSMakePulseParams param;

	// Keep a copy for reference
	param.num_scats = count;
	param.user_max_groups = user_max_groups;
	param.user_max_work_items = user_max_work_items;
	param.range_start = range_start;
	param.range_delta = range_delta;
	param.range_count = MAX(1, range_count);
    
	// The 2nd pass kernel functions are only for work_items <= 1024.
	if (user_max_groups > 1024) {
		fprintf(stderr, "%s : RS : I'm not programmed to handle user_max_groups > 1024.\n", now());
		param.user_max_groups = 1024;
	}
	
	// Work items is at most count / 2
	unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : count / 2;
	
	// Number of group item-pairs
	unsigned int group_count = count <= work_items * 2 ? 1 : count / (work_items * 2);
	if (group_count > param.user_max_groups) {
		group_count = param.user_max_groups;
	}
	
	//printf("count=%d  work_items=%d  groups=%d/%d\n", count, work_items, group_count, param.user_max_groups);
	
	// 1st pass
	param.entry_counts[0] = count;
	param.group_counts[0] = group_count;
	param.global[0] = group_count * work_items;
	param.local[0] = work_items;
	param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
	
	// 2nd pass
	unsigned int work_count = group_count * param.range_count;
	
	param.entry_counts[1] = work_count;
    work_items = work_count / (param.range_count * 2);
    if (work_items < 1) {
        fprintf(stderr, "%s : RS : 2nd pass with CL work_items < 2?\n", now());
        work_items = 1;
    }

	if (param.local[0] % param.range_count == 0 && user_max_work_items >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_UNIVERSAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else if (group_count >= 2 * param.range_count && user_max_work_items >= work_items) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_LOCAL;
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_RANGE;
		param.group_counts[1] = 1;
		param.global[1] = param.range_count;
		param.local[1] = 1;
		param.local_mem_size[1] = sizeof(cl_float4);
		
	}
	if (param.entry_counts[1] > RS_MAX_GATES * work_items) {
		fprintf(stderr, "%s : RS : H->dev_work may not be large enough.\n", now());
	}
	return param;
}


void RS_init_scat_pos(RSHandle *H) {
    
    int counts[H->dsd_count];
    int i, k, bin;
    float a;
    
    memset(counts, 0, H->dsd_count * sizeof(int));
    
    RSVolume domain = RS_get_domain(H);

    //
	// Initialize the scatter body positions & velocities
	//
	for (i = 0; i < H->num_scats; i++) {
		H->scat_pos[i].x = (float)rand() / RAND_MAX * domain.size.x + domain.origin.x;
		H->scat_pos[i].y = (float)rand() / RAND_MAX * domain.size.y + domain.origin.y;
		H->scat_pos[i].z = (float)rand() / RAND_MAX * domain.size.z + domain.origin.z;
        H->scat_pos[i].w = 0.0f;                       // Use this to store drop radius
        
		H->scat_aux[i].s0 = 0.0f;                      // Use this to store range
        H->scat_aux[i].s1 = (float)rand() / RAND_MAX;  // Use this to store age
		H->scat_aux[i].s2 = 0.0f;
		H->scat_aux[i].s3 = 1.0f;                      // Use this to store angular weight
		
		H->scat_vel[i].x = 0.0f;
		H->scat_vel[i].y = 0.0f;
		H->scat_vel[i].z = 0.0f;
		H->scat_vel[i].w = 0.0f;

        // At the reference
        H->scat_ori[i].x = 0.0f;
        H->scat_ori[i].y = 0.0f;
        H->scat_ori[i].z = 0.0f;
        H->scat_ori[i].w = 1.0f;
        
        // Facing the sky
//        H->scat_ori[i].x =  0.0f;
//        H->scat_ori[i].y = -0.707106781186547f;
//        H->scat_ori[i].z =  0.0f;
//        H->scat_ori[i].w =  0.707106781186548f;

        // Facing the beam
//        H->scat_ori[i].x =  0.5f;
//        H->scat_ori[i].y = -0.5f;
//        H->scat_ori[i].z = -0.5f;
//        H->scat_ori[i].w =  0.5f;
        
        // Some other tests
//        H->scat_ori[i].x =  0.5f;
//        H->scat_ori[i].y =  0.5f;
//        H->scat_ori[i].z = -0.5f;
//        H->scat_ori[i].w =  0.5f;

        // Rotate by theta
//        float theta = 70.0f / 180.0f * M_PI_2;
//        H->scat_ori[i].x = 0.0f;
//        H->scat_ori[i].y = 0.0f;
//        H->scat_ori[i].z = sinf(0.5f * theta);
//        H->scat_ori[i].w = cosf(0.5f * theta);
        
        // Tumbling vector for orientation update
        H->scat_tum[i].x = 0.0f;
        H->scat_tum[i].y = 0.0f;
        H->scat_tum[i].z = 0.0f;
        H->scat_tum[i].w = 1.0f;

        // Initial return from each point
        H->scat_rcs[i].s0 = 1.0f;
		H->scat_rcs[i].s1 = 0.0f;
		H->scat_rcs[i].s2 = 1.0f;
		H->scat_rcs[i].s3 = 0.0f;
        
        // Random seeds
        H->scat_rnd[i].s0 = rand();
        H->scat_rnd[i].s1 = rand();
        H->scat_rnd[i].s2 = rand();
        H->scat_rnd[i].s3 = rand();
	}
    
    // Parameterized drop radius as scat_pos.w if DSD has been set
    // May want to add maximum relaxation time of each drop size
    // Potential places: vel.w, aux.s2
    if (H->dsd_name != RSDropSizeDistributionUndefined) {
        for (i = 0; i < H->num_scats; i++) {
            a = (float)rand() / RAND_MAX;
            k = H->dsd_count;
            bin = 0;
            while (k > 0) {
                k--;
                if (a >= H->dsd_cdf[k]) {
                    bin = k;
                    break;
                }
            }
            counts[bin]++;
            H->scat_pos[i].w = H->dsd_r[bin];
            H->scat_aux[i].s2 = ((float)bin + 0.5f) /  (float)(H->dsd_count);  // temporary use this to store normalized bin index
        }
        
        if (H->verb > 1) {
            rsprint("Actual DSD Specifications:");
            for (i = 0; i < MIN(H->dsd_count - 2, 3); i++) {
                printf("                 o %.2f mm - PDF %.5f / %.5f / %d particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)counts[i] / (float)H->num_scats, counts[i]);
            }
            if (H->dsd_count > 8) {
                printf("                 o  :      -      :     /  :     /\n");
                printf("                 o  :      -      :     /  :     /\n");
                i = MAX(4, H->dsd_count - 1);
            }
            for (; i < H->dsd_count; i++) {
                printf("                 o %.2f mm - PDF %.5f / %.5f / %d particles\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], (float)counts[i] / (float)H->num_scats, counts[i]);
            }
        }
    }
	
	// Replace a few points for debugging purpose.
	H->scat_pos[0].x = domain.origin.x + 0.5f * domain.size.x;
	H->scat_pos[0].y = domain.origin.y + 0.5f * domain.size.y;
	H->scat_pos[0].z = domain.origin.z + 0.5f * domain.size.z;
	
    // Replace the very first debris particle
    if (H->species_population[1] > 0) {
        k = (int)H->species_population[0] / H->num_workers;
        H->scat_pos[k].x = 0.0f;
        H->scat_pos[k].y = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
        H->scat_pos[k].z = 0.5f * domain.size.z;
        
        H->scat_aux[k].s0 = H->params.range_start + floorf(H->params.range_count * 0.5f) * H->params.range_delta;
    }
	
	// Restore simulation time, default beam position at unit vector (0, 1, 0)
	H->sim_tic = 0;
	H->sim_toc = 0;
	H->sim_time = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = 1.0f;
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = 0.0f;
    H->sim_desc.s[RSSimulationDescriptionWaveNumber] = 4.0f * M_PI / H->params.lambda;
    H->sim_desc.s[RSSimulationDescriptionTimeIncrement] = H->params.prt;
    H->sim_desc.s[RSSimulationDescriptionTotalParticles] = H->num_scats;
    H->sim_desc.s[RSSimulationDescriptionDebrisAgeIncrement] = H->params.prt / H->worker[0].vel_desc.s[RSTable3DDescriptionRefreshTime];
    
    // Make a copy in float so we are maintaining all 32-bits
    float tmpf; memcpy(&tmpf, &H->sim_concept, sizeof(float));
    H->sim_desc.s[RSSimulationDescriptionConcept] = tmpf;
    
    // Propagate / duplicate some constants to other places for efficient kernel execution
    for (i = 0; i < H->num_workers; i++) {
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionUserConstant] = H->sim_desc.s[RSSimulationDescriptionWaveNumber];
    }
}

#pragma mark -
#pragma mark Properties

void RS_set_concept(RSHandle *H, RSSimulationConcept c) {
    H->sim_concept = c;
}


void RS_set_prt(RSHandle *H, const float prt) {
	H->params.prt = prt;
	H->params.prf = 1.0f / prt;
    
    H->sim_desc.s[RSSimulationDescriptionTimeIncrement] = H->params.prt;
}


void RS_set_lambda(RSHandle *H, const float lambda) {
    H->params.lambda = lambda;
}


void RS_set_density(RSHandle *H, const float density) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Density cannot be changed.");
        return;
    }
	H->params.body_per_cell = density;
}


void RS_set_antenna_params(RSHandle *H, RSfloat beamwidth_deg, RSfloat gain_dbi) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar antenna parameters cannot be changed.");
        return;
    }
	H->params.antenna_bw_deg = beamwidth_deg;
	H->params.antenna_bw_rad = H->params.antenna_bw_deg * M_PI / 180.0f;
    
    RS_set_angular_weight_to_standard(H, H->params.antenna_bw_rad);
}


void RS_set_tx_params(RSHandle *H, RSfloat pulsewidth, RSfloat tx_power_watt) {
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Radar parameters cannot be changed.");
        return;
    }
	H->params.tau = pulsewidth;
	H->params.dr = H->params.c * H->params.tau * 0.5f;
	H->params.tx_power_watt = tx_power_watt;

    RS_set_range_weight_to_triangle(H, H->params.dr);
}


void RS_set_scan_box(RSHandle *H,
					 RSfloat range_start, RSfloat range_end, RSfloat range_delta,
					 RSfloat azimuth_start, RSfloat azimuth_end, RSfloat azimuth_delta,
					 RSfloat elevation_start, RSfloat elevation_end, RSfloat elevation_delta) {
	
    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation domain has been populated. Scan box cannot be changed.");
        return;
    }

    //	H->status &= !RSStatusDomainPopulated;
	H->params.range_start = range_start;
	H->params.range_end = range_end;
	H->params.range_delta = range_delta;
	H->params.azimuth_start_deg = azimuth_start;
	H->params.azimuth_end_deg = azimuth_end;
	H->params.azimuth_delta_deg = azimuth_delta;
	H->params.elevation_start_deg = elevation_start;
	H->params.elevation_end_deg = elevation_end;
	H->params.elevation_delta_deg = elevation_delta;
	
	const RSfloat r_lo = floor((H->params.range_start - H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat r_hi =  ceil((H->params.range_end   + H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat az_lo = floor((H->params.azimuth_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat az_hi =  ceil((H->params.azimuth_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat el_lo = MAX(0.0f, floor((H->params.elevation_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat el_hi = MIN(90.0f,  ceil((H->params.elevation_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat tiny = 1.0e-5;
	
	int nr = 0;
	int naz = 0;
	int nel = 0;
	
	RSfloat r;
	RSfloat az;
	RSfloat el;
	
	int ii = 0;
	
	// Number of range gates
	r = floor(H->params.range_start / H->params.range_delta) * H->params.range_delta;
	while (r <= ceil(H->params.range_end / H->params.range_delta) * H->params.range_delta) {
		r += H->params.range_delta;
		nr++;
	}
	H->params.range_count = MIN(RS_MAX_GATES, nr);
	
	// Evaluate the number of scatterers needed
	az = az_lo;
	while (az <= az_hi + tiny) {
		az += H->params.azimuth_delta_deg;
		if (az >= 360.0f) {
			az -= 360.0f;
		}
		naz++;
	}
	el = el_lo;
	while (el <= el_hi) {
		el += H->params.elevation_delta_deg;
		nel++;
    }
    // Zero volume
    if (naz == 0 || nel == 0) {
        rsprint("NEL = %d and/or NAZ = %d resulted in a zero volumne.\n", naz, nel);
        return;
    }
	H->num_anchors  = 2 * naz * nel + 1;  // Save one for radar origin
	// printf("%s : RS : Number of anchors needed = %d  (naz = %d  nel = %d)\n", now(), (int)H->num_anchors, naz, nel);
	if (H->anchor_pos) {
		if (H->verb > 2) {
			rsprint("Freeing existing anchor memory.");
		}
		free(H->anchor_pos);
	}
	H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
	if (H->anchor_pos == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchors.\n", now());
		return;
	}
	
	// Domain size
	RSfloat
	xmin = INFINITY, xmax = -INFINITY,
	ymin = INFINITY, ymax = -INFINITY,
    zmin = INFINITY, zmax = -INFINITY;
	el = el_lo / 180.0f * M_PI;
	while (el <= el_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
		az = az_lo / 180.0f * M_PI;
		while (az <= az_hi / 180.0f * M_PI + tiny && ii < H->num_anchors - 1) {
			H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_lo * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_hi * sin(el);
			H->anchor_pos[ii].w = 1.0f;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			az += azimuth_delta / 180.0f * M_PI;
		}
		el += elevation_delta / 180.0f * M_PI;
	}
	
	// Radar origin at (0, 0, 0)
	H->anchor_pos[ii].x = 0.0f;
	H->anchor_pos[ii].y = 0.0f;
	H->anchor_pos[ii].z = 0.0f;
	H->anchor_pos[ii].w = 5.0f;
	
	//printf("H->num_anchors = %zu   ii = %d\n", H->num_anchors, ii);
	
	// Volume of a single resolution cell
	r = 0.5f * (H->params.range_start + H->params.range_start);
	RSfloat vol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5f);
	RSfloat nvol = ((xmax - xmin) * (ymax - ymin) * (zmax - zmin)) / vol;
	
    // The closing domain of the simulation
    H->sim_desc.s[RSSimulationDescriptionBoundSizeX] = xmax - xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeY] = ymax - ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundSizeZ] = zmax - zmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginX] = xmin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginY] = ymin;
    H->sim_desc.s[RSSimulationDescriptionBoundOriginZ] = zmin;
	
	// Suggest a number of scatter bodies to use
	H->num_scats = (size_t)(H->params.body_per_cell * nvol);
	
	// Round to a GPU preferred number: make_pulse_pass_1 uses 2 x max_work_group_size stride
    size_t max_work_group_size;
    clGetDeviceInfo(H->worker[0].dev, CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(max_work_group_size), &max_work_group_size, NULL);
    size_t mul = H->num_cus[0] * H->num_devs * max_work_group_size * 2;
	size_t preferred_n = (size_t)(H->num_scats / mul) * mul;
	while (preferred_n < H->params.body_per_cell * 9 / 10) {
		preferred_n += mul;
	}
	
	if (H->verb) {
        rsprint("User domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+6.2f ~ %+6.2f ] deg\n",
               1.0e-3*H->params.range_start, 1e-3*H->params.range_end,
               H->params.elevation_start_deg, H->params.elevation_end_deg,
               H->params.azimuth_start_deg, H->params.azimuth_end_deg);
        rsprint("Work domain @ R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %+6.2f ~ %+6.2f ] deg\n",
               1.0e-3*r_lo, 1.0e-3*r_hi,
               el_lo, el_hi,
               az_lo, az_hi);
		rsprint("            @ X:[ %.2f ~ %.2f ] m   Y:[ %.2f ~ %.2f ] m   Z:[ %.2f ~ %.2f ] m\n",
			   xmin, xmax,
			   ymin, ymax,
               zmin, zmax);
        rsprint("              = ( %.2f m x %.2f m x %.2f m )\n",
               xmax - xmin, ymax - ymin, zmax - zmin);
        rsprint("nvol = %s.%02d\n", commaint(floor(nvol)), (int)(100 * (nvol - floor(nvol))));
		rsprint("Suggested %s bodies\n", commaint(preferred_n));
		rsprint("Set to GPU preferred %s (%.2f bodies / resolution cell)\n", commaint(preferred_n), (float)preferred_n / nvol);
	}
	
    // Now, we actually set it to suggested debris count
	H->num_scats = preferred_n;
	
	// Anchor lines to show the volume of interest, which was set by the user. The number is well more than enough
	H->num_anchor_lines  = 8 * (naz + nel);
	
	if (H->anchor_lines) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor_line memory.\n", now());
		}
		free(H->anchor_lines);
	}
	H->anchor_lines = (cl_float4 *)malloc(H->num_anchor_lines * sizeof(cl_float4));
	if (H->anchor_lines == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchor_lines.\n", now());
		return;
	}
	ii = 0;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	// printf("num_anchor_lines = %zu  ii = %d\n", H->num_anchor_lines, ii);
	
	H->num_anchor_lines = ii;
	
	return;
}


void RS_set_beam_pos(RSHandle *H, RSfloat az_deg, RSfloat el_deg) {
	// Compute the unit vector of the pointing direction
    H->sim_desc.s[RSSimulationDescriptionBeamUnitX] = cosf(el_deg / 180.0f * M_PI) * sinf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitY] = cosf(el_deg / 180.0f * M_PI) * cosf(az_deg / 180.0f * M_PI);
    H->sim_desc.s[RSSimulationDescriptionBeamUnitZ] = sinf(el_deg / 180.0f * M_PI);

    H->status |= RSStatusScattererSignalsNeedsUpdate;
}


void RS_set_verbosity(RSHandle *H, const char verb) {
	H->verb = verb;
}


void RS_set_debris_count(RSHandle *H, const int species_id, const size_t count) {
    
    int i;
    
    if (species_id == 0) {
        printf("%s : RS : RS_set_debris_count() cannot have species = 0.\n", now());
        return;
    }

    H->species_population[species_id] = count;

    H->num_species = 0;
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->species_population[i] > 0) {
            H->num_species++;
        }
    }
    
    if (H->verb > 1) {
        printf("%s : RS : Total number of species = %d\n", now(), (int)H->num_species);
    }

    if (H->sim_tic > 0) {
        RS_update_debris_count(H);
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        RS_derive_ndranges(H);
        
#endif

    }
}


void RS_revise_debris_counts_to_gpu_preference(RSHandle *H) {
    
    int i;
    
    for (i = 0; i < RS_MAX_DEBRIS_TYPES; i++) {
        if (H->species_population[i]) {
            H->species_population[i] = ((H->species_population[i] + H->preferred_multiple - 1) / H->preferred_multiple) * H->preferred_multiple;
        }
    }
}


size_t RS_get_debris_count(RSHandle *H, const int species_id) {
    return H->species_population[species_id];
}


size_t RS_get_worker_debris_count(RSHandle *H, const int species_id, const int worker_id) {
    return H->worker[worker_id].species_population[species_id];
}


size_t RS_get_all_worker_debris_counts(RSHandle *H, const int species_id, size_t counts[]) {
    
    int i;
    
    for (i = 0; i < H->num_workers; i++) {
        counts[i] = H->worker[i].species_population[species_id];
    }
    return H->species_population[species_id];
}


RSVolume RS_get_domain(RSHandle *H) {
    RSVolume v;
    v.size.x = H->sim_desc.s[RSSimulationDescriptionBoundSizeX];
    v.size.y = H->sim_desc.s[RSSimulationDescriptionBoundSizeY];
    v.size.z = H->sim_desc.s[RSSimulationDescriptionBoundSizeZ];
    v.origin.x = H->sim_desc.s[RSSimulationDescriptionBoundOriginX];
    v.origin.y = H->sim_desc.s[RSSimulationDescriptionBoundOriginY];
    v.origin.z = H->sim_desc.s[RSSimulationDescriptionBoundOriginZ];
    return v;
}


void RS_update_debris_count(RSHandle *H) {
    
    int i, k;
    
    size_t count = H->num_scats;
    
    if (H->num_workers == 0) {
        printf("%s : RS : Expected. Number of workers = 0.\n", now());
        return;
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 1) {
        k--;
        count -= H->species_population[k];
    }
    H->species_population[0] = count;

    if (H->verb > 1) {
        printf("%s : RS : Population details:\n", now());
        for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            printf("                 o Global species_population[%d] = %s\n", k, commaint(H->species_population[k]));
        }
    }
    
    k = RS_MAX_DEBRIS_TYPES;
    while (k > 0) {
        k--;
        size_t species_count_left = H->species_population[k];
        if (species_count_left == 0) {
            for (i = 0; i < H->num_workers; i++) {
                H->worker[i].species_population[k] = 0;
            }
            continue;
        }
        // Groups of debris types
        size_t round_up_down_toggle = H->num_workers > 1 ? k % H->num_workers : k;
        size_t sub_species_population = (H->species_population[k] + round_up_down_toggle) / H->num_workers;
        for (i = 0; i < H->num_workers - 1; i++) {
            H->worker[i].species_population[k] = sub_species_population;
            species_count_left -= sub_species_population;
        }
        // The last worker gets all the remainders
        H->worker[i].species_population[k] = species_count_left;
    }
    
    for (i = 0; i < H->num_workers; i++) {
        k = RS_MAX_DEBRIS_TYPES;
        size_t origin = H->worker[i].num_scats;
        while (k > 1) {
            k--;
            if (H->worker[i].species_population[k] == 0) {
                continue;
            }
            origin -= H->worker[i].species_population[k];
            H->worker[i].species_origin[k] = origin;
        }
    }
    
    if (H->verb > 2) {
        for (i = 0; i < H->num_workers; i++) {
            printf("%s : RS : worker[%d] with total population %s  offset %s\n", now(), i, commaint(H->worker[i].num_scats), commaint(H->worker[i].species_global_offset));
            for (k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
                printf("                 o species_population[%d] - [ %9s, %9s, %9s ]\n", k,
                       commaint(H->worker[i].species_origin[k]),
                       commaint(H->worker[i].species_population[k]),
                       commaint(H->worker[i].species_origin[k] + H->worker[i].species_population[k]));
            }
        }
    }
}


void RS_set_dsd(RSHandle *H, const float *pdf, const float *diameters, const int count, const char name) {
    
    if (H->status & RSStatusDomainPopulated) {
        fprintf(stderr, "%s : RS : Simulation domain has been populated. DSD cannot be changed.", now());
        return;
    }
    
    int i;
    
    if (count == 0) {
        printf(" %s : RS : DSD bin count cannot be 0.\n", now());
        return;
    }
    
    H->dsd_name = name;
    H->dsd_count = count;
    
    if (H->dsd_r != NULL) {
        free(H->dsd_r);
        free(H->dsd_pdf);
        free(H->dsd_cdf);
    }
    H->dsd_r = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_pdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    H->dsd_cdf = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    if (H->dsd_r == NULL || H->dsd_pdf == NULL || H->dsd_cdf == NULL) {
        fprintf(stderr, "%s : RS : Error allocating resources for DSD parameterization.\n", now());
        return;
    }
    
    memset(H->dsd_r, 0, count * sizeof(RSfloat));
    memset(H->dsd_pdf, 0, count * sizeof(RSfloat));
    memset(H->dsd_cdf, 0, count * sizeof(RSfloat));
    
    RSfloat lo = 0.0f;
    
    for (i = 0; i < count; i++) {
        H->dsd_r[i] = 0.5f * diameters[i];
        H->dsd_pdf[i] = pdf[i];
        H->dsd_cdf[i] = lo;
        lo += pdf[i];
    }
    
    if (H->verb) {
        printf("%s : RS : User set DSD specifications:\n", now());
        for (i = 0; i < MIN(MAX(count - 2, 1), 3); i++) {
            printf("                 o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
        if (count > 5) {
            printf("                 o  :      -      :     /     :\n");
            printf("                 o  :      -      :     /     :\n");
            i = MAX(4, count - 1);
        }
        for (; i < count; i++) {
            printf("                 o %.2f mm - PDF %.4f / TH %.4f\n", 2000.0f * H->dsd_r[i], H->dsd_pdf[i], H->dsd_cdf[i]);
        }
    }
}


void RS_set_dsd_to_mp(RSHandle *H) {
    
    int i;
    
    float d, sum = 0.0f;
    
    //float ds[] = {0.0001f, 0.0002f, 0.0005f, 0.001f, 0.002f, 0.003f, 0.004f, 0.005f};
    float ds[] = {0.001f, 0.003f};
    
    const int count = sizeof(ds) / sizeof(float);
    
    H->dsd_mu = 8000.0f;              // Brandes et al. 2006, mu = 8000 m^-3 m^-1
    H->dsd_lambda = 2.3f * 1000.0f;
    
    RSfloat *n = (RSfloat *)malloc(count * sizeof(RSfloat));
    
    // Derive a concentration curve
    for (i = 0; i < count; i++) {
        d = ds[i];
        n[i] = H->dsd_mu * exp(-H->dsd_lambda * d);
        sum += n[i];
    }
    
    // Convert concentration to pdf
    for (i = 0; i < count; i++) {
        n[i] /= sum;
    }
    
    RS_set_dsd(H, n, ds, count, RSDropSizeDistributionMarshallPalmer);
    
    free(n);
}


#pragma mark -
#pragma mark Functions to set properties after RS_init()

void RS_set_range_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
    memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host range weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d\n",
               table.dx, table.x0, table.xm, table_size);
    }
		
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
		
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting range weight.", i);
            }
            gcl_free(H->worker[i].range_weight);
        }
        H->worker[i].range_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].range_weight == NULL) {
            fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
            return;
        }
    }

#else
    
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].range_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting range weight.", now(), i);
            }
            clReleaseMemObject(H->worker[i].range_weight);
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] creating range weight (cl_mem) & copying data from %p.\n", now(), i, table.data);
        }
        H->worker[i].range_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
            return;
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] created range weight @ %p.\n", now(), i, H->worker[i].range_weight);
        }
    }

#endif

    for (i = 0; i < H->num_workers; i++) {
        // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->worker[i].range_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }
    
    RS_table_free(table);

}


void RS_set_range_weight_to_triangle(RSHandle *H, float pulse_width_m) {
	float w[3] = {0.0f, 1.0f, 0.0f};
	RS_set_range_weight(H, w, -pulse_width_m, pulse_width_m, 3);
}


void RS_set_angular_weight(RSHandle *H, const float *weights, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
    RSTable table = RS_table_init(table_size);
    if (table.data == NULL) {
        return;
    }
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	table.dx = 1.0f / table_index_delta;
	table.x0 = -table_index_start * table.dx;
	table.xm = (float)table_size - 1.0f;
	memcpy(table.data, weights, table_size * sizeof(float));
    if (H->verb > 1) {
        rsprint("Host angular weight table received.  dx = %.4f   x0 = %.1f   xm = %.0f  n = %d",
               table.dx, table.x0, table.xm, table_size);
    }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting angular weight.", i);
            }
            gcl_free(H->worker[i].angular_weight);
        }
//        for (int k = 0; k < table_size; k++) {
//            printf("k=%d  w = %.3f  %.2f\n", k, table.data[k], 10 * log10f(table.data[k]));
//        }
        H->worker[i].angular_weight = gcl_malloc(table_size * sizeof(float), table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
        if (H->worker[i].angular_weight == NULL) {
            fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
            return;
        }
    }
		
#else
		
    cl_int ret;
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].angular_weight != NULL) {
            if (H->verb > 1) {
                rsprint("worker[%d] setting angular weight.\n", i);
            }
            clReleaseMemObject(H->worker[i].angular_weight);
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] creating angular weight (cl_mem) & copying data from %p.\n", now(), i, table.data);
        }
        H->worker[i].angular_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), table.data, &ret);
        if (ret != CL_SUCCESS) {
            fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
            return;
        }
        if (H->verb > 2) {
            printf("%s : RS : worker[%d] created angular weight.\n", now(), i);
        }
    }
		
#endif
    
    // Copy over to CL workers. A bit wasteful but the codes are easier to ready this way.
    for (i = 0; i < H->num_workers; i++) {
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionScale] = table.dx;
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionOrigin] = table.x0;
        H->worker[i].angular_weight_desc.s[RSTable1DDescriptionMaximum] = table.xm;
        H->worker[i].mem_size += (cl_uint)(table.xm + 1.0f) * sizeof(cl_float4);
    }

    RS_table_free(table);
}


void RS_set_angular_weight_to_double_cone(RSHandle *H, float beamwidth_rad) {
	float w[] = {1.0f, 0.0f, 0.8f, 0.0f};
	unsigned int n = sizeof(w) / sizeof(float);
	RS_set_angular_weight(H, w, 0.0f, 2.0f * beamwidth_rad, n);
}


void RS_set_angular_weight_to_standard(RSHandle *H, float beamwidth_rad) {
	const unsigned int n = 32;
	float a;
	float b = 1.27f * M_PI / beamwidth_rad;
	float c;
	float *w = (float *)malloc(n * sizeof(float));
	
    float delta = 1.0f / 360.0f * M_PI;
    
	for (int i = 0; i < n; i++) {
		a = (float)i * delta;
		c = b * sinf(a);
		if (i == 0) {
			w[i] = 1.0f;
		} else if (i == (n - 1)) {
			w[i] = 0.0f;
		} else {
			w[i] = 8.0f * jn(2, c) / (c * c);
			w[i] *= w[i];
		}
		//printf("angle=%.4f deg  w[%d] = %.4f dB\n", a / M_PI * 180.0f, i, 10.0f * log10f(w[i]));
	}
	
    RS_set_angular_weight(H, w, 0.0f, delta, n);

    free(w);
}


void RS_set_vel_data(RSHandle *H, const RSTable3D table) {
	
	int i;
		
    int t = H->vel_count;
    
	cl_image_format format = {CL_RGBA, CL_FLOAT};
	
#if defined (CL_VERSION_1_2)

	cl_image_desc desc;
	desc.image_type = CL_MEM_OBJECT_IMAGE3D;
	desc.image_width  = table.x_;
	desc.image_height = table.y_;
	desc.image_depth  = table.z_;
	desc.image_array_size = 0;
	desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
	desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
	desc.num_mip_levels = 0;
	desc.num_samples = 0;
	desc.buffer = NULL;
	
#endif
	
    
	for (i = 0; i < H->num_workers; i++) {
		if (H->worker[i].vel[t] != NULL) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

            gcl_release_image(H->worker[i].vel[t]);

#else
            
            clReleaseMemObject(H->worker[i].vel[t]);
            
#endif

        }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        H->worker[i].vel[t] = gcl_create_image(&format, desc.image_width, desc.image_height, desc.image_depth, H->worker[i].surf_vel[t]);

#else
        
        cl_int ret;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].vel[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, table.data, &ret);
        
#else
        
        H->worker[i].vel[t] = clCreateImage3D(H->worker[i].context, flags, &format, table.x_, table.y_, table.z_,
                                              table.x_ * sizeof(cl_float4), table.y_ * table.x_ * sizeof(cl_float4), table.data, &ret);
        
#endif
        
#endif
        
        if (H->worker[i].vel[t] == NULL) {
			fprintf(stderr, "%s : RS : worker[%d] encountered error creating wind table on CL device.\n", now(), i);
			return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created vel[%d] @ %p\n", now(), i, t, &H->worker[i].vel[t]);
        }

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_async(H->worker[i].que, ^{
			size_t origin[3] = {0, 0, 0};
			size_t region[3] = {table.x_, table.y_, table.z_};
			gcl_copy_ptr_to_image(H->worker[i].vel[t], table.data, origin, region);
			dispatch_semaphore_signal(H->worker[i].sem);
		});

#endif

    }
	
	for (i = 0; i < H->num_workers; i++) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
#endif

        // Copy over to CL worker
        float tmpf; memcpy(&tmpf, &table.spacing, sizeof(float));
        H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionFormat] = tmpf;                   // Make a copy in float so we are maintaining all 32-bits
        //printf("%s : RS : %d / %.9f\n", now(), table.spacing, H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionFormat]);
        if (table.spacing & RSTableSpacingStretchedX) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeX] = table.xs;      // "m" for stretched grid: m * log1p(n * pos.x) + o;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleX] = table.xo;   // "n" for stretched grid: m * log1p(n * pos.y) + o;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetX] = table.xm;          // "o" for stretched grid: m * log1p(n * pos.z) + o;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleX] = table.xs;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginX] = table.xo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumX] = table.xm;
        }
        if (table.spacing & RSTableSpacingStretchedY) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeY] = table.ys;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleY] = table.yo;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetY] = table.ym;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleY] = table.ys;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginY] = table.yo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumY] = table.ym;
        }
        if (table.spacing & RSTableSpacingStretchedZ) {
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionBaseChangeZ] = table.zs;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionPositionScaleZ] = table.zo;
            H->worker[i].vel_desc.s[RSTable3DStaggeredDescriptionOffsetZ] = table.zm;
        } else {
            H->worker[i].vel_desc.s[RSTable3DDescriptionScaleZ] = table.zs;
            H->worker[i].vel_desc.s[RSTable3DDescriptionOriginZ] = table.zo;
            H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumZ] = table.zm;
        }
        H->worker[i].vel_desc.s[RSTable3DDescriptionRefreshTime] = table.tr;

        H->worker[i].mem_size += (cl_uint)((table.xm + 1.0f) * (table.ym + 1.0f) * (table.zm + 1.0f)) * sizeof(cl_float4);
	}

    H->vel_count++;
}


void RS_set_vel_data_to_LES_table(RSHandle *H, const LESTable *leslie) {
	
	int i;
    float hmax, zmax;
	
	RSTable3D table = RS_table3d_init(leslie->nn);
    if (table.data == NULL) {
        printf("%s : RS : LES input data cannot be NULL.", now());
        return;
    }

    // For LES tables:
    //
    // dz(k) = a * r ^ 1.05
    //
    //  z(k) = a * ( 1 - r ^ k ) / ( 1 - r )
    //
    //     k = 1 / log(r) * log( 1 - ( 1 - r ) / a * z( k ) )
    //       = 1 / log(r) * log( 1 + ( r - 1 ) / a * z( k ) )
    //
    // For a = 2.7, r = 1.05, these values may be documented in the data files at some point
    //
    //     k = 20.495934314287851 * log1p ( 0.018518518518519 * z( k ) )

    table.x_ = leslie->nx;    table.xm = 0.5f * (float)(leslie->nx - 1);    table.xs = 1.0f / log(leslie->rx);    table.xo = (leslie->rx - 1.0f) / leslie->ax;
    table.y_ = leslie->ny;    table.ym = 0.5f * (float)(leslie->ny - 1);    table.ys = 1.0f / log(leslie->ry);    table.yo = (leslie->ry - 1.0f) / leslie->ay;
    table.z_ = leslie->nz;    table.zm = 0.0f;                              table.zs = 1.0f / log(leslie->rz);    table.zo = (leslie->rz - 1.0f) / leslie->az;

    hmax = leslie->ax * (1.0f - powf(leslie->rx, table.xm)) / (1.0f - leslie->rx);
    zmax = leslie->az * (1.0f - powf(leslie->rz, (float)(leslie->nz - 1))) / (1.0f - leslie->rz);
    
    if (H->verb > 0 && H->vel_count == 0) {
        printf("%s : RS : LES stretched x-grid using %.6f * log1p( %.6f * x )    Mid = %.2f m\n",
               now(), table.xs, table.xo, hmax);
        printf("%s : RS : LES stretched z-grid using %.6f * log1p( %.6f * z )    Max = %.2f m\n",
               now(), table.zs, table.zo, zmax);
    }
    
    if (H->verb > 1) {
        printf("%s : RS : GPU LES[%2d] @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
               now(),
               H->vel_count,
               -hmax, hmax,
               -hmax, hmax,
              0.0, zmax);
    }
    
    // Some other parameters
    table.tr = leslie->tr;
    table.spacing = RSTableSpacingStretchedX | RSTableSpacingStretchedY | RSTableSpacingStretchedZ;

	// Need to arrange LES values into float4, then upload to GPU's global memory
	for (i = 0; i < leslie->nn; i++) {
		table.data[i].x = leslie->data.u[i];
		table.data[i].y = leslie->data.v[i];
		table.data[i].z = leslie->data.w[i];
		table.data[i].w = 0.0f;
        if (!(isfinite(table.data[i].x) &&
              isfinite(table.data[i].y) &&
              isfinite(table.data[i].z))) {
            printf("%s : RS : Some LES entries are not finite  (i = %d, vel = %.2f, %.2f, %.2f).\n", now(), i, table.data[i].x, table.data[i].y, table.data[i].z);
        }
	}

    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->vel_desc = *leslie;
    memset(&H->vel_desc.data, 0, sizeof(LESValue));

    RS_set_vel_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_vel_data_to_uniform(RSHandle *H, cl_float4 velocity) {
    
    RSTable3D table = RS_table3d_init(1);
    
    RSVolume domain = RS_get_domain(H);
    
    if (H->verb > 1) {
        printf("%s : RS : Uniform @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
               now(),
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
    }
    
    // Set up the mapping coefficients:
    table.x_ = 1;    table.xm = 0.0f;    table.xs = 1.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
    table.y_ = 1;    table.ym = 0.0f;    table.ys = 1.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
    table.z_ = 1;    table.zm = 0.0f;    table.zs = 1.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
    
    table.tr = 1000.0f;

    table.data[0].x = velocity.x;
    table.data[0].y = velocity.y;
    table.data[0].z = velocity.z;
    table.data[0].w = 0.0f;
    
    RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube27(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(27);
	
    RSVolume domain = RS_get_domain(H);
    
	if (H->verb > 1) {
		printf("%s : RS : Cube27 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
	}
	
	// Set up the mapping coefficients: -table_start * table_xs
	table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
	table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
	table.z_ = 3;    table.zm = 2.0f;    table.zs = 3.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	//	printf(" %.2f x %.2f = %.2f\n", -domain.origin.x, H->physics_table.xs, -domain.origin.x / domain.size.x * 2.0f);
	//	printf("o = [%.2f, %.2f, %.2f]\n", table.xo, table.yo, table.zo);
	
	const float v = 10.0f;
	
	for (i = 0; i < 27; i++) {
		table.data[i].x = (float) (i % 3)      * v - v;
		table.data[i].y = (float)((i % 9) / 3) * v - v;
		table.data[i].z = (float) (i / 9)      * v - v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_vel_data(H, table);
	
    RS_table3d_free(table);
}


void RS_set_vel_data_to_cube125(RSHandle *H) {
	
	int i;
	
	RSTable3D table = RS_table3d_init(125);
	
    RSVolume domain = RS_get_domain(H);
    
	if (H->verb > 1) {
		printf("%s : RS : Cube125 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
               domain.origin.x, domain.origin.x + domain.size.x,
               domain.origin.y, domain.origin.y + domain.size.y,
               domain.origin.z, domain.origin.z + domain.size.z);
	}
	
	// Set up the mapping coefficients
	table.x_ = 5;    table.xm = 4.0f;    table.xs = 5.0f / domain.size.x;    table.xo = -domain.origin.x * table.xs;
	table.y_ = 5;    table.ym = 4.0f;    table.ys = 5.0f / domain.size.y;    table.yo = -domain.origin.y * table.ys;
	table.z_ = 5;    table.zm = 4.0f;    table.zs = 5.0f / domain.size.z;    table.zo = -domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	const float v = 0.5f;
	
	for (i = 0; i < 125; i++) {
		table.data[i].x = (float) (i %  5)      * v - 2.0f * v;
		table.data[i].y = (float)((i % 25) / 5) * v - 2.0f * v;
		table.data[i].z = (float) (i / 25)      * v - 2.0f * v;
		table.data[i].w = 0.0f;
	}
	
	RS_set_vel_data(H, table);
    
    RS_table3d_free(table);
	
}


void RS_clear_vel_data(RSHandle *H) {
    // Technically the video RAM hasn't been freed but we will assume there is enough room and this memory gets freed when a new table comes in
    for (int i = 0; i < H->num_workers; i++) {
        cl_uint nx = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumX] + 1;
        cl_uint ny = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumY] + 1;
        cl_uint nz = (cl_uint)H->worker[i].vel_desc.s[RSTable3DDescriptionMaximumZ] + 1;
        H->worker[i].mem_size -= nx * ny * nz * H->vel_count * sizeof(cl_float4);
    }
    H->vel_count = 0;
}


void RS_set_adm_data(RSHandle *H, const RSTable2D cd, const RSTable2D cm) {
    
    int i;
    
    const int t = H->adm_count;
    
    const size_t n = cd.x_ * cd.y_;
    if (cm.x_ * cm.y_ != n) {
        fprintf(stderr, "%s : RS : RS_set_adm_data() received inconsistent cd (%d x %d) & cm (%d x %d) dimensions", now(), cd.x_, cd.y_, cm.x_, cm.y_);
        return;
    }
    
    if (H->verb > 2) {
        printf("%s : RS : ADM[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]\n", now(), H->adm_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = cd.x_;
    desc.image_height = cd.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].adm_cd[t] != NULL && H->worker[i].adm_cm[t] != NULL) {
            
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
            
            gcl_release_image(H->worker[i].adm_cd[t]);
            gcl_release_image(H->worker[i].adm_cm[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].adm_cd[t]);
            clReleaseMemObject(H->worker[i].adm_cm[t]);
            
#endif
            
            H->worker[i].mem_size -= ((cl_uint)(H->worker[i].adm_desc[t].s8 + 1.0f) * (H->worker[i].adm_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  adm_cd & adm_cm always have the same desc
        
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        H->worker[i].adm_cd[t] = gcl_create_image(&format, cd.x_, cd.y_, 1, H->worker[i].surf_adm_cd[t]);
        H->worker[i].adm_cm[t] = gcl_create_image(&format, cm.x_, cm.y_, 1, H->worker[i].surf_adm_cm[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].adm_cd[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, cm.data, &retm);
        
#else
        
        H->worker[i].adm_cd[t] = clCreateImage2D(H->worker[i].context, flags, &format, cd.x_, cd.y_, cd.x_ * sizeof(cl_float4), cd.data, &retd);
        H->worker[i].adm_cm[t] = clCreateImage2D(H->worker[i].context, flags, &format, cm.x_, cm.y_, cm.x_ * sizeof(cl_float4), cm.data, &retm);
        
#endif
        
#endif
        if (H->worker[i].adm_cd[t] == NULL || H->worker[i].adm_cm[t] == NULL) {
            fprintf(stderr, "%s : RS : worker[%d] encountered error creating ADM tables on CL device(s).\n", now(), i);
            return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created adm_cd[%d] & adm_cd[%d] @ %p & %p\n", now(), i, t, t, &H->worker[i].adm_cd[t], &H->worker[i].adm_cm[t]);
        }
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {cd.x_, cd.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].adm_cd[t], cd.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].adm_cm[t], cm.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleX] = cd.xs;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleY] = cd.ys;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginX] = cd.xo;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginY] = cd.yo;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] = cd.xm;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] = cd.ym;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnX] = H->adm_desc[t].phys.inv_inln_x;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnY] = H->adm_desc[t].phys.inv_inln_y;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionRecipInLnZ] = H->adm_desc[t].phys.inv_inln_z;
        H->worker[i].adm_desc[t].s[RSTable3DDescriptionTachikawa] = H->adm_desc[t].phys.Ta;
        H->worker[i].mem_size += ((cl_uint)(cd.xm + 1.0f) * (cd.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->adm_count++;
}


void RS_set_adm_data_to_ADM_table(RSHandle *H, const ADMTable *adam) {
    
    int i;
    
    RSTable2D cd = RS_table2d_init(adam->nn);
    RSTable2D cm = RS_table2d_init(adam->nn);
    
    if (cd.data == NULL || cm.data == NULL) {
        printf("%s : RS : ADM input data cannot be NULL.", now());
        return;
    }

    // Set up the mapping coefficients
    // Assumptions: maps are always in beta in [-180deg, +180deg] and alpha in [0, +180deg]
    cd.x_ = adam->nb;    cd.xm = (float)(cd.x_ - 1);    cd.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cd.xo = -(-M_PI) * cd.xs + 0.5f;
    cd.y_ = adam->na;    cd.ym = (float)(cd.y_ - 1);    cd.ys = (float)(adam->na - 1) / M_PI;             cd.yo = 0.5f;
    
    cm.x_ = adam->nb;    cm.xm = (float)(cm.x_ - 1);    cm.xs = (float)(adam->nb - 1) / (2.0f * M_PI);    cm.xo = -(-M_PI) * cm.xs + 0.5f;
    cm.y_ = adam->na;    cm.ym = (float)(cm.y_ - 1);    cm.ys = (float)(adam->na - 1) / M_PI;             cm.yo = 0.5f;

    // Arrange ADM values into float4, getting ready for GPU's global memory
    for (i = 0; i < adam->nn; i++) {
        cd.data[i].x = adam->data.cdx[i];
        cd.data[i].y = adam->data.cdy[i];
        cd.data[i].z = adam->data.cdz[i];
        cd.data[i].w = 0.0f;
        cm.data[i].x = adam->data.cmx[i];
        cm.data[i].y = adam->data.cmy[i];
        cm.data[i].z = adam->data.cmz[i];
        cm.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->adm_desc[H->adm_count] = *adam;
    memset(&H->adm_desc[H->adm_count].data, 0, sizeof(ADMData));

    if (H->verb > 1) {
        const int t = H->adm_count;
        printf("%s : RS : GPU ADM[%d]   Ta = %.4f  inv_inln = [%.4f %.4f %.4f]   mass = %.4f kg\n",
               now(), t, H->adm_desc[t].phys.Ta, H->adm_desc[t].phys.inv_inln_x, H->adm_desc[t].phys.inv_inln_y, H->adm_desc[t].phys.inv_inln_z, H->adm_desc[t].phys.mass);
    }

    RS_set_adm_data(H, cd, cm);
    
    RS_table2d_free(cd);
    RS_table2d_free(cm);
}

void RS_set_adm_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table = RS_table2d_init(9);
    
    if (H->verb > 1) {
        printf("%s : RS : ADM to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]\n", now());
    }
    
    table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / (2.0f * M_PI);    table.xo = -(-M_PI) * table.xs;
    table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / M_PI;             table.yo = 0.0f;

    for (i = 0; i < 9; i++) {
        table.data[i].x = 1.0f;
        table.data[i].y = 1.0f;
        table.data[i].z = 1.0f;
        table.data[i].w = 0.0f;
    }
    
    RS_set_adm_data(H, table, table);
    
    RS_table2d_free(table);
}


void RS_clear_adm_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->adm_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].adm_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->worker[i].mem_size -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->adm_count = 0;
}


void RS_set_rcs_data(RSHandle *H, const RSTable2D real, const RSTable2D imag) {
    
    int i;
    
    const int t = H->rcs_count;

    const size_t n = real.x_ * real.y_;
    if (imag.x_ * imag.y_ != n) {
        fprintf(stderr, "%s : RS : RS_set_rcs_data() received inconsistent real (%d x %d) & imag (%d x %d) dimensions", now(), real.x_, real.y_, imag.x_, imag.y_);
        return;
    }

    if (H->verb > 1) {
        printf("%s : RS : GPU RCS[%d] @ X:[ -M_PI - +M_PI ]  Y:[ 0 - M_PI ]\n", now(), H->rcs_count);
    }
    
    // This is the part that we need to create two texture maps for each RSTable2D table
    cl_image_format format = {CL_RGBA, CL_FLOAT};
    
#if defined (CL_VERSION_1_2)
    
    cl_image_desc desc;
    desc.image_type = CL_MEM_OBJECT_IMAGE2D;
    desc.image_width  = real.x_;
    desc.image_height = real.y_;
    desc.image_depth  = 1;
    desc.image_array_size = 0;
    desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
    desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
    desc.num_mip_levels = 0;
    desc.num_samples = 0;
    desc.buffer = NULL;
    
#endif
    
    
    for (i = 0; i < H->num_workers; i++) {
        if (H->worker[i].rcs_real[t] != NULL && H->worker[i].rcs_imag[t] != NULL) {
            
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
            
            gcl_release_image(H->worker[i].rcs_real[t]);
            gcl_release_image(H->worker[i].rcs_imag[t]);
            
#else
            
            clReleaseMemObject(H->worker[i].rcs_real[t]);
            clReleaseMemObject(H->worker[i].rcs_imag[t]);
            
#endif
            
            H->worker[i].mem_size -= ((cl_uint)(H->worker[i].rcs_desc[t].s8 + 1.0f) * (H->worker[i].rcs_desc[t].s9 + 1.0f)) * 2 * sizeof(cl_float4);
        }
        //  rcs_real & rcs_imag always have the same desc
        
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        H->worker[i].rcs_real[t] = gcl_create_image(&format, real.x_, real.y_, 1, H->worker[i].surf_rcs_real[t]);
        H->worker[i].rcs_imag[t] = gcl_create_image(&format, imag.x_, imag.y_, 1, H->worker[i].surf_rcs_imag[t]);
        
#else
        
        cl_int retd, retm;
        cl_mem_flags flags = CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR;
        
#if defined (CL_VERSION_1_2)
        
        H->worker[i].rcs_real[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage(H->worker[i].context, flags, &format, &desc, imag.data, &retm);
        
#else
        
        H->worker[i].rcs_real[t] = clCreateImage2D(H->worker[i].context, flags, &format, real.x_, real.y_, real.x_ * sizeof(cl_float4), real.data, &retd);
        H->worker[i].rcs_imag[t] = clCreateImage2D(H->worker[i].context, flags, &format, imag.x_, imag.y_, imag.x_ * sizeof(cl_float4), imag.data, &retm);
        
#endif
        
#endif
        if (H->worker[i].rcs_real[t] == NULL || H->worker[i].rcs_imag[t] == NULL) {
            fprintf(stderr, "%s : RS : worker[%d] encountered error creating RCS tables on CL device(s).\n", now(), i);
            return;
        } else if (H->verb > 2) {
            printf("%s : RS : worker[%d] created rcs_real[%d] & rcs_imag[%d] @ %p & %p\n", now(), i, t, t, &H->worker[i].rcs_real[t], &H->worker[i].rcs_imag[t]);
        }
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_async(H->worker[i].que, ^{
            size_t origin[3] = {0, 0, 0};
            size_t region[3] = {real.x_, imag.y_, 1};
            gcl_copy_ptr_to_image(H->worker[i].rcs_real[t], real.data, origin, region);
            gcl_copy_ptr_to_image(H->worker[i].rcs_imag[t], imag.data, origin, region);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        
#endif
        
    }
    
    for (i = 0; i < H->num_workers; i++) {
        
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
        
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        
#endif
        
        // Copy over to CL worker
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleX] = real.xs;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleY] = real.ys;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionScaleZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginX] = real.xo;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginY] = real.yo;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionOriginZ] = 0.0f;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] = real.xm;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] = real.ym;
        H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumZ] = 0.0f;
        H->worker[i].mem_size += ((cl_uint)(real.xm + 1.0f) * (real.ym + 1.0f)) * 2 * sizeof(cl_float4);
    }
    H->rcs_count++;
}


void RS_set_rcs_data_to_RCS_table(RSHandle *H, const RCSTable *rosie) {
    int i;
    
    RSTable2D real = RS_table2d_init(rosie->nn);
    RSTable2D imag = RS_table2d_init(rosie->nn);
    
    if (real.data == NULL || imag.data == NULL) {
        printf("%s : RS : RCS input data cannot be NULL.", now());
        return;
    }
    // Set up the mapping coefficients
    // Assumptions: maps are always in alpha in [-180deg, +180deg] and beta in [0, +180deg]
    real.x_ = rosie->na;    real.xm = (float)(real.x_ - 1);    real.xs = (float)rosie->na / (2.0f * M_PI);    real.xo = -(-M_PI) * real.xs;
    real.y_ = rosie->nb;    real.ym = (float)(real.y_ - 1);    real.ys = (float)rosie->nb / M_PI;             real.yo = 0.0f;
    
    imag.x_ = rosie->na;    imag.xm = (float)(imag.x_ - 1);    imag.xs = (float)rosie->na / (2.0f * M_PI);    imag.xo = -(-M_PI) * real.xs;
    imag.y_ = rosie->nb;    imag.ym = (float)(imag.y_ - 1);    imag.ys = (float)rosie->nb / M_PI;             imag.yo = 0.0f;
    
    // Arrange RCS values into float4, getting ready for GPU's global memory
    for (i = 0; i < rosie->nn; i++) {
        real.data[i].x = rosie->data.hh_real[i];
        real.data[i].y = rosie->data.vv_real[i];
        real.data[i].z = rosie->data.hv_real[i];
        real.data[i].w = 0.0f;
        imag.data[i].x = rosie->data.hh_imag[i];
        imag.data[i].y = rosie->data.vv_imag[i];
        imag.data[i].z = rosie->data.hv_imag[i];
        imag.data[i].w = 0.0f;
    }
    
    // Cache a copy of the parameters but not the data, the data could be deallocated immediately after this function call.
    H->rcs_desc[H->rcs_count] = *rosie;
    memset(&H->rcs_desc[H->rcs_count].data, 0, sizeof(RCSData));

    RS_set_rcs_data(H, real, imag);
    
    RS_table2d_free(real);
    RS_table2d_free(imag);

}


void RS_set_rcs_data_to_unity(RSHandle *H) {
    
    int i;
    
    RSTable2D table_real = RS_table2d_init(9);
    RSTable2D table_imag = RS_table2d_init(9);
    
    if (H->verb > 1) {
        printf("%s : RS : RCS to unity @ X:[ -M_PI - M_PI ]  Y:[ 0 - M_PI ]\n", now());
    }
    
    table_real.x_ = 3;    table_real.xm = 2.0f;    table_real.xs = 3.0f / (2.0f * M_PI);    table_real.xo = -(-M_PI) * table_real.xs;
    table_real.y_ = 3;    table_real.ym = 2.0f;    table_real.ys = 3.0f / M_PI;             table_real.yo = 0.0f;

    table_imag.x_ = 3;    table_imag.xm = 2.0f;    table_imag.xs = 3.0f / (2.0f * M_PI);    table_imag.xo = -(-M_PI) * table_imag.xs;
    table_imag.y_ = 3;    table_imag.ym = 2.0f;    table_imag.ys = 3.0f / M_PI;             table_imag.yo = 0.0f;
    
    for (i =  0; i < 9; i++) {
        table_real.data[i].x = 1.0f;
        table_real.data[i].y = 1.0f;
        table_real.data[i].z = 1.0f;
        table_real.data[i].w = 0.0f;

        table_imag.data[i].x = 0.0f;
        table_imag.data[i].y = 0.0f;
        table_imag.data[i].z = 0.0f;
        table_imag.data[i].w = 0.0f;
    }
    
    RS_set_rcs_data(H, table_real, table_imag);
    
    RS_table2d_free(table_real);
    RS_table2d_free(table_imag);
}


void RS_clear_rcs_data(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {
        for (int t = 0; t < H->rcs_count; t++) {
            cl_uint nx = (cl_uint)H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumX] + 1;
            cl_uint ny = (cl_uint)H->worker[i].rcs_desc[t].s[RSTable3DDescriptionMaximumY] + 1;
            H->worker[i].mem_size -= nx * ny * 2 * sizeof(cl_float4);
        }
    }
    H->rcs_count = 0;
}


#pragma mark -
#pragma mark GUI Specific Functions

#if defined (GUI) || defined (_SHARE_OBJ_)

// Compute auxiliary attributes: range, angular weight, etc.
// Users should not need to call this directly. It's either RS_make_pulse() or RS_update_colors()
// The framework will check the status to avoid redundant compuations.
void RS_update_auxiliary_attributes(RSHandle *H) {
    
    int i;
    
    if (!(H->status & RSStatusDomainPopulated)) {
        fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
        return;
    }
    
#if defined(__APPLE__) &&  defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            scat_sig_aux_kernel(&H->worker[i].ndrange_scat_all,
                                (cl_float4 *)H->worker[i].scat_sig,
                                (cl_float4 *)H->worker[i].scat_aux,
                                (cl_float4 *)H->worker[i].scat_pos,
                                (cl_float4 *)H->worker[i].scat_rcs,
                                (cl_float *)H->worker[i].angular_weight,
                                H->worker[i].angular_weight_desc,
                                H->sim_desc);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE];
    memset(events, 0, sizeof(events));
    
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
        clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }

    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, events);
        clReleaseEvent(events[i]);
    }
    
    H->status &= ~RSStatusScattererSignalsNeedsUpdate;
    
#endif
    
}

void RS_update_colors(RSHandle *H) {

    int i;
    
#if defined(__APPLE__) &&  defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            if (H->status & RSStatusScattererSignalsNeedsUpdate) {
                // Compute the attributes
                scat_sig_aux_kernel(&H->worker[i].ndrange_scat_all,
                                    (cl_float4 *)H->worker[i].scat_sig,
                                    (cl_float4 *)H->worker[i].scat_aux,
                                    (cl_float4 *)H->worker[i].scat_pos,
                                    (cl_float4 *)H->worker[i].scat_rcs,
                                    (cl_float *)H->worker[i].angular_weight,
                                    H->worker[i].angular_weight_desc,
                                    H->sim_desc);
            }
            // Set individual color based on draw mode
            scat_clr_kernel(&H->worker[i].ndrange_scat[0],
                            (cl_float4 *)H->worker[i].scat_clr,
                            (cl_float4 *)H->worker[i].scat_pos,
                            (cl_float4 *)H->worker[i].scat_aux,
                            H->draw_mode);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    cl_event events[RS_MAX_GPU_DEVICE][2];
    memset(events, 0, sizeof(events));
    
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        if (H->status & RSStatusScattererSignalsNeedsUpdate) {
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][0]);

            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 1, &events[i][0], &events[i][1]);
        } else {
            clSetKernelArg(C->kern_scat_clr, RSScattererColorKernelArgumentDrawMode, sizeof(cl_uint4), &H->draw_mode);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_clr, 1, NULL, &C->num_scats, NULL, 0, NULL, &events[i][1]);
        }
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][1]);
        clReleaseEvent(events[i][0]);
        clReleaseEvent(events[i][1]);
    }
    
#endif
    
    H->status &= ~RSStatusScattererSignalsNeedsUpdate;
}

void RS_share_mem_with_vbo(RSHandle *H, const int n, unsigned int vbo[][n]) {
    if (H->verb) {
        if (H->num_workers == 1) {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2]);
        } else {
            printf("%s : RS : RS_share_mem_with_vbo()   [ %d %d %d ]   [ %d %d %d ]\n", now(),
                   vbo[0][0], vbo[0][1], vbo[0][2],
                   vbo[1][0], vbo[1][1], vbo[1][2]);
        }
    }
    for (int i = 0; i < H->num_workers; i++) {
        H->worker[i].vbo_scat_pos = vbo[i][0];
        H->worker[i].vbo_scat_clr = vbo[i][1];
        H->worker[i].vbo_scat_ori = vbo[i][2];
    }
    H->has_vbo_from_gl = 1;
}

#endif

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

void RS_derive_ndranges(RSHandle *H) {
    for (int i = 0; i < H->num_workers; i++) {

        RSWorker *C = &H->worker[i];
        
        C->ndrange_scat_all.work_dim = 1;
        C->ndrange_scat_all.global_work_offset[0] = 0;
        C->ndrange_scat_all.global_work_size[0] = C->num_scats;
        C->ndrange_scat_all.local_work_size[0] = 0;
        
        for (int k = 0; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->species_population[k] == 0) {
                continue;
            }
            C->ndrange_scat[k].work_dim = 1;
            C->ndrange_scat[k].global_work_offset[0] = C->species_origin[k];
            C->ndrange_scat[k].global_work_size[0] = C->species_population[k];
            C->ndrange_scat[k].local_work_size[0] = 0;
            if (C->verb > 2) {
                printf("%s : RS : work[%d] offset, size = %d, %d\n",
                       now(), (int)C->name, (int)C->ndrange_scat[k].global_work_offset[0], (int)C->ndrange_scat[k].global_work_size[0]);
            }
        }
        
        C->ndrange_pulse_pass_1.work_dim = 1;
        C->ndrange_pulse_pass_1.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_1.global_work_size[0] = C->make_pulse_params.global[0];
        C->ndrange_pulse_pass_1.local_work_size[0] = C->make_pulse_params.local[0];
        
        C->ndrange_pulse_pass_2.work_dim = 1;
        C->ndrange_pulse_pass_2.global_work_offset[0] = 0;
        C->ndrange_pulse_pass_2.global_work_size[0] = C->make_pulse_params.global[1];
        C->ndrange_pulse_pass_2.local_work_size[0] = C->make_pulse_params.local[1];
    }
}


#endif

#pragma mark -
#pragma mark Framework Functions

void RS_io_test(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			io_kernel(&H->worker[i].ndrange_scat[0],
                      (cl_float4 *)H->worker[i].scat_pos,
                      (cl_float4 *)H->worker[i].scat_aux);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
    
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
    
#else
    
	for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_io, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
	}
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
	
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }

#endif
	
}


void RS_dummy_test(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            dummy_kernel(&H->worker[i].ndrange_scat[0],
                         (cl_float4 *)H->worker[i].scat_pos);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
    }
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    //	cl_event events[RS_MAX_GPU_DEVICE];
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_dummy, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }
    
#endif

}


void RS_populate(RSHandle *H) {
	if (H->num_scats > RS_MAX_NUM_SCATS) {
		rsprint("Exceed the maximum allowed. (%ld > %d).\n", (unsigned long)H->num_scats, RS_MAX_NUM_SCATS);
	}
	
    if (H->verb) {
        rsprint("RS_populate()");
    }
    
    if (H->adm_count != H->rcs_count) {
        rsprint("ADM & RCS are not consistent. Unexpected behavior may happen.");
    }
    
    // Use some default tables if there isn't any set
    if (H->vel_count == 0) {
        RS_set_vel_data_to_cube27(H);
    }
    if (H->adm_count == 0) {
        RS_set_adm_data_to_unity(H);
    }
    if (H->rcs_count == 0) {
        RS_set_rcs_data_to_unity(H);
    }

    if (H->status & RSStatusDomainPopulated) {
        rsprint("Simulation was populated.");
    }

    //
	// CPU memory allocation
	//
	if (H->scat_pos != NULL) {
		RS_free_scat_memory(H);
	}

    H->status = RSStatusDomainNull;

    posix_memalign((void **)&H->scat_pos, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_vel, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_ori, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_tum, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_aux, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rcs, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_sig, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
    posix_memalign((void **)&H->scat_rnd, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_uint4));

	posix_memalign((void **)&H->pulse, RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
	
	if (H->scat_pos == NULL ||
		H->scat_vel == NULL ||
		H->scat_ori == NULL ||
        H->scat_tum == NULL ||
		H->scat_aux == NULL ||
        H->scat_rcs == NULL ||
		H->scat_sig == NULL ||
        H->scat_rnd == NULL ||
		H->pulse == NULL) {
		fprintf(stderr, "%s : RS : Error allocating memory space for scatterers.\n", now());
		return;
	}
	
	int i;
	char has_null = 0;
	for (i = 0; i < H->num_workers; i++) {
		posix_memalign((void **)&H->pulse_tmp[i], RS_ALIGN_SIZE, H->params.range_count * sizeof(cl_float4));
		has_null |= H->pulse_tmp[i] == NULL;
	}
	if (has_null) {
		fprintf(stderr, "%s : RS : Error allocating memory space for pulses.\n", now());
		return;
	}
	
    // Initialize the scatter body positions on CPU, will upload to the GPU later
    RS_init_scat_pos(H);

    //
	// GPU memory allocation
	//
	
	size_t offset = 0;
	
	// Divide the scatter bodies into (num_workers) chunks
	size_t sub_num_scats = H->num_scats / MAX(1, H->num_workers);
	
    for (i = 0; i < H->num_workers; i++) {
        H->offset[i] = offset;
        if (H->verb > 1) {
            printf("%s : RS : worker[%d] num_scats = %s   offset = %s\n", now(), i, commaint(sub_num_scats), commaint(offset));
        }
        RS_worker_malloc(H, i, sub_num_scats, offset);
        offset += sub_num_scats;
    }
	
    RS_update_debris_count(H);
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    CGLContextObj cobj = CGLGetCurrentContext();
    if (cobj == NULL) {
        fprintf(stderr, "No GL context yet.\n");
        return;
    }
    
    gcl_gl_set_sharegroup(CGLGetShareGroup(cobj));
    
    RS_derive_ndranges(H);

#endif

    // Upload the particle parameters to the GPU
    RS_upload(H);

    if (H->verb) {
        printf("%s : RS : VEL / ADM / RCS count = %d / %d / %d\n", now(), H->vel_count, H->adm_count, H->rcs_count);
        printf("%s : RS : CL domain synchronized.\n", now());
    }
    
    if (H->dsd_name != RSDropSizeDistributionUndefined) {
        RS_rcs_from_dsd(H);
        if (H->verb) {
            printf("%s : RS : Drop-size derived RCS computed.\n", now());
        }
    }
    
	H->status |= RSStatusDomainPopulated | RSStatusScattererSignalsNeedsUpdate;

	return;
}


void RS_download(RSHandle *H) {
	
	int i;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

//    printf("%p <-----------------------\n", H->scat_ori);
    
    for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_vel + H->offset[i], H->worker[i].scat_vel, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_aux + H->offset[i], H->worker[i].scat_aux, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_sig + H->offset[i], H->worker[i].scat_sig, H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
		});
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

    int k;

    cl_event events[H->num_workers][6];
    
    // Non-blocking read, wait for events later when they are queue up.
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, &events[i][0]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, &events[i][1]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, &events[i][2]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_aux, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, &events[i][3]);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_FALSE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, &events[i][4]);
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_FALSE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, &events[i][5]);
	}

    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(6, events[i]);
        for (k = 0; k < 6; k++) {
            clReleaseEvent(events[i][k]);
        }
    }

#endif

    RS_merge_pulse_tmp(H);
}


void RS_download_position_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL,NULL);
	}
	
#endif

}

void RS_download_orientation_only(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL,NULL);
    }
    
#endif
    
}

void RS_merge_pulse_tmp(RSHandle *H) {
	memcpy(H->pulse, H->pulse_tmp[0], H->params.range_count * sizeof(cl_float4));
	for (int i = 1; i < H->num_workers; i++) {
		for (int k = 0; k < H->params.range_count; k++) {
			H->pulse[k].s0 += H->pulse_tmp[i][k].s0;
			H->pulse[k].s1 += H->pulse_tmp[i][k].s1;
			H->pulse[k].s2 += H->pulse_tmp[i][k].s2;
			H->pulse[k].s3 += H->pulse_tmp[i][k].s3;
		}
	}
}

void RS_download_pulse_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	for (i = 0; i < H->num_workers; i++)
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	
#else
	
    // Blocking read since there is only one read
	for (i = 0; i < H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_TRUE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, NULL);
	}
	
#endif
    
	RS_merge_pulse_tmp(H);
    //printf("pulse %zu [ %.4e %.4e %.4e ... ]\n", H->sim_tic, H->pulse[0].s0, H->pulse[0].s1, H->pulse[0].s2);
}


void RS_upload(RSHandle *H) {
	
	int i;
	
	if (H->verb > 3) {
		for (i = 0; i < H->num_workers; i++) {
			printf("%s : RS : worker[%d].scat_pos @ %p\n", now(), i, H->worker[i].scat_pos);
			printf("%s : RS : worker[%d].scat_vel @ %p\n", now(), i, H->worker[i].scat_vel);
		}
		printf("%s : RS : scat_pos @ %p\n", now(), H->scat_pos);
		printf("%s : RS : scat_vel @ %p\n", now(), H->scat_vel);
	}
	
    if (H->num_scats == 0) {
        printf("%s : RS : Abort @ num_scats = 0 during RS_upload()\n", now());
        return;
    }
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->worker[i].scat_pos, H->scat_pos + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_vel, H->scat_vel + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_ori, H->scat_ori + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
            gcl_memcpy(H->worker[i].scat_tum, H->scat_tum + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_aux, H->scat_aux + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_rcs, H->scat_rcs + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_rnd, H->scat_rnd + H->offset[i], H->worker[i].num_scats * sizeof(cl_uint4));
            dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

    // Blocking write since there is no need to optimize this too much
    for (i = 0; i < H->num_workers; i++) {
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_tum, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_tum + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_aux, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_aux + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rcs, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
        clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rnd, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_uint4),  H->scat_rnd + H->offset[i], 0, NULL, NULL);
	}

#endif
	
}


// Signal strength as a function of drop size
void RS_rcs_from_dsd(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            scat_rcs_kernel(&H->worker[i].ndrange_scat[0],
                            (cl_float4 *)H->worker[i].scat_rcs,
                            (cl_float4 *)H->worker[i].scat_pos,
                            (cl_float4 *)H->worker[i].scat_aux);
            dispatch_semaphore_signal(H->worker[i].sem);
        });
        dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
    }
    
#else

    size_t local_item_size = 1;
    
    cl_event events[RS_MAX_GPU_DEVICE];
    
    for (i = 0; i < H->num_workers; i++) {
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_rcs, 1, &H->worker[i].species_origin[0], &H->worker[i].species_population[0], &local_item_size, 0, NULL, &events[i]);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i]);
        clReleaseEvent(events[i]);
    }
    
#endif

}


void RS_advance_time(RSHandle *H) {
	
	int i, k;
    int r, a;

    if (!(H->status & RSStatusDomainPopulated)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}

    const int v = H->vel_idx;

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(5.0f / H->params.prt);
        H->vel_idx = H->vel_idx == H->vel_count - 1 ? 0 : H->vel_idx + 1;
        if (H->verb > 2) {
            rsprint("Wind table advanced. vel_idx = %d", H->vel_idx);
        }
    }

    // These kernels are actually independent and, thus, can be parallelized.
    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            if (H->sim_concept & RSSimulationConceptDraggedBackground) {
                el_atts_kernel(&H->worker[i].ndrange_scat[0],
                               (cl_float4 *)H->worker[i].scat_pos,
                               (cl_float4 *)H->worker[i].scat_vel,
                               (cl_uint4 *)H->worker[i].scat_rnd,
                               (cl_image)H->worker[i].vel[v],
                               H->worker[i].vel_desc,
                               H->sim_desc);
            } else {
                bg_atts_kernel(&H->worker[i].ndrange_scat[0],
                               (cl_float4 *)H->worker[i].scat_pos,
                               (cl_float4 *)H->worker[i].scat_vel,
                               (cl_uint4 *)H->worker[i].scat_rnd,
                               (cl_image)H->worker[i].vel[v],
                               H->worker[i].vel_desc,
                               H->sim_desc);
            }
            dispatch_semaphore_signal(H->worker[i].sem);
		});

        r = 0;
        a = 0;
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                dispatch_async(H->worker[i].que, ^{
                    db_atts_kernel(&H->worker[i].ndrange_scat[k],
                                   (cl_float4 *)H->worker[i].scat_pos,
                                   (cl_float4 *)H->worker[i].scat_ori,
                                   (cl_float4 *)H->worker[i].scat_vel,
                                   (cl_float4 *)H->worker[i].scat_tum,
                                   (cl_float4 *)H->worker[i].scat_sig,
                                   (cl_uint4 *)H->worker[i].scat_rnd,
                                   (cl_image)H->worker[i].vel[v],
                                   H->worker[i].vel_desc,
                                   (cl_image)H->worker[i].adm_cd[a],
                                   (cl_image)H->worker[i].adm_cm[a],
                                   H->worker[i].adm_desc[a],
                                   (cl_image)H->worker[i].rcs_real[r],
                                   (cl_image)H->worker[i].rcs_imag[r],
                                   H->worker[i].rcs_desc[r],
                                   H->sim_desc);
                    dispatch_semaphore_signal(H->worker[i].sem);
                });
            }
            r = r == H->rcs_count - 1 ? 0 : r + 1;
            a = a == H->adm_count - 1 ? 0 : a + 1;
        }
	}
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
            if (H->worker[i].species_population[k]) {
                dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
            }
        }
    }

//    i = 0;
//    r = 0;
//    a = 0;
//    dispatch_async(H->worker[i].que, ^{
//        db_atts_kernel(&H->worker[i].ndrange_scat_all,
//                       (cl_float4 *)H->worker[i].scat_pos,
//                       (cl_float4 *)H->worker[i].scat_ori,
//                       (cl_float4 *)H->worker[i].scat_vel,
//                       (cl_float4 *)H->worker[i].scat_tum,
//                       (cl_float4 *)H->worker[i].scat_sig,
//                       (cl_uint4 *)H->worker[i].scat_rnd,
//                       (cl_image)H->worker[i].vel[v],
//                       H->worker[i].vel_desc,
//                       (cl_image)H->worker[i].adm_cd[a],
//                       (cl_image)H->worker[i].adm_cm[a],
//                       H->worker[i].adm_desc[a],
//                       (cl_image)H->worker[i].rcs_real[r],
//                       (cl_image)H->worker[i].rcs_imag[r],
//                       H->worker[i].rcs_desc[r],
//                       H->sim_desc);
//        dispatch_semaphore_signal(H->worker[i].sem);
//    });
//    dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);

#else

    cl_event events[RS_MAX_GPU_DEVICE][RS_MAX_DEBRIS_TYPES];
    memset(events, 0, sizeof(events));
	
	if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(1.0f / H->params.prt);
	}
    
	for (i = 0; i < H->num_workers; i++) {
        r = 0;
        a = 0;

        // Convenient pointer to reduce dereferencing
        RSWorker *C = &H->worker[i];

        clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->species_origin[0], &C->num_scats, NULL, 0, NULL, &events[i][0]);
        
//        // Background: Need to refresh some parameters at each time update
//        if (H->sim_concept & RSSimulationConceptDraggedBackground) {
//            clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
//            clSetKernelArg(C->kern_el_atts, RSEllipsoidAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
//            clEnqueueNDRangeKernel(C->que, C->kern_el_atts, 1, &C->species_origin[0], &C->species_population[0], NULL, 0, NULL, &events[i][0]);
//        } else {
//            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
//            clSetKernelArg(C->kern_bg_atts, RSBackgroundAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
//            clEnqueueNDRangeKernel(C->que, C->kern_bg_atts, 1, &C->species_origin[0], &C->species_population[0], NULL, 0, NULL, &events[i][0]);
//        }
//        
//        // Debris particles
//        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentBackgroundVelocity,    sizeof(cl_mem),     &C->vel[v]);
//        clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
//        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
//            if (C->species_population[k]) {
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDrag,              sizeof(cl_mem),     &C->adm_cd[a]);
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelMomentum,          sizeof(cl_mem),     &C->adm_cm[a]);
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentAirDragModelDescription,       sizeof(cl_float16), &C->adm_desc);
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionReal,         sizeof(cl_mem),     &C->rcs_real[r]);
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionImag,         sizeof(cl_mem),     &C->rcs_imag[r]);
//                clSetKernelArg(C->kern_db_atts, RSDebrisAttributeKernelArgumentRadarCrossSectionDescription,  sizeof(cl_float16), &C->rcs_desc[r]);
//                clEnqueueNDRangeKernel(C->que, C->kern_db_atts, 1, &C->species_origin[k], &C->species_population[k], NULL, 0, NULL, &events[i][k]);
//            }
//            r = r == H->rcs_count - 1 ? 0 : r + 1;
//            a = a == H->adm_count - 1 ? 0 : a + 1;
//        }
    }

    for (i = 0; i < H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
   
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][0]);
        clReleaseEvent(events[i][0]);
//        for (k = 1; k < RS_MAX_DEBRIS_TYPES; k++) {
//            if (H->worker[i].species_population[k]) {
//                clWaitForEvents(1, &events[i][k]);
//                clReleaseEvent(events[i][k]);
//            }
//        }
    }
	
#endif
	
    H->sim_time += H->params.prt;
    H->sim_desc.s[RSSimulationDescriptionSimTic] = ++H->sim_tic;
    H->status |= RSStatusScattererSignalsNeedsUpdate;
}


void RS_make_pulse(RSHandle *H) {
	
	int i;
	
	if (!(H->status & RSStatusDomainPopulated)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

    for (i = 0; i < H->num_workers; i++) {
        dispatch_async(H->worker[i].que, ^{
            if (H->status & RSStatusScattererSignalsNeedsUpdate) {
                //printf("RS_make_pulse: kern_scat_sig_aux\n");
                scat_sig_aux_kernel(&H->worker[i].ndrange_scat_all,
                                    (cl_float4 *)H->worker[i].scat_sig,
                                    (cl_float4 *)H->worker[i].scat_aux,
                                    (cl_float4 *)H->worker[i].scat_pos,
                                    (cl_float4 *)H->worker[i].scat_rcs,
                                    (cl_float *)H->worker[i].angular_weight,
                                    H->worker[i].angular_weight_desc,
                                    H->sim_desc);
            }
            make_pulse_pass_1_kernel(&H->worker[i].ndrange_pulse_pass_1,
                                     (cl_float4 *)H->worker[i].work,
                                     (cl_float4 *)H->worker[i].scat_sig,
                                     (cl_float4 *)H->worker[i].scat_aux,
                                     H->worker[i].make_pulse_params.local_mem_size[0],
                                     (cl_float *)H->worker[i].range_weight,
                                     H->worker[i].range_weight_desc,
                                     H->worker[i].make_pulse_params.range_start,
                                     H->worker[i].make_pulse_params.range_delta,
                                     H->worker[i].make_pulse_params.range_count,
                                     H->worker[i].make_pulse_params.group_counts[0],
                                     H->worker[i].make_pulse_params.entry_counts[0]);
            switch (H->worker[i].make_pulse_params.cl_pass_2_method) {
				case RS_CL_PASS_2_IN_LOCAL:
					make_pulse_pass_2_local_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				case RS_CL_PASS_2_IN_RANGE:
					make_pulse_pass_2_range_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				default:
					make_pulse_pass_2_group_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
			}
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i = 0; i < H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else

    cl_event events[H->num_workers][3];
    memset(events, 0, sizeof(events));

    // In this implementation, kern_make_pulse_pass_2 should point to kern_make_pulse_pass_2_group, kern_make_pulse_pass_2_local or kern_make_pulse_pass_2_range,
    // which had been selected based on the group size in RS_make_pulse_params()
    for (i = 0; i < H->num_workers; i++) {
        RSWorker *C = &H->worker[i];
        if (H->status & RSStatusScattererSignalsNeedsUpdate) {
            //printf("RS_make_pulse: kern_scat_sig_aux\n");
            clSetKernelArg(C->kern_scat_sig_aux, RSScattererAngularWeightKernalArgumentSimulationDescription, sizeof(cl_float16), &H->sim_desc);
            clEnqueueNDRangeKernel(C->que, C->kern_scat_sig_aux, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, &events[i][0]);
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 1, &events[i][0], &events[i][1]);
        } else {
            clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 0, NULL, &events[i][1]);
        }
        clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_2, 1, NULL, &C->make_pulse_params.global[1], &C->make_pulse_params.local[1], 1, &events[i][1], &events[i][2]);
        clFlush(C->que);
    }
    for (i = 0; i < H->num_workers; i++) {
        clWaitForEvents(1, &events[i][2]);
        clReleaseEvent(events[i][0]);
        clReleaseEvent(events[i][1]);
        clReleaseEvent(events[i][2]);
    }
	
#endif
	
    H->status &= ~RSStatusScattererSignalsNeedsUpdate;
}


#pragma mark -
#pragma mark Elements for table lookup

RSTable RS_table_init(size_t numel) {
    RSTable table = {0.0f, 1.0f, 1.0f, 0, NULL};
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(float))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table_free(RSTable T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


RSTable2D RS_table2d_init(size_t numel) {
    RSTable2D table;
    
    table.xs = 1.0f;      table.ys = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        fprintf(stderr, "%s : RS : Error allocating an RSTable2D->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table2d_free(RSTable2D T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable3D RS_table3d_init(size_t numel) {
	RSTable3D table;
	
    table.spacing = RSTableSpacingUniform;
    
	table.xs = 1.0f;      table.ys = 1.0f;      table.zs = 1.0f;
	table.xo = 0.0f;      table.yo = 0.0f;      table.zo = 0.0f;
	table.xm = 1.0f;      table.ym = 1.0f;      table.zm = 1.0f;
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable3D->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table3d_free(RSTable3D T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


#pragma mark -
#pragma mark Display

static void RS_show_scat_i(RSHandle *H, const size_t i) {
	printf(" %7lu - ( %9.2f, %9.2f, %9.2f, %4.2f )  %7.2f %7.2f %7.2f   %7.4f %7.4f %7.4f %7.4f\n", i,
		   H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, H->scat_pos[i].w,
		   H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w);
}


static void RS_show_rcs_i(RSHandle *H, const size_t i) {
    printf(" %7lu - ( %9.2f, %9.2f, %9.2f )  %7.4f %7.4f %7.4f %7.4f  [ %7.2f %7.2f %7.2f %7.2f ] %.2f\n", i,
           H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z,
           H->scat_ori[i].x, H->scat_ori[i].y, H->scat_ori[i].z, H->scat_ori[i].w,
           H->scat_sig[i].x, H->scat_sig[i].y, H->scat_sig[i].z, H->scat_sig[i].w,
           H->scat_aux[i].s0);
}


void RS_show_scat_pos(RSHandle *H) {
	size_t i, w;
    for (w = 0; w < H->num_workers; w++) {
        for (i = H->worker[w].species_origin[0];
             i < H->worker[w].species_origin[0] + H->worker[w].species_population[0];
             i += H->worker[w].species_population[0] / 9) {
            RS_show_scat_i(H, i);
        }
    }
	i = H->worker[w].species_origin[0] + H->worker[w].species_population[0] - 1;
	RS_show_scat_i(H, i);
}


void RS_show_scat_sig(RSHandle *H) {
    size_t i, w;
    printf("background:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].species_population[0]; i += H->worker[w].species_population[0] / 9) {
            RS_show_rcs_i(H, H->worker[w].species_global_offset + H->worker[w].species_origin[0] + i);
        }
    }
    if (H->species_population[1] == 0) {
        return;
    }
    // Show the debris
    //i = (int)H->species_population[0] / H->num_workers;
    printf("debris type #1:\n");
    for (w = 0; w < H->num_workers; w++) {
        for (i = 0; i < H->worker[w].species_population[1]; i++) {
            RS_show_rcs_i(H, H->worker[w].species_global_offset + H->worker[w].species_origin[1] + i);
        }
    }
}


void RS_show_pulse(RSHandle *H) {
	unsigned int i;
	printf(" %7zu - [", H->sim_tic);
	for (i = 0; i < MIN(4, H->params.range_count); i++) {
		if (i > 0) {
			printf(",");
		}
		printf(" %9.2f", H->pulse[i].s0);
	}
	if (i < H->params.range_count) {
		printf(",  . . . , %9.2f", H->pulse[H->params.range_count - 1].s0);
	}
	printf(" ] (%d)\n", H->params.range_count);
}

#pragma mark -

RSBox RS_suggest_scan_doamin(RSHandle *H, const int nbeams) {
    RSBox box;

    // Extremas of the domain
    float w = H->vel_desc.ax * (1.0f - powf(H->vel_desc.rx, 0.5f * (float)(H->vel_desc.nx - 3))) / (1.0f - H->vel_desc.rx);
    float h = H->vel_desc.az * (1.0f - powf(H->vel_desc.rz,        (float)(H->vel_desc.nz - 1))) / (1.0f - H->vel_desc.rz);
    
    // Maximum number of beams plus the padding on one side in azimuth
    float na = 0.5f * (float)nbeams + RS_DOMAIN_PAD + 0.5f;
    
    // Maximum number of beams in elevation
    float ne = 14.0f;
    
    // Maximum y of the emulation box: The range when the width is fully utilized; This is also rmax
    float rmax = w / sinf(na * H->params.antenna_bw_rad);
    
    // Minimum y of the emulation box: The range when the height is fully utilized
    float rmin = (rmax - 2.0f * w) / cosf(na * H->params.antenna_bw_rad) / cosf(ne * H->params.antenna_bw_rad);
    
    // Maximum number of range cells minus the padding on both sides minus one radar cell
    float nr = (rmax - rmin) / H->params.dr - 2.0f * RS_DOMAIN_PAD - 1.0f;
    
    box.origin.a = ceilf(-0.5f * (float)nbeams) * H->params.antenna_bw_rad * 180.0f / M_PI;
    box.size.a = nbeams * H->params.antenna_bw_deg;

    box.origin.r = rmax - (nr + 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;
    box.size.r = floorf(nr - 2.0f * RS_DOMAIN_PAD - 1.0f) * H->params.dr;

    box.origin.e = 0.0f;
    box.size.e = ne * H->params.antenna_bw_deg;

    if (H->verb) {
        printf("%s : RS : Suggest scan box based on [ 2w = %.1f m, h = %.1f m ] : nr = %.1f   na = %.1f   ne = %.1f\n"
               "%s : RS : Best fit with R:[ %5.2f ~ %5.2f ] km   E:[ %5.2f ~ %5.2f ] deg   A:[ %6.2f ~ %6.2f ] deg\n",
               now(), 2.0f * w, h, nr, na, ne,
               now(), 1.0e-3f * box.origin.r, 1.0e-3f * (box.origin.r + box.size.r), box.origin.e, box.origin.e + box.size.e, box.origin.a, box.origin.a + box.size.a);
    }

    return box;
}