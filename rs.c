//
//  rs.c
//  Radar Simulation Framework
//
//  Created by Boon Leng Cheong.
//

#include "rs.h"

// More functions
void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, char verb);
void RS_worker_free(RSWorker *C);
void RS_worker_malloc(RSHandle *H, const int worker_id, const size_t sub_num_scats);

void RS_init_scat_pos(RSHandle *H);


// The block declaration is automatically generated by XCode
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
#include "rs.cl.h"
#endif

#pragma mark -
#pragma mark Private Functions

void RS_worker_init(RSWorker *C, cl_device_id dev, cl_uint src_size, const char **src_ptr, char verb) {
	
	C->dev = dev;
	C->verb = verb;
	
	clGetDeviceInfo(C->dev, CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(cl_uint), &C->num_cus, NULL);
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	// A queue & semaphore for the CL work
	C->que = gcl_create_dispatch_queue(CL_DEVICE_TYPE_GPU, NULL);
	C->sem = dispatch_semaphore_create(0);
	
#else
	
	cl_int ret;
	
	// The OpenCL context
	C->context = clCreateContext(NULL, 1, &C->dev, &pfn_notify, NULL, &ret);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error creating OpenCL context.  ret = %d\n", now(), ret);
		exit(EXIT_FAILURE);
	}
	
	// Program
	C->prog = clCreateProgramWithSource(C->context, src_size, (const char **)src_ptr, NULL, &ret);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error creating OpenCL program.  ret = %d\n", now(), ret);
		clReleaseContext(C->context);
		return;
	}
	ret = clBuildProgram(C->prog, 1, &C->dev, "", NULL, NULL);
	//    ret = clBuildProgram(C->prog, 1, &C->dev, "", &pfn_prog_notify, NULL);
	if (ret != CL_SUCCESS) {
		char char_buf[RS_MAX_STR] = "";
		clGetProgramBuildInfo(C->prog, C->dev, CL_PROGRAM_BUILD_LOG, RS_MAX_STR, char_buf, NULL);
		fprintf(stderr, "%s : RS : CL Compilation failed:\n%s", now(), char_buf);
		clReleaseProgram(C->prog);
		clReleaseContext(C->context);
		return;
	}
	
#define CHECK_CL_CREATE_KERNEL                                                                          \
    if (ret != CL_SUCCESS) {                                                                            \
        fprintf(stderr, "%s : RS : Error creating OpenCL kernel scat_mov().  ret = %d\n", now(), ret);  \
        clReleaseProgram(C->prog);                                                                      \
        clReleaseContext(C->context);                                                                   \
        return;                                                                                         \
    }
	
	// Tie all kernels to the program
    C->kern_io = clCreateKernel(C->prog, "io", &ret);                                             CHECK_CL_CREATE_KERNEL
	C->kern_scat_mov = clCreateKernel(C->prog, "scat_mov", &ret);                                 CHECK_CL_CREATE_KERNEL
	C->kern_scat_chk = clCreateKernel(C->prog, "scat_chk", &ret);                                 CHECK_CL_CREATE_KERNEL
	C->kern_make_pulse_pass_1 = clCreateKernel(C->prog, "make_pulse_pass_1", &ret);               CHECK_CL_CREATE_KERNEL
	C->kern_make_pulse_pass_2_group = clCreateKernel(C->prog, "make_pulse_pass_2_group", &ret);   CHECK_CL_CREATE_KERNEL
	C->kern_make_pulse_pass_2_local = clCreateKernel(C->prog, "make_pulse_pass_2_range", &ret);   CHECK_CL_CREATE_KERNEL
	C->kern_make_pulse_pass_2_range = clCreateKernel(C->prog, "make_pulse_pass_2_local", &ret);   CHECK_CL_CREATE_KERNEL
	C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
	C->kern_scat_physics = clCreateKernel(C->prog, "scat_physics", &ret);                         CHECK_CL_CREATE_KERNEL
	
	if (C->verb > 3) {
		size_t pref_size;
		CL_CHECK(clGetKernelWorkGroupInfo(C->kern_scat_mov, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
		printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   scat_mov()\n", now(), pref_size);
		
		CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_1, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
		printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_1()\n", now(), pref_size);
		
		CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_group, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
		printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_group()\n", now(), pref_size);
		
		CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_local, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
		printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_local()\n", now(), pref_size);
		
		CL_CHECK(clGetKernelWorkGroupInfo(C->kern_make_pulse_pass_2_range, C->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, sizeof(pref_size), &pref_size, NULL));
		printf("%s : RS : KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE = %ld   make_pulse_pass_2_range()\n", now(), pref_size);
	}
	
	// A queue for the CL work of each device
	C->que = clCreateCommandQueue(C->context, C->dev, 0, &ret);
	
#endif
	
}


void RS_worker_free(RSWorker *C) {
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	dispatch_release(C->sem);
	dispatch_release(C->que);
	
#else
	
	clReleaseCommandQueue(C->que);
	
    clReleaseKernel(C->kern_io);
	clReleaseKernel(C->kern_scat_mov);
	clReleaseKernel(C->kern_scat_chk);
	clReleaseKernel(C->kern_make_pulse_pass_1);
	clReleaseKernel(C->kern_make_pulse_pass_2_group);
	clReleaseKernel(C->kern_make_pulse_pass_2_local);
	clReleaseKernel(C->kern_make_pulse_pass_2_range);
	clReleaseKernel(C->kern_scat_physics);
	
	clReleaseProgram(C->prog);
	
	clReleaseContext(C->context);
	
#endif
	
}


//void RS_worker_malloc(RSWorker *C, size_t num_scats, RSTable *range_weight_table, RSTable *angular_weight_table, RSTable3D *physics_table, RSParams *params) {
void RS_worker_malloc(RSHandle *H, const int worker_id, const size_t sub_num_scats) {
	
	RSWorker *C = &H->worker[worker_id];
	RSTable *range_weight_table   = &H->range_weight_table;
	RSTable *angular_weight_table = &H->angular_weight_table;
    RSTable2D *adm_table          = &H->adm_tables[0];
	RSTable3D *physics_table      = &H->physics_table;
	
	C->num_scats = sub_num_scats;
	
	C->make_pulse_params = RS_make_pulse_params((cl_uint)C->num_scats,
												RS_CL_GROUP_ITEMS,
												C->num_cus * 4,
												H->params.range_start,
												H->params.range_delta,
												H->params.range_count);
	
	C->range_weight_desc.s0 = range_weight_table->dx;
	C->range_weight_desc.s1 = range_weight_table->x0;
	C->range_weight_desc.s2 = range_weight_table->xm;
	C->range_weight_desc.s3 = 0.0f;
	
	C->angular_weight_desc.s0 = angular_weight_table->dx;
	C->angular_weight_desc.s1 = angular_weight_table->x0;
	C->angular_weight_desc.s2 = angular_weight_table->xm;
	C->angular_weight_desc.s3 = 0.0f;
    
    // Pretend we only have one table at the moment
    for (int i=0; i<1; i++) {
        C->adm_desc[i].s0 = adm_table->xs;
        C->adm_desc[i].s1 = adm_table->ys;
        C->adm_desc[i].s2 = 1.0f;
        C->adm_desc[i].s3 = 1.0f;
        C->adm_desc[i].s4 = adm_table->xo;
        C->adm_desc[i].s5 = adm_table->yo;
        C->adm_desc[i].s6 = 1.0f;
        C->adm_desc[i].s7 = 1.0f;
        C->adm_desc[i].s8 = adm_table->xm;
        C->adm_desc[i].s9 = adm_table->ym;
        C->adm_desc[i].sa = 1.0f;
        C->adm_desc[i].sb = 1.0f;
        C->adm_desc[i].sc = adm_table->xs;
        C->adm_desc[i].sd = adm_table->ys;
        C->adm_desc[i].se = 1.0f;
        C->adm_desc[i].sf = 1.0f;
    }

	C->physics_desc.s0 = physics_table->xs;
	C->physics_desc.s1 = physics_table->ys;
	C->physics_desc.s2 = physics_table->zs;
	C->physics_desc.s3 = 1.0f;
	C->physics_desc.s4 = physics_table->xo;
	C->physics_desc.s5 = physics_table->yo;
	C->physics_desc.s6 = physics_table->zo;
	C->physics_desc.s7 = 1.0f;
	C->physics_desc.s8 = physics_table->xm;
	C->physics_desc.s9 = physics_table->ym;
	C->physics_desc.sa = physics_table->zm;
	C->physics_desc.sb = 1.0f;
	C->physics_desc.sc = 0.0f;
	C->physics_desc.sd = 0.0f;
	C->physics_desc.se = 0.0f;
	C->physics_desc.sf = 1.0f;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	C->ndrange_scat.work_dim = 1;
	C->ndrange_scat.global_work_offset[0] = 0;
	C->ndrange_scat.global_work_size[0] = sub_num_scats;
	C->ndrange_scat.local_work_size[0] = 0;
	
	C->ndrange_pulse_pass_1.work_dim = 1;
	C->ndrange_pulse_pass_1.global_work_offset[0] = 0;
	C->ndrange_pulse_pass_1.global_work_size[0] = C->make_pulse_params.global[0];
	C->ndrange_pulse_pass_1.local_work_size[0] = C->make_pulse_params.local[0];
	
	C->ndrange_pulse_pass_2.work_dim = 1;
	C->ndrange_pulse_pass_2.global_work_offset[0] = 0;
	C->ndrange_pulse_pass_2.global_work_size[0] = C->make_pulse_params.global[1];
	C->ndrange_pulse_pass_2.local_work_size[0] = C->make_pulse_params.local[1];
	
	// printf("Creating cl_mem from vbo ... %d %d\n", C->vbo_scat_pos, C->vbo_scat_clr);
	C->scat_pos = gcl_gl_create_ptr_from_buffer(C->vbo_scat_pos);
	C->scat_clr = gcl_gl_create_ptr_from_buffer(C->vbo_scat_clr);
	C->scat_ori = gcl_gl_create_ptr_from_buffer(C->vbo_scat_ori);
	if (C->scat_pos == NULL || C->scat_clr == NULL || C->scat_ori == NULL) {
		fprintf(stderr, "%s : RS : Error in gcl_gl_create_ptr_from_buffer().\n", now());
		return;
	}
	
	C->scat_vel = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
	C->scat_att = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
	C->scat_sig = gcl_malloc(C->num_scats * sizeof(cl_float4), NULL, 0);
	C->work = gcl_malloc(RS_MAX_GATES * RS_CL_GROUP_ITEMS * sizeof(cl_float4), NULL, 0);
	C->pulse = gcl_malloc(RS_MAX_GATES * sizeof(cl_float4), NULL, 0);
	
	C->scat_rnd = gcl_malloc(C->num_scats * sizeof(cl_int4), NULL, 0);
	
	C->mem_size = (cl_uint)( (4 * C->num_scats + RS_MAX_GATES * RS_CL_GROUP_ITEMS + RS_MAX_GATES) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );
	
#else
	
	cl_int ret;
	
#define CHECK_CL_CREATE_BUFFER                                                             \
    if (ret != CL_SUCCESS) {                                                               \
        fprintf(stderr, "%s : RS : Error in clCreateBuffer().  ret = %d\n", now(), ret);   \
        return;                                                                            \
}
	
	C->scat_pos = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                   CHECK_CL_CREATE_BUFFER
	C->scat_vel = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                   CHECK_CL_CREATE_BUFFER
	C->scat_ori = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                   CHECK_CL_CREATE_BUFFER
	C->scat_att = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                   CHECK_CL_CREATE_BUFFER
	C->scat_sig = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_float4), NULL, &ret);                   CHECK_CL_CREATE_BUFFER
	C->work = clCreateBuffer(C->context, CL_MEM_READ_WRITE, RS_MAX_GATES * RS_CL_GROUP_ITEMS * sizeof(cl_float4), NULL, &ret);   CHECK_CL_CREATE_BUFFER
	C->pulse = clCreateBuffer(C->context, CL_MEM_READ_WRITE, RS_MAX_GATES * sizeof(cl_float4), NULL, &ret);                      CHECK_CL_CREATE_BUFFER
	
	C->scat_rnd = clCreateBuffer(C->context, CL_MEM_READ_WRITE, C->num_scats * sizeof(cl_int4), NULL, &ret);                     CHECK_CL_CREATE_BUFFER
	
	C->mem_size = (cl_uint)( (5 * C->num_scats + RS_MAX_GATES * RS_CL_GROUP_ITEMS + RS_MAX_GATES) * sizeof(cl_float4) + C->num_scats * sizeof(cl_int4) );
	
	//
	// Set up kernel's input / output arguments
	//
    ret = CL_SUCCESS;
    ret |= clSetKernelArg(C->kern_io, 0, sizeof(cl_mem), &C->scat_pos);
    ret |= clSetKernelArg(C->kern_io, 1, sizeof(cl_mem), &C->scat_att);
    if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel io().\n", now());
		exit(EXIT_FAILURE);
	}
	
	cl_float4 beam_pos = {{0.0f, 1.0f, 0.0f, 0.0f}};
	float prt = 0.0f;
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_scat_mov, 0, sizeof(cl_mem), &C->scat_pos);
	ret |= clSetKernelArg(C->kern_scat_mov, 1, sizeof(cl_mem), &C->scat_vel);
	ret |= clSetKernelArg(C->kern_scat_mov, 2, sizeof(cl_mem), &C->scat_ori);
	ret |= clSetKernelArg(C->kern_scat_mov, 3, sizeof(cl_mem), &C->scat_att);
	ret |= clSetKernelArg(C->kern_scat_mov, 4, sizeof(cl_mem), &C->angular_weight);
	ret |= clSetKernelArg(C->kern_scat_mov, 5, sizeof(cl_float4), &C->angular_weight_desc);
	ret |= clSetKernelArg(C->kern_scat_mov, 6, sizeof(cl_float4), &beam_pos);
	ret |= clSetKernelArg(C->kern_scat_mov, 7, sizeof(float), &prt);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel scat_mov().\n", now());
		exit(EXIT_FAILURE);
	}
	C->mem_size += (cl_uint)(angular_weight_table->xm + 1.0f) * sizeof(float);
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_scat_chk, 0, sizeof(cl_mem), &C->scat_pos);
	ret |= clSetKernelArg(C->kern_scat_chk, 1, sizeof(cl_mem), &C->scat_att);
	ret |= clSetKernelArg(C->kern_scat_chk, 2, sizeof(cl_mem), &C->scat_rnd);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel scat_chk().\n", now());
		exit(EXIT_FAILURE);
	}
	
	if (C->verb > 1) {
		printf("%s : RS : Pass 1   global = %5s   local =%3zu x %2d = %6s B   groups =%3d   N = %9s\n",
			   now(),
			   commaint(C->make_pulse_params.global[0]),
			   C->make_pulse_params.local[0],
			   C->make_pulse_params.range_count,
			   commaint(C->make_pulse_params.local_mem_size[0]),
			   C->make_pulse_params.group_counts[0],
			   commaint(C->make_pulse_params.entry_counts[0]));
	}
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 0, sizeof(cl_mem), &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 1, sizeof(cl_mem), &C->scat_sig);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 2, sizeof(cl_mem), &C->scat_att);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 3, C->make_pulse_params.local_mem_size[0], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 4, sizeof(cl_mem), &C->range_weight);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 5, sizeof(float), &range_weight_table->x0);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 6, sizeof(float), &range_weight_table->xm);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 7, sizeof(float), &range_weight_table->dx);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 8, sizeof(float), &C->make_pulse_params.range_start);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 9, sizeof(float), &C->make_pulse_params.range_delta);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 10, sizeof(unsigned int), &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 11, sizeof(unsigned int), &C->make_pulse_params.group_counts[0]);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_1, 12, sizeof(unsigned int), &C->make_pulse_params.entry_counts[0]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_1().\n", now());
		exit(EXIT_FAILURE);
	}
	C->mem_size += (cl_uint)(range_weight_table->xm + 1.0f) * sizeof(float);
	
	if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_local;
	} else if (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE) {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_range;
	} else {
		C->kern_make_pulse_pass_2 = C->kern_make_pulse_pass_2_group;
	}
	
	if (C->verb > 1) {
		printf("%s : RS : Pass 2   global =   %3zu   local =%3zu x %2lu = %6s B   groups = %d%s   N = %9s\n",
			   now(),
			   C->make_pulse_params.global[1],
			   C->make_pulse_params.local[1],
			   C->make_pulse_params.local_mem_size[1] / C->make_pulse_params.local[1] / sizeof(cl_float4),
			   commaint(C->make_pulse_params.local_mem_size[1]),
			   C->make_pulse_params.group_counts[1],
			   C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_RANGE ? "R" :
			   (C->make_pulse_params.cl_pass_2_method == RS_CL_PASS_2_IN_LOCAL ? "L" : "U"),
			   commaint(C->make_pulse_params.entry_counts[1]));
	}
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 0, sizeof(cl_mem), &C->pulse);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 1, sizeof(cl_mem), &C->work);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 2, C->make_pulse_params.local_mem_size[1], NULL);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 3, sizeof(unsigned int), &C->make_pulse_params.range_count);
	ret |= clSetKernelArg(C->kern_make_pulse_pass_2, 4, sizeof(unsigned int), &C->make_pulse_params.entry_counts[1]);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel make_pulse_pass_2().\n", now());
		exit(EXIT_FAILURE);
	}
	
	//	printf("C->physics        @ %p\n", C->physics);
	//	printf("C->range_weight   @ %p\n", C->range_weight);
	//	printf("C->angular_weight @ %p\n", C->angular_weight);
	//	printf("C->scat_pos       @ %p\n", C->scat_pos);
	//	printf("C->scat_vel       @ %p\n", C->scat_vel);
	
	ret = CL_SUCCESS;
	ret |= clSetKernelArg(C->kern_scat_physics, 0, sizeof(cl_mem), &C->scat_pos);
	ret |= clSetKernelArg(C->kern_scat_physics, 1, sizeof(cl_mem), &C->scat_vel);
	ret |= clSetKernelArg(C->kern_scat_physics, 2, sizeof(cl_mem), &C->physics);
	ret |= clSetKernelArg(C->kern_scat_physics, 3, sizeof(cl_float16), &C->physics_desc);
	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to set arguments for kernel kern_scat_physics().\n", now());
		exit(EXIT_FAILURE);
	}
	C->mem_size += (cl_uint)((physics_table->xm + 1.0f) * (physics_table->ym + 1.0f) * (physics_table->zm + 1.0f)) * sizeof(cl_float4);
	
	if (C->verb) {
		printf("%s : RS : worker[%d] memory access = %s B\n", now(), C->name, commaint(C->mem_size));
	}
	
#endif
	
}

#pragma mark -
#pragma mark Convenient Functions

char *commaint(long long num) {
	static int i = 7;
	static char buf[8][64];
	
	// Might need a semaphore to protect the following line
	i = i == 7 ? 0 : i + 1;
	
	int b = i;
	snprintf(buf[b], 48, "%lld", num);
	if (num >= 1000) {
		int c = (int)(strlen(buf[b]) - 1) / 3; // Number of commans
		int p = (int)(strlen(buf[b])) + c;     // End position
		int d = 1;                          // Count of digits
		buf[b][p] = '\0';
		while (p > 0) {
			p--;
			buf[b][p] = buf[b][p - c];
			if (d > 3) {
				d = 0;
				buf[b][p] = ',';
				c--;
			}
			d++;
		}
	}
	return buf[b];
}


// Here is a nice reference: http://www.cplusplus.com/ref/ctime/time.html
char *now() {
	static char timestr[64];
	time_t utc;
	time(&utc);
	strftime(timestr, 63, "%H:%M:%S", localtime(&utc));
	return timestr;
}


void rsprint(const char *format, ...) {
	
	char str[RS_MAX_STR] = "";
	sprintf(str, "%s : RS : ", now());
	size_t len = strlen(str);
	va_list args;
	
	va_start(args, format);
	vsnprintf(str + len, RS_MAX_STR - len, format, args);
	len = strlen(str);
	va_end(args);
	
	len = MIN(len, RS_MAX_STR - 2);
	if (str[len-1] != '\n') {
		str[len] = '\n';
		str[len+1] = '\0';
	}
	printf("%s", str);
}


void pfn_prog_notify(cl_program program, void *user_data) {
	fprintf(stderr, "%s : RS : Program %p returned %p (via pfn_prog_notify)\n", now(), program, user_data);
}


void pfn_notify(const char *errinfo, const void *private_info, size_t cb, void *user_data) {
	fprintf(stderr, "%s : RS : %s (via pfn_notify)\n", now(), errinfo);
}


void get_device_info(cl_uint *num_devices, cl_device_id *devices, cl_uint *num_cus, cl_int detail_level) {
	
	int i = 0, j = 0;
	cl_uint num_platforms = 0;
	cl_uint platform_num_devices = 0;
	
	*num_devices = 0;
	
	cl_platform_id platforms[RS_MAX_GPU_PLATFORM];
	
	char buf_char[RS_MAX_STR];
	cl_uint buf_uint;
	cl_ulong buf_ulong;
	
	CL_CHECK(clGetPlatformIDs(RS_MAX_GPU_PLATFORM, platforms, &num_platforms));
	
	if (detail_level)
		printf("* Number of OpenCL platforms: %d\n", num_platforms);
	
	for (; i<num_platforms; i++) {
		
		CL_CHECK(clGetDeviceIDs(platforms[i], CL_DEVICE_TYPE_GPU, RS_MAX_GPU_DEVICE - *num_devices, &devices[*num_devices], &platform_num_devices));
		
		*num_devices += platform_num_devices;
		if (*num_devices >= RS_MAX_GPU_DEVICE) {
			fprintf(stderr, "%s : RS : Sweet. A lot of devices found. Upgrade! Upgrade!\n", now());
			*num_devices = RS_MAX_GPU_DEVICE;
			return;
		}
		
		if (detail_level) {
			printf("  > PLATFORM %d:\n", i);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_NAME, RS_MAX_STR, buf_char, NULL));
			printf("    * NAME = %s\n", buf_char);
			if (detail_level > 1) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VENDOR, RS_MAX_STR, buf_char, NULL));
				printf("    * VENDOR = %s\n", buf_char);
			}
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_PROFILE, RS_MAX_STR, buf_char, NULL));
			printf("    * PROFILE = %s\n", buf_char);
			CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_VERSION, RS_MAX_STR, buf_char, NULL));
			printf("    * VERSION = %s\n", buf_char);
			if (detail_level > 2) {
				CL_CHECK(clGetPlatformInfo(platforms[i], CL_PLATFORM_EXTENSIONS, RS_MAX_STR, buf_char, NULL));
				if (strlen(buf_char)) {
					char *b = buf_char;
					while (1) {
						char *e = strchr(b, ' ');
						if (e) {
							*e = '\0';
						}
						if (b == buf_char) {
							printf("    * EXTENSIONS = %s\n", b);
						} else {
							printf("                   %s\n", b);
						}
						if (e) {
							b = e + 1;
						} else {
							break;
						}
					}
				}
			}
			printf("    * Number of OpenCL devices = %d\n", *num_devices);
			
#define FMT "%-35s"
#define FMT2 "%-14s"
			
			for (j=0; j<platform_num_devices; j++) {
				printf("      > DEVICE %d:\n", j);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_NAME, RS_MAX_STR, buf_char, NULL));
				printf("        - " FMT " = %s\n", "CL_DEVICE_NAME", buf_char);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VENDOR, RS_MAX_STR, buf_char, NULL));
				printf("        - " FMT " = %s\n", "CL_DEVICE_VENDOR", buf_char);
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
				printf("        - " FMT " = %u\n", "CL_DEVICE_MAX_COMPUTE_UNITS", (unsigned int)num_cus[j]);
				if (detail_level > 1) {
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DEVICE_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DRIVER_VERSION, RS_MAX_STR, buf_char, NULL));
					printf("        - " FMT " = %s\n", "CL_DRIVER_VERSION", buf_char);
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CLOCK_FREQUENCY, sizeof(buf_uint), &buf_uint, NULL));
					printf("        - " FMT " = %s MHz\n", "CL_DEVICE_MAX_CLOCK_FREQUENCY", commaint(buf_uint));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_GLOBAL_MEM_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_GLOBAL_MEM_SIZE", commaint(buf_ulong));
					CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_MEM_ALLOC_SIZE, sizeof(buf_ulong), &buf_ulong, NULL));
					printf("        - " FMT " = %s B\n", "CL_DEVICE_MAX_MEM_ALLOC_SIZE", commaint(buf_ulong));
					if (detail_level > 2) {
						size_t work_sizes[3];
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_ITEM_SIZES, sizeof(work_sizes), &work_sizes, NULL);
						printf("        - " FMT " = %zu / %zu / %zu\n", "CL_DEVICE_MAX_WORK_ITEM_SIZES", work_sizes[0], work_sizes[1], work_sizes[2]);
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_WORK_GROUP_SIZE, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT " = %zu\n", "CL_DEVICE_MAX_WORK_GROUP_SIZE", work_sizes[0]);
						clGetDeviceInfo(devices[j], CL_DEVICE_LOCAL_MEM_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n", "CL_DEVICE_LOCAL_MEM_SIZE", commaint(buf_ulong));
						clGetDeviceInfo(devices[j], CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, sizeof(cl_ulong), &buf_ulong, NULL);
						printf("        - " FMT " = %s B\n\n", "CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE", commaint(buf_ulong));
						
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("        - " FMT "   " FMT2 " %7s\n", "CL_DEVICE_IMAGE <dim>", "2D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE2D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "2D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_WIDTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_WIDTH", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_HEIGHT, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n", "", "3D_MAX_HEIGHT", commaint(work_sizes[0]));
						clGetDeviceInfo(devices[j], CL_DEVICE_IMAGE3D_MAX_DEPTH, sizeof(size_t), work_sizes, NULL);
						printf("          " FMT "   " FMT2 " %7s\n\n", "", "3D_MAX_DEPTH", commaint(work_sizes[0]));
					}
				}
			} // for (; j<platform_num_devices; j++)
		} else {
			for (; j<platform_num_devices; j++)
				CL_CHECK(clGetDeviceInfo(devices[j], CL_DEVICE_MAX_COMPUTE_UNITS, sizeof(buf_uint), &num_cus[j], NULL));
		}
	} // for (; i<num_platforms; i++)
}


cl_uint read_kernel_source_from_files(char *src_ptr[], ...) {
	
	static char char_buf[RS_MAX_KERNEL_SRC] = "";
	
	cl_uint count = 0, len = 0;
	
	va_list files;
	
	va_start(files, src_ptr);
	char *filename = va_arg(files, char *);
	while (filename != NULL && strlen(filename) > 0) {
#ifdef DEBUG_KERNEL_READ
		printf("%s : RS : src '%s' (%d)\n", now(), filename, (int)strlen(filename));
#endif
		// Read in the kernel source
		FILE *fid = fopen(filename, "r");
		if (fid == NULL) {
			fprintf(stderr, "%s : RS : Error opening kernel source %s.\n", now(), filename);
			break;
		}
		while (!feof(fid) && strlen(char_buf) < RS_MAX_KERNEL_SRC && count < RS_MAX_KERNEL_LINES) {
			src_ptr[count] = fgets(char_buf + len, RS_MAX_KERNEL_SRC - len, fid);
			if (src_ptr[count] != NULL) {
				len += strlen(src_ptr[count]) + 1;
				count++;
			}
		}
		fclose(fid);
		
		filename = va_arg(files, char *);
	}
	va_end(files);
	
	if (len >= RS_MAX_KERNEL_SRC * 8 / 10) {
		printf("%s : RS : \e[31mWARNING. Kernel source size = %s / %s (%.2f > 80%%)\e[0m\n",
			   now(), commaint(len), commaint(RS_MAX_KERNEL_SRC), (float)len / RS_MAX_KERNEL_SRC * 100.0f);
	}
	
	if (len >= RS_MAX_KERNEL_SRC || count >= RS_MAX_KERNEL_LINES) {
		fprintf(stderr, "Kernel source exceeds buffer size constraints.\n");
		return 0;
	}
	
#ifdef DEBUG_KERNEL_READ
	printf("%d lines\n", count);
	for (int i=0; i<count; i++) {
		printf("%d:%s", i, src_ptr[i]);
	}
#endif
	
	return count;
}


ReductionParams *make_reduction_params(cl_uint count, cl_uint user_max_groups, cl_uint user_max_work_items) {
	
	ReductionParams *params = (ReductionParams *)malloc(sizeof(ReductionParams));
	
	if (params == NULL) {
		fprintf(stderr, "%s : RS : Error creating ReductionParams.\n", now());
		return NULL;
	}
	
	// Copy these for housekeeping
	params->count = count;
	params->user_max_groups = user_max_groups;
	params->user_max_work_items = user_max_work_items;
	
	// Work items is only count / 2 for small counts
	int work_items = count > 2 * user_max_work_items ? user_max_work_items : count / 2;
	
	// Number of group of item-pairs
	int groups = count / (work_items * 2);
	if (groups > user_max_groups) {
		groups = user_max_groups;
	}
	
	cl_uint levels = 1;
	cl_uint numels = groups;
	
	// First pass to figure out how many levels
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		numels = numels / (work_items * 2);
		levels++;
	}
	
	params->pass_counts = levels;
	params->entry_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->group_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	params->work_item_counts = (cl_uint *)malloc(levels * sizeof(cl_uint));
	
	params->entry_counts[0] = count;
	params->group_counts[0] = groups;
	params->work_item_counts[0] = work_items;
	
	int level = 1;
	
	numels = groups;
	while (numels > 1) {
		int work_items = (numels > user_max_work_items * 2) ? user_max_work_items : numels / 2;
		int groups = numels / (work_items * 2);
		if (groups > user_max_groups) {
			groups = user_max_groups;
		}
		
		params->entry_counts[level] = numels;
		params->group_counts[level] = groups;
		params->work_item_counts[level] = work_items;
		
		numels = numels / (work_items * 2);
		level++;
	}
	
	return params;
}


void free_reduction_params(ReductionParams *params) {
	free(params->entry_counts);
	free(params->group_counts);
	free(params->work_item_counts);
	free(params);
}


float read_table(const float *table, const float index_last, const float index) {
	float floor_index = floorf(index);
	float alpha = index - floor_index;
	if (index <= 0.0f) {
		//		printf("%.2f / %.2f --> i = %u  X0\n", index, index_last, 0);
		return table[0];
	} else if (floor_index >= index_last) {
		//		printf("%.2f / %.2f --> i = %u  XM\n", index, index_last, (unsigned int)index_last);
		return table[(unsigned int)index_last];
	}
	unsigned int i = (unsigned int)floor_index;
	//	printf("%.2f / %.2f --> i = %d, %d / %.2f, %.2f  alpha = %.2f  v = %.3f\n", index, index_last, i, i+1,
	//		   table[i], table[i + 1],
	//		   alpha,
	//		   table[i] + alpha * (table[i + 1] - table[i]);
	return table[i] + alpha * (table[i + 1] - table[i]);
}


#pragma mark -
#pragma mark RS Initialization and Deallocation


RSHandle *RS_init_with_path(const char *bundle_path, RSMethod method, const char verb) {
	
	RSHandle *H;
	
	// Allocate
	if (posix_memalign((void **)((uintptr_t)&H), RS_ALIGN_SIZE, sizeof(RSHandle))) {
		fprintf(stderr, "%s : RS : Error initializing RSHandle.\n", now());
		return NULL;
	}
	memset(H, 0, sizeof(RSHandle));
	
	// Default non-zero parameters
	H->status = RS_STATUS_DOMAIN_NULL;
	H->params.c = 3.0e8f;
	H->params.body_per_cell = 50.0f;
	H->params.domain_pad_factor = RS_DOMAIN_PAD;
	H->params.prt = 0.0f;
	H->num_workers = 1;
	H->method = method;
	
	for (int i=0; i<RS_MAX_GPU_DEVICE; i++) {
		H->worker[i].name = i;
	}
	
	// Set up some basic parameters to default values, H->verb is still 0 so no API message output
	RS_set_antenna_params(H, 1.0f, 50.0f);
	
	RS_set_tx_params(H, 1.0e-6f, 50.0e3f);
	
	RS_set_beam_pos(H, 5.0f, 1.0f);
	
	// Now, we are ready to set the verbose flag
	H->verb = verb;
	
	if (H->method == RS_METHOD_GPU) {
		if (verb) {
			rsprint("Getting CL devices ...");
		}
		
		// Get and show some device info
		get_device_info(&H->num_devs, H->devs, H->num_cus, H->verb);
		if (H->num_devs == 0 || H->num_cus[0] == 0) {
			fprintf(stderr, "%s : RS : Error. No OpenCL devices found.\n", now());
			H->method = RS_METHOD_CPU;
		}
	} else {
		// Run this to get the num_cus to the same values.
		get_device_info(&H->num_devs, H->devs, H->num_cus, 0);
		if (H->num_cus[0] == 0) {
			H->num_cus[0] = 16;
		}
	}
	
	if (H->method == RS_METHOD_GPU) {
		
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
		
		H->num_workers = 1;
		
		CGLContextObj cobj = CGLGetCurrentContext();
		if (cobj == NULL) {
			fprintf(stderr, "No GL context yet.\n");
			return NULL;
		}
		gcl_gl_set_sharegroup(CGLGetShareGroup(cobj));
		
		for (int i=0; i<H->num_workers; i++) {
			if (H->verb > 2) {
				printf("%s : RS : Initializing worker %d using %p\n", now(), i, H->devs[i]);
			}
			RS_worker_init(&H->worker[i], H->devs[i], 0, NULL, H->verb);
		}
		
#else
		
		cl_uint count;
		char *src_ptr[RS_MAX_KERNEL_LINES];
		
		// Kernel source
		if (!strcmp(bundle_path, ".")) {
			count = read_kernel_source_from_files(src_ptr, "rs.cl", NULL);
		} else {
			//char types_h_path[RS_MAX_STR];
			//snprintf(types_h_path, RS_MAX_STR, "%s/rs_types.h", bundle_path);
			char kern_src_path[RS_MAX_STR];
			snprintf(kern_src_path, RS_MAX_STR, "%s/rs.cl", bundle_path);
			//count = read_kernel_source_from_files(src_ptr, types_h_path, kern_src_path, NULL);
			count = read_kernel_source_from_files(src_ptr, kern_src_path, NULL);
		}
		if (count == 0) {
			return NULL;
		}
		
		H->num_workers = H->num_devs;
		//H->num_workers = 1;
		
		for (int i=0; i<H->num_workers; i++) {
			if (H->verb > 2) {
				printf("%s : RS : Initializing worker %d using %p\n", now(), i, H->devs[i]);
			}
			RS_worker_init(&H->worker[i], H->devs[i], count, (const char **)src_ptr, H->verb);
		}
		
#endif
		
	}
	
	// More parameters that need the CL context initialized
	char user_verb = H->verb;
	
	H->verb = 0;
	
	RS_set_scan_box(H,
					15.0e3f, 20.0e3f, 250.0f,                   // Range
					-12.0f, 12.0f, 1.0f,                        // Azimuth
					0.0f, 8.0f, 1.0f);                          // Elevation
	
	RS_set_range_weight_to_triangle(H, 250.0f);
	
	RS_set_angular_weight_to_standard(H, 2.0f / 180.0f * M_PI);
	//RS_set_angular_weight_to_double_cone(H, 2.0f / 180.0f * M_PI);

	RS_set_physics_data_to_cube27(H);
	
	H->verb = user_verb;
	
	return H;
}


RSHandle *RS_init() {
	return RS_init_with_path(".", RS_METHOD_GPU, 0);
}


RSHandle *RS_init_verbose(const char verb) {
	return RS_init_with_path(".", RS_METHOD_GPU, verb);
}


RSHandle *RS_init_for_cpu_verbose(const char verb) {
	return RS_init_with_path(".", RS_METHOD_CPU, verb);
}


void RS_free_scat_memory(RSHandle *H) {
	int i;
	
	if (H->verb > 2) {
		printf("%s : RS : Freeing GPU memories ...\n", now());
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		if (H->worker[i].vbo_scat_pos == 0) {
			fprintf(stderr, "%s : RS : Unexpected error. VBO was not shared.\n", now());
			return;
		}
		gcl_free(H->worker[i].scat_pos);
		gcl_free(H->worker[i].scat_clr);  // Only the GUI version has this
		gcl_free(H->worker[i].scat_vel);
		gcl_free(H->worker[i].scat_ori);
		gcl_free(H->worker[i].scat_att);
		gcl_free(H->worker[i].scat_sig);
		gcl_free(H->worker[i].work);
		gcl_free(H->worker[i].pulse);
		gcl_free(H->worker[i].scat_rnd);
	}
	
#else
	
	for (i=0; i<H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].scat_pos);
		clReleaseMemObject(H->worker[i].scat_vel);
		clReleaseMemObject(H->worker[i].scat_ori);
		clReleaseMemObject(H->worker[i].scat_att);
		clReleaseMemObject(H->worker[i].scat_sig);
		clReleaseMemObject(H->worker[i].work);
		clReleaseMemObject(H->worker[i].pulse);
		clReleaseMemObject(H->worker[i].scat_rnd);
	}
	
#endif
	
	if (H->verb > 2) {
		printf("%s : RS : Freeing CPU memories ...\n", now());
	}
	
	free(H->scat_pos);
	free(H->scat_vel);
	free(H->scat_ori);
	free(H->scat_att);
	free(H->scat_sig);
	
	free(H->work);
	free(H->pulse);
	
	for (i=0; i<H->num_workers; i++) {
		free(H->pulse_tmp[i]);
	}
}


void RS_free(RSHandle *H) {
	
	char v = H->verb;
	
	for (int i=0; i<H->num_workers; i++) {
		RS_worker_free(&H->worker[i]);
	}
	
	RS_free_scat_memory(H);
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (int i=0; i<H->num_workers; i++) {
		gcl_free(H->worker[i].range_weight);
		gcl_free(H->worker[i].angular_weight);
		gcl_release_image(H->worker[i].physics);
	}
	
#else
	
	for (int i=0; i<H->num_workers; i++) {
		clReleaseMemObject(H->worker[i].range_weight);
		clReleaseMemObject(H->worker[i].angular_weight);
		clReleaseMemObject(H->worker[i].physics);
	}
	
#endif
	
	RS_table_free(H->range_weight_table);
	RS_table_free(H->angular_weight_table);
	RS_table3d_free(H->physics_table);
	
	free(H->anchor_pos);
	
	free(H);
	
	if (v) {
		printf("%s : RS : Resources released.\n", now());
	}
}


RSMakePulseParams RS_make_pulse_params(const cl_uint count, const cl_uint user_max_work_items, cl_uint user_max_groups,
									   const float range_start, const float range_delta, const unsigned int range_count) {
	RSMakePulseParams param;
	
	// Keep a copy for reference
	param.num_scats = count;
	param.user_max_groups = user_max_groups;
	param.user_max_work_items = user_max_work_items;
	param.range_start = range_start;
	param.range_delta = range_delta;
	param.range_count = MAX(1, range_count);
    
	// The 2nd pass kernel functions are only for work_items <= 256
	if (user_max_groups > 256) {
		fprintf(stderr, "%s : RS : I'm not programmed to handle user_max_groups > 256.\n", now());
		param.user_max_groups = 256;
	}
	
	// Work items is at most count / 2
	unsigned int work_items = count > param.user_max_work_items * 2 ? param.user_max_work_items : count / 2;
	
	// Number of group item-pairs
	unsigned int group_count = count <= work_items * 2 ? 1 : count / (work_items * 2);
	if (group_count > param.user_max_groups) {
		group_count = param.user_max_groups;
	}
	
	//printf("count=%d  work_items=%d  groups=%d/%d\n", count, work_items, group_count, param.user_max_groups);
	
	// 1st pass
	param.entry_counts[0] = count;
	param.group_counts[0] = group_count;
	param.global[0] = group_count * work_items;
	param.local[0] = work_items;
	param.local_mem_size[0] = range_count * work_items * sizeof(cl_float4);
	
	// 2nd pass
	unsigned int work_count = group_count * param.range_count;
	
	param.entry_counts[1] = work_count;
	
	if (param.local[0] % param.range_count == 0) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_UNIVERSAL;
		work_items = work_count / (param.range_count * 2);
		if (work_items < 1) {
			fprintf(stderr, "%s : RS : 2nd pass with CL work_items < 2?\n", now());
			work_items = 1;
		}
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else if (group_count >= 2 * param.range_count) {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_LOCAL;
		work_items = work_count / (param.range_count * 2);
		if (work_items < 1) {
			work_items = 1;
		}
		param.group_counts[1] = 1;
		param.global[1] = work_items;
		param.local[1] = work_items;
		param.local_mem_size[1] = work_items * sizeof(cl_float4);
		
	} else {
		//
		param.cl_pass_2_method = RS_CL_PASS_2_IN_RANGE;
		param.group_counts[1] = 1;
		param.global[1] = param.range_count;
		param.local[1] = 1;
		param.local_mem_size[1] = sizeof(cl_float4);
		
	}
	if (param.entry_counts[1] > RS_MAX_GATES * RS_CL_GROUP_ITEMS) {
		fprintf(stderr, "%s : RS : H->dev_work is not large enough.\n", now());
	}
	return param;
}


void RS_init_scat_pos(RSHandle *H) {
	//
	// Initialize the scatter body positions & velocities
	//
	for (int i=1; i<H->num_scats; i++) {
		H->scat_pos[i].x = (float)rand() / RAND_MAX * H->domain.size.x + H->domain.origin.x;
		H->scat_pos[i].y = (float)rand() / RAND_MAX * H->domain.size.y + H->domain.origin.y;
		H->scat_pos[i].z = (float)rand() / RAND_MAX * H->domain.size.z + H->domain.origin.z;
		H->scat_pos[i].w = 1.0f;
		
		H->scat_att[i].s0 = 0.0f;
		H->scat_att[i].s1 = (float)rand() / RAND_MAX;
		H->scat_att[i].s2 = 0.0f;
		H->scat_att[i].s3 = 0.0f;
		
		H->scat_vel[i].x = 0.0f;
		H->scat_vel[i].y = 0.0f;
		H->scat_vel[i].z = 0.0f;
		H->scat_vel[i].w = 1.0f;
		
		H->scat_ori[i].x = 0.0f;
		H->scat_ori[i].y = 0.0f;
		H->scat_ori[i].z = 0.0f;
		H->scat_ori[i].w = 1.0f;
		
		H->scat_sig[i].s0 = 1.0f;
		H->scat_sig[i].s1 = 0.0f;
		H->scat_sig[i].s2 = 1.0f;
		H->scat_sig[i].s3 = 0.0f;
	}
	
	// Replace a few points for debugging purpose.
	H->scat_pos[0].x = H->domain.origin.x + 0.5f * H->domain.size.x;
	H->scat_pos[0].y = H->domain.origin.y + 0.5f * H->domain.size.y;
	H->scat_pos[0].z = H->domain.origin.z + 0.5f * H->domain.size.z;
	
	H->scat_pos[1820].x = H->domain.origin.x;
	H->scat_pos[1820].y = H->domain.origin.y;
	H->scat_pos[1820].z = H->domain.origin.z;
	
	H->scat_pos[3640].x = H->domain.origin.x + 0.25f * H->domain.size.x;
	H->scat_pos[3640].y = H->domain.origin.y + 0.25f * H->domain.size.y;
	H->scat_pos[3640].z = H->domain.origin.z + 0.25f * H->domain.size.z;
	
	H->scat_pos[5460].x = H->domain.origin.x + 0.75f * H->domain.size.x;
	H->scat_pos[5460].y = H->domain.origin.y + 0.75f * H->domain.size.y;
	H->scat_pos[5460].z = H->domain.origin.z + 0.75f * H->domain.size.z;
	
	H->scat_pos[7280].x = H->domain.origin.x + H->domain.size.x;
	H->scat_pos[7280].y = H->domain.origin.y + H->domain.size.y;
	H->scat_pos[7280].z = H->domain.origin.z + H->domain.size.z;
	
	// Advance the point by dt = 0.0f so that all attributes are computed.
	float prt = H->params.prt;
	H->params.prt = 0.0f;
	RS_advance_time_cpu(H);
	H->params.prt = prt;
	
	// Restore simulation time
	H->sim_tic = 0;
	H->sim_toc = 0;
	H->sim_time = 0.0f;
}

#pragma mark -
#pragma mark Properties

void RS_set_prt(RSHandle *H, const float prt) {
	H->params.prt = prt;
	H->params.prf = 1.0f / prt;
//	for (int i=0; i<H->num_scats; i++) {
//		H->scat_att[i].s1 = (float)rand() / RAND_MAX * 1000.0f;
//	}
}

void RS_set_density(RSHandle *H, const float density) {
	H->params.body_per_cell = density;
}


void RS_set_antenna_params(RSHandle *H, RSfloat beamwidth_deg, RSfloat gain_dbi) {
	H->params.antenna_bw_deg = beamwidth_deg;
	H->params.antenna_bw_rad = M_PI * H->params.antenna_bw_deg / 180.0f;
}


void RS_set_tx_params(RSHandle *H, RSfloat pulsewidth, RSfloat tx_power_watt) {
	H->params.tau = pulsewidth;
	H->params.dr = H->params.c * H->params.tau * 0.5f;
	H->params.tx_power_watt = tx_power_watt;
}


void RS_set_scan_box(RSHandle *H,
					 RSfloat range_start, RSfloat range_end, RSfloat range_delta,
					 RSfloat azimuth_start, RSfloat azimuth_end, RSfloat azimuth_delta,
					 RSfloat elevation_start, RSfloat elevation_end, RSfloat elevation_delta) {
	
	H->status &= !RS_STATUS_DOMAIN_POPULATED;
	H->params.range_start = range_start;
	H->params.range_end = range_end;
	H->params.range_delta = range_delta;
	H->params.azimuth_start_deg = azimuth_start;
	H->params.azimuth_end_deg = azimuth_end;
	H->params.azimuth_delta_deg = azimuth_delta;
	H->params.elevation_start_deg = elevation_start;
	H->params.elevation_end_deg = elevation_end;
	H->params.elevation_delta_deg = elevation_delta;
	
	const RSfloat r_lo = floor((H->params.range_start - H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat r_hi =  ceil((H->params.range_end   + H->params.domain_pad_factor * H->params.dr) / H->params.range_delta) * H->params.range_delta;
	const RSfloat az_lo = floor((H->params.azimuth_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat az_hi =  ceil((H->params.azimuth_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg;
	const RSfloat el_lo = MAX( 0.0f, floor((H->params.elevation_start_deg - H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat el_hi = MIN(90.0f,  ceil((H->params.elevation_end_deg   + H->params.domain_pad_factor * H->params.antenna_bw_deg) / H->params.antenna_bw_deg) * H->params.antenna_bw_deg);
	const RSfloat tiny = 1.0e-5;
	
	int nr = 0;
	int naz = 0;
	int nel = 0;
	
	RSfloat r;
	RSfloat az;
	RSfloat el;
	
	int ii = 0;
	
	// Number of range gates
	r = floor(H->params.range_start / H->params.range_delta) * H->params.range_delta;
	while (r <= ceil(H->params.range_end / H->params.range_delta) * H->params.range_delta) {
		r += H->params.range_delta;
		nr++;
	}
	H->params.range_count = MIN(RS_MAX_GATES, nr);
	
	// Evaluate the number of scatterers needed
	az = az_lo;
	while (az <= az_hi + tiny) {
		az += H->params.azimuth_delta_deg;
		if (az >= 360.0f) {
			az -= 360.0f;
		}
		naz++;
	}
	el = el_lo;
	while (el <= el_hi) {
		el += H->params.elevation_delta_deg;
		nel++;
	}
	H->num_anchors  = 2 * naz * nel + 1;  // Save one for radar origin
	//printf("%s : RS : Number of anchors needed = %d\n", now(), (int)H->num_anchors);
	if (H->anchor_pos) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor memory.\n", now());
		}
		free(H->anchor_pos);
	}
	H->anchor_pos = (cl_float4 *)malloc(H->num_anchors * sizeof(cl_float4));
	if (H->anchor_pos == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchors.\n", now());
		return;
	}
	
	// Domain size
	RSfloat
	xmin = INFINITY, xmax = -INFINITY,
	ymin = INFINITY, ymax = -INFINITY,
	zmin = INFINITY, zmax = 0.0;
	el = el_lo / 180.0 * M_PI;
	while (el <= el_hi / 180.0 * M_PI + tiny && ii < H->num_anchors - 1) {
		az = az_lo / 180.0 * M_PI;
		while (az <= az_hi / 180.0 * M_PI + tiny && ii < H->num_anchors - 1) {
			H->anchor_pos[ii].x = r_lo * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_lo * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_lo * sin(el);
			H->anchor_pos[ii].w = 1.0;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			H->anchor_pos[ii].x = r_hi * cos(el) * sin(az);
			H->anchor_pos[ii].y = r_hi * cos(el) * cos(az);
			H->anchor_pos[ii].z = r_hi * sin(el);
			H->anchor_pos[ii].w = 1.0;
			xmin = H->anchor_pos[ii].x < xmin ? H->anchor_pos[ii].x : xmin;
			xmax = H->anchor_pos[ii].x > xmax ? H->anchor_pos[ii].x : xmax;
			ymin = H->anchor_pos[ii].y < ymin ? H->anchor_pos[ii].y : ymin;
			ymax = H->anchor_pos[ii].y > ymax ? H->anchor_pos[ii].y : ymax;
			zmin = H->anchor_pos[ii].z < zmin ? H->anchor_pos[ii].z : zmin;
			zmax = H->anchor_pos[ii].z > zmax ? H->anchor_pos[ii].z : zmax;
			ii++;
			
			az += azimuth_delta / 180.0 * M_PI;
		}
		el += elevation_delta / 180.0 * M_PI;
	}
	
	// Radar origin at (0, 0, 0)
	H->anchor_pos[ii].x = 0.0f;
	H->anchor_pos[ii].y = 0.0f;
	H->anchor_pos[ii].z = 0.0f;
	H->anchor_pos[ii].w = 1.0f;
	
	//printf("H->num_anchors = %zu   ii = %d\n", H->num_anchors, ii);
	
	// Volume of a single resolution cell
	r = 0.5f * (H->params.range_start + H->params.range_start);
	RSfloat vol = (H->params.antenna_bw_rad * r) * (H->params.antenna_bw_rad * r) * (H->params.c * H->params.tau * 0.5);
	RSfloat nvol = ((xmax-xmin) * (ymax-ymin) * (zmax-zmin)) / vol;
	
	H->domain.origin.x = xmin;
	H->domain.origin.y = ymin;
	H->domain.origin.z = zmin;
	H->domain.size.x = xmax - xmin;
	H->domain.size.y = ymax - ymin;
	H->domain.size.z = zmax - zmin;
	
	// Suggest a number of scatter bodies to use
	H->num_scats = (size_t)(H->params.body_per_cell * nvol);
	
	// Round to a GPU preferred number
	size_t mul = RS_CL_GROUP_ITEMS * H->num_cus[0] * H->num_devs * 4;
	size_t preferred_n = (size_t)(H->num_scats / mul) * mul;
	if (preferred_n < H->params.body_per_cell * 9 / 10) {
		preferred_n += mul;
	}
	
	if (H->verb) {
		printf("%s : RS : nvol = %.4f\n", now(), nvol);
		printf("%s : RS : Box @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   xmin, xmax,
			   ymin, ymax,
			   zmin, zmax);
		printf("%s : RS : User domain @ R:[ %5.2f - %5.2f ]   E:[ %5.2f - %5.2f ]   A:[ %+.2f - %+.2f ]\n", now(),
			   1e-3*H->params.range_start, 1e-3*H->params.range_end,
			   H->params.elevation_start_deg, H->params.elevation_end_deg,
			   H->params.azimuth_start_deg, H->params.azimuth_end_deg);
		
		printf("%s : RS : Work domain @ R:[ %5.2f - %5.2f ]   E:[ %5.2f - %5.2f ]   A:[ %+.2f - %+.2f ]\n", now(),
			   1e-3*r_lo, 1e-3*r_hi,
			   el_lo, el_hi,
			   az_lo, az_hi);
		
		printf("%s : RS : Suggested %s bodies\n", now(), commaint(H->num_scats));
		printf("%s : RS : Using GPU preferred %s (%.2f bodies / resolution cell)\n", now(), commaint(preferred_n), (float)preferred_n / nvol);
	}
	
	H->num_scats = preferred_n;
	
	// Anchor lines to show the volume of interest, which was set by the user. The number is well more than enough
	H->num_anchor_lines  = 8 * (naz + nel);
	
	if (H->anchor_lines) {
		if (H->verb > 2) {
			printf("%s : RS : Freeing existing anchor_line memory.\n", now());
		}
		free(H->anchor_lines);
	}
	H->anchor_lines = (cl_float4 *)malloc(H->num_anchor_lines * sizeof(cl_float4));
	if (H->anchor_lines == NULL) {
		fprintf(stderr, "%s : RS : Error in allocating anchor_lines.\n", now());
		return;
	}
	ii = 0;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (az < (H->params.azimuth_end_deg - H->params.azimuth_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		az += H->params.azimuth_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_start * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	while (el < (H->params.elevation_end_deg - H->params.elevation_delta_deg) / 180.0 * M_PI + tiny && ii < H->num_anchor_lines - 1) {
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
		
		el += H->params.elevation_delta_deg / 180.0 * M_PI;
		
		H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
		H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
		H->anchor_lines[ii].z = H->params.range_end * sin(el);
		H->anchor_lines[ii].w = 1.0;
		ii++;
	}
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_start_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_end_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	el = H->params.elevation_end_deg / 180.0 * M_PI;
	az = H->params.azimuth_start_deg / 180.0 * M_PI;
	H->anchor_lines[ii].x = H->params.range_start * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_start * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_start * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	H->anchor_lines[ii].x = H->params.range_end * cos(el) * sin(az);
	H->anchor_lines[ii].y = H->params.range_end * cos(el) * cos(az);
	H->anchor_lines[ii].z = H->params.range_end * sin(el);
	H->anchor_lines[ii].w = 1.0;
	ii++;
	
	// printf("num_anchor_lines = %zu  ii = %d\n", H->num_anchor_lines, ii);
	
	H->num_anchor_lines = ii;
	
	return;
}


void RS_set_beam_pos(RSHandle *H, RSfloat az_deg, RSfloat el_deg) {
	// Compute the unit vector of the pointing direction
	H->beam_pos.x = cosf(el_deg / 180.0f * M_PI) * sinf(az_deg / 180.0f * M_PI);
	H->beam_pos.y = cosf(el_deg / 180.0f * M_PI) * cosf(az_deg / 180.0f * M_PI);
	H->beam_pos.z = sinf(el_deg / 180.0f * M_PI);
	H->beam_pos.w = 0.0f;
}


void RS_set_verbosity(RSHandle *H, const char verb) {
	H->verb = verb;
}

#pragma mark -
#pragma mark Functions to set properties after RS_init()

void RS_set_worker_count(RSHandle *H, char count) {
	
	if (H->method == RS_METHOD_GPU) {
		printf("%s : RS : Number of workers cannot be changed for GPU method.\n", now());
		return;
	}
	
	H->num_workers = count;
	
	size_t offset = 0;
	size_t sub_num_scats = H->num_scats / H->num_workers;
	
	for (int i=0; i<H->num_workers; i++) {
		H->offset[i] = offset;
		if (H->verb > 1) {
			printf("%s : RS : worker[%d] num_scats = %s   offset = %s\n", now(), i, commaint(sub_num_scats), commaint(offset));
		}
		offset += sub_num_scats;
	}
}


void RS_set_range_weight(RSHandle *H, const float *table, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
	RS_table_free(H->range_weight_table);
	H->range_weight_table = RS_table_init(table_size);
	if (H->range_weight_table.data == NULL) {
		fprintf(stderr, "%s : RS : Unable to allocate weight table.\n", now());
		return;
	}
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	H->range_weight_table.dx = 1.0f / table_index_delta;
	H->range_weight_table.x0 = -table_index_start * H->range_weight_table.dx;
	H->range_weight_table.xm = (float)table_size - 1.0f;
	if (H->verb) {
		printf("%s : RS : Host range weight table set.  n = %d\n", now(), table_size);
	}
	memcpy(H->range_weight_table.data, table, table_size * sizeof(float));
	
	if (H->method == RS_METHOD_GPU) {
		
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
		
		for (i=0; i<H->num_workers; i++) {
			if (H->worker[i].range_weight != NULL) {
				if (H->verb > 1) {
					printf("%s : RS : worker[%d] setting range weight.\n", now(), i);
				}
				gcl_free(H->worker[i].range_weight);
			}
			H->worker[i].range_weight = gcl_malloc(table_size * sizeof(float), H->range_weight_table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
			if (H->worker[i].range_weight == NULL) {
				fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
				return;
			}
		}
		
#else
		
		cl_int ret;
		for (i=0; i<H->num_workers; i++) {
			if (H->worker[i].range_weight != NULL) {
				if (H->verb > 1) {
					printf("%s : RS : worker[%d] setting range weight.\n", now(), i);
				}
				clReleaseMemObject(H->worker[i].range_weight);
			}
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] creating range weight (cl_mem) & copying data from %p.\n", now(), i, H->range_weight_table.data);
			}
			H->worker[i].range_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), H->range_weight_table.data, &ret);
			if (ret != CL_SUCCESS) {
				fprintf(stderr, "%s : RS : Error creating range weight table on CL device.\n", now());
				return;
			}
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] created range weight @ %p.\n", now(), i, H->worker[i].range_weight);
			}
		}
		
#endif
		
	}
}


void RS_set_range_weight_to_triangle(RSHandle *H, float pulse_width_m) {
	float w[3] = {0.0f, 1.0f, 0.0f};
	RS_set_range_weight(H, w, -pulse_width_m, pulse_width_m, 3);
}


void RS_set_angular_weight(RSHandle *H, const float *table, const float table_index_start, const float table_index_delta, unsigned int table_size) {
	
	int i;
	
	RS_table_free(H->angular_weight_table);
	H->angular_weight_table = RS_table_init(table_size);
	//	printf("table_size = %d\n", table_size);
	if (H->angular_weight_table.data == NULL) {
		fprintf(stderr, "%s : RS : Unable to allocate weight table.\n", now());
		return;
	}
	// Set up the coefficients for FMA(a, b, c) in the CL kernel
	H->angular_weight_table.dx = 1.0f / table_index_delta;
	H->angular_weight_table.x0 = -table_index_start * H->angular_weight_table.dx;
	H->angular_weight_table.xm = (float)table_size - 1.0f;
	if (H->verb > 1) {
		printf("%s : RS : Host angular weight table set.  dx = %.4f   x0 = %.1f   xm = %.0f\n", now(),
			   H->angular_weight_table.dx, H->angular_weight_table.x0, H->angular_weight_table.xm);
	}
	memcpy(H->angular_weight_table.data, table, table_size * sizeof(float));
	
	if (H->method == RS_METHOD_GPU) {
		
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
		
		//printf("gcl_malloc() for angular weight  %d  table_size=%d.\n", H->num_workers, table_size);
		for (i=0; i<H->num_workers; i++) {
			if (H->worker[i].angular_weight != NULL) {
				if (H->verb > 1) {
					printf("%s : RS : worker[%d] setting angular weight.\n", now(), i);
				}
				gcl_free(H->worker[i].angular_weight);
			}
			H->worker[i].angular_weight = gcl_malloc(table_size * sizeof(float), H->angular_weight_table.data, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR);
			if (H->worker[i].angular_weight == NULL) {
				fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
				return;
			}
		}
		
#else
		
		cl_int ret;
		for (i=0; i<H->num_workers; i++) {
			if (H->worker[i].angular_weight != NULL) {
				if (H->verb > 1) {
					printf("%s : RS : worker[%d] setting angular weight.\n", now(), i);
				}
				clReleaseMemObject(H->worker[i].angular_weight);
			}
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] creating angular weight (cl_mem) & copying data from %p.\n", now(), i, H->angular_weight_table.data);
			}
			H->worker[i].angular_weight = clCreateBuffer(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, table_size * sizeof(float), H->angular_weight_table.data, &ret);
			if (ret != CL_SUCCESS) {
				fprintf(stderr, "%s : RS : Error creating angular weight table on CL device.\n", now());
				return;
			}
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] created angular weight.\n", now(), i);
			}
		}
		
#endif
		
	}
}


void RS_set_angular_weight_to_double_cone(RSHandle *H, float beamwidth_rad) {
	float w[] = {1.0f, 0.0f, 0.8f, 0.0f};
	unsigned int n = sizeof(w) / sizeof(float);
	RS_set_angular_weight(H, w, 0.0f, 2.0f * beamwidth_rad, n);
}


void RS_set_angular_weight_to_standard(RSHandle *H, float beamwidth_rad) {
	unsigned int n = 40;
	float a;
	float b = 1.27f * M_PI / beamwidth_rad;
	float c;
	float w[n];
	
	for (int i=0; i<n; i++) {
		a = (float)i / 360.0f * M_PI;
		c = b * sinf(a);
		if (i == 0) {
			w[i] = 1.0f;
		} else if (i == (n - 1)) {
			w[i] = 0.0f;
		} else {
			w[i] = 8.0f * jn(2, c) / (c * c);
			w[i] *= w[i];
		}
		//printf("angle=%.4f deg  w[%d] = %.4f dB\n", a / M_PI * 180.0f, i, 10.0f * log10f(w[i]));
	}
	RS_set_angular_weight(H, w, 0.0f, 0.5f / 180.0f * M_PI, n);
}


void RS_set_physics_data(RSHandle *H, const RSTable3D table) {
	
	int i;
	
	const size_t n = table.x_ * table.y_ * table.z_;
	
	// Free the old table if exists; and create a new table
	RS_table3d_free(H->physics_table);
	H->physics_table = RS_table3d_init(n);
	if (H->physics_table.data == NULL) {
		fprintf(stderr, "%s : RS : RS_set_physics_data() failed to allocate 3D table.\n", now());
		return;
	}
	
	// Set up the mapping coefficients
	H->physics_table.x_ = table.x_;   H->physics_table.xs = table.xs;   H->physics_table.xo = table.xo;    H->physics_table.xm = table.xm;
	H->physics_table.y_ = table.y_;   H->physics_table.ys = table.ys;   H->physics_table.yo = table.yo;    H->physics_table.ym = table.ym;
	H->physics_table.z_ = table.z_;   H->physics_table.zs = table.zs;   H->physics_table.zo = table.zo;    H->physics_table.zm = table.zm;
	
    // Copy over other parameters
    H->physics_table.tr = table.tr;
    
	// Copy the table data
	if (H->verb) {
		printf("%s : RS : Host physics table set.  n = %d x %d x %d\n", now(), H->physics_table.x_, H->physics_table.y_, H->physics_table.z_);
	}
	memcpy(H->physics_table.data, table.data, n * sizeof(cl_float4));
	
	// We are done if no GPU acceleration is utilized
	if (H->method == RS_METHOD_CPU) {
		return;
	}
	
	cl_image_format format = {CL_RGBA, CL_FLOAT};
	
#if defined (CL_VERSION_1_2)

	cl_image_desc desc;
	desc.image_type = CL_MEM_OBJECT_IMAGE3D;
	desc.image_width  = H->physics_table.x_;
	desc.image_height = H->physics_table.y_;
	desc.image_depth  = H->physics_table.z_;
	desc.image_array_size = 0;
	desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
	desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
	desc.num_mip_levels = 0;
	desc.num_samples = 0;
	desc.buffer = NULL;
	
#endif
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		if (H->worker[i].physics != NULL) {
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] setting physics.\n", now(), i);
			}
			gcl_release_image(H->worker[i].physics);
		}
		H->worker[i].physics = gcl_create_image(&format, desc.image_width, desc.image_height, desc.image_depth, NULL);
		if (H->worker[i].physics == NULL) {
			fprintf(stderr, "%s : RS : Error creating physics table on CL device.\n", now());
			return;
		}
		if (H->verb > 1) {
			printf("%s : RS : Copying physics table[%d]  %p --> %p  (%u x %u x %u)\n",
				   now(), i, H->physics_table.data, H->worker[i].physics,
				   H->physics_table.x_, H->physics_table.y_, H->physics_table.z_);
		}
		dispatch_async(H->worker[i].que, ^{
			size_t origin[3] = {0, 0, 0};
			size_t region[3] = {H->physics_table.x_, H->physics_table.y_, H->physics_table.z_};
			gcl_copy_ptr_to_image(H->worker[i].physics, H->physics_table.data, origin, region);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	cl_int ret;
	
	//	float *f = (float *)H->physics_table.data;
	//	for (i=0; i<27 * 4; i+=4)
	//		printf("%d - %.4f\n", i/4, f[i]);
	
	for (i=0; i<H->num_workers; i++) {
		if (H->worker[i].physics != NULL) {
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] setting physics table.\n", now(), i);
			}
			clReleaseMemObject(H->worker[i].physics);
		}
		if (H->verb > 1) {
			printf("%s : RS : worker[%d] creating physics (image3d_t) & copying from %p.\n", now(), i, H->physics_table.data);
		}
		
#if defined (CL_VERSION_1_2)
		
		H->worker[i].physics = clCreateImage(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, &format, &desc, H->physics_table.data, &ret);
		
#else
		
		H->worker[i].physics = clCreateImage3D(H->worker[i].context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, &format,
											   H->physics_table.x_, H->physics_table.y_, H->physics_table.z_,
											   H->physics_table.x_ * sizeof(cl_float4),
											   H->physics_table.y_ * H->physics_table.x_ * sizeof(cl_float4),
											   H->physics_table.data,
											   &ret);
		
#endif
		
		if (ret != CL_SUCCESS) {
			fprintf(stderr, "%s : RS : Error creating physics table on CL device.\n", now());
			return;
		}
		if (H->verb > 1) {
			printf("%s : RS : worker[%d] created physics @ %p\n", now(), i, H->worker[i].physics);
		}
	}
	
#endif
	
}


void RS_set_physics_data_to_LES_table(RSHandle *H, const LESTable *leslie) {
	
	int i;
	
	RSTable3D table;
	
	if (H->verb > 1) {
		printf("%s : RS : LES @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
			   H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
			   H->domain.origin.z, H->domain.origin.z + H->domain.size.z);
	}
	
	// Set up the mapping coefficients
	table.x_ = leslie->nx;    table.xm = (float)(table.x_ - 1);    table.xs = (float)leslie->nx / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
	table.y_ = leslie->ny;    table.ym = (float)(table.y_ - 1);    table.ys = (float)leslie->ny / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;
	table.z_ = leslie->nz;    table.zm = (float)(table.z_ - 1);    table.zs = (float)leslie->nz / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs;
	
	// Copy over other important parameters
	table.tr = leslie->tr;
	
	// Temporary buffer for passing data
	table.data = (cl_float4 *)malloc(leslie->nn * sizeof(cl_float4));
	
	// Need to arrange LES values into float4, then upload to GPU's global memory
	for (i=0; i<leslie->nn; i++) {
		table.data[i].x = leslie->u[i];
		table.data[i].y = leslie->v[i];
		table.data[i].z = leslie->w[i];
		table.data[i].w = 1.0f;
	}
	
	RS_set_physics_data(H, table);
	
	free(table.data);
}


void RS_set_physics_data_to_cube27(RSHandle *H) {
	
	int i;
	
	RSTable3D table;
	
	if (H->verb > 1) {
		printf("%s : RS : Cube27 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
			   H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
			   H->domain.origin.z, H->domain.origin.z + H->domain.size.z);
	}
	
	// Set up the mapping coefficients: -table_start * table_dx
	//	table.x_ = 3;    table.xm = 2.0f;    table.xs = 2.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs + 0.5f;
	//	table.y_ = 3;    table.ym = 2.0f;    table.ys = 2.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys + 0.5f;
	//	table.z_ = 3;    table.zm = 2.0f;    table.zs = 2.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs + 0.5f;
	
	table.x_ = 3;    table.xm = 2.0f;    table.xs = 3.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
	table.y_ = 3;    table.ym = 2.0f;    table.ys = 3.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;
	table.z_ = 3;    table.zm = 2.0f;    table.zs = 3.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	//	printf(" %.2f x %.2f = %.2f\n", -H->domain.origin.x, H->physics_table.xs, -H->domain.origin.x / H->domain.size.x * 2.0f);
	//	printf("o = [%.2f, %.2f, %.2f]\n", table.xo, table.yo, table.zo);
	
	cl_float4 data[27];
	
	table.data = data;
	
	const float v = 1.0f;
	
	for (i=0; i<27; i++) {
		data[i].x = (float) (i % 3)      * v - v;
		data[i].y = (float)((i % 9) / 3) * v - v;
		data[i].z = (float) (i / 9)      * v - v;
		data[i].w = 0.0f;
	}
	
	RS_set_physics_data(H, table);
	
}


void RS_set_physics_data_to_cube125(RSHandle *H) {
	
	int i;
	
	RSTable3D table;
	
	if (H->verb > 1) {
		printf("%s : RS : Cube125 @ X:[ %.2f - %.2f ]   Y:[ %.2f - %.2f ]   Z:[ %.2f - %.2f ]\n",
			   now(),
			   H->domain.origin.x, H->domain.origin.x + H->domain.size.x,
			   H->domain.origin.y, H->domain.origin.y + H->domain.size.y,
			   H->domain.origin.z, H->domain.origin.z + H->domain.size.z);
	}
	
	// Set up the mapping coefficients
	//	table.x_ = 5;    table.xm = 4.0f;    table.xs = 4.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs + 0.5f;
	//	table.y_ = 5;    table.ym = 4.0f;    table.ys = 4.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys + 0.5f;
	//	table.z_ = 5;    table.zm = 4.0f;    table.zs = 4.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs + 0.5f;
	
	table.x_ = 5;    table.xm = 4.0f;    table.xs = 5.0f / H->domain.size.x;    table.xo = -H->domain.origin.x * table.xs;
	table.y_ = 5;    table.ym = 4.0f;    table.ys = 5.0f / H->domain.size.y;    table.yo = -H->domain.origin.y * table.ys;
	table.z_ = 5;    table.zm = 4.0f;    table.zs = 5.0f / H->domain.size.z;    table.zo = -H->domain.origin.z * table.zs;
	
	table.tr = 1000.0f;
	
	cl_float4 data[125];
	
	table.data = data;
	
	const float v = 0.5f;
	
	for (i=0; i<125; i++) {
		data[i].x = (float) (i %  5)      * v - 2.0f * v;
		data[i].y = (float)((i % 25) / 5) * v - 2.0f * v;
		data[i].z = (float) (i / 25)      * v - 2.0f * v;
		data[i].w = 0.0f;
		// printf("i=%3d  (%+.2f, %+.2f, %+.2f)\n", i, data[i].x, data[i].y, data[i].z);
	}
	
	RS_set_physics_data(H, table);
	
}


void RS_set_adm_data(RSHandle *H, const RSTable2D table) {
    
    int i, t;
    
    const size_t n = table.x_ * table.y_;
    
    t = 0;
    {
        // Free the old table if exists; and create a new table
        RS_table2d_free(H->adm_tables[t]);
        H->adm_tables[t] = RS_table2d_init(n);
        if (H->adm_tables[t].data == NULL) {
            fprintf(stderr, "%s : RS : RS_set_adm_data() failed to allocate 2D table", now());
            return;
        }
        
        // Set up mapping coefficients
        H->adm_tables[t].x_ = table.x_;   H->adm_tables[t].xs = table.xs;   H->adm_tables[t].xo = table.xo;   H->adm_tables[t].xm = table.xm;
        H->adm_tables[t].y_ = table.y_;   H->adm_tables[t].ys = table.ys;   H->adm_tables[t].yo = table.yo;   H->adm_tables[t].ym = table.ym;
        
        // Copy over other parameters

        // Copy the table data
        if (H->verb) {
            printf("%s : RS : Host ADM table set.  n = %d x %d\n", now(), H->adm_tables[t].x_, H->adm_tables[t].y_);
        }
        memcpy(H->adm_tables[t].data, table.data, n * sizeof(cl_float8));
        
        // We are done if no GPU acceleration is utilized
        if (H->method == RS_METHOD_CPU) {
            return;
        }
        
        // This is the part that we need to create two texture maps for each RSTable2D table
        cl_image_format format = {CL_RGBA, CL_FLOAT};
        
#if defined (CL_VERSION_1_2)
        
        cl_image_desc desc;
        desc.image_type = CL_MEM_OBJECT_IMAGE2D;
        desc.image_width  = H->adm_tables[t].x_;
        desc.image_height = H->adm_tables[t].y_;
        desc.image_depth  = 1;
        desc.image_array_size = 0;
        desc.image_row_pitch = desc.image_width * sizeof(cl_float4);
        desc.image_slice_pitch = desc.image_height * desc.image_row_pitch;
        desc.num_mip_levels = 0;
        desc.num_samples = 0;
        desc.buffer = NULL;
        
#endif

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

        for (i=0; i<H->num_workers; i++) {
            if (H->worker[i].adm[t] != NULL) {
                if (H->verb > 1) {
                    printf("%s : RS : worker[%d] setting adm[%d].\n", now(), i, t);
                }
                gcl_release_image(H->worker[i].adm[t]);
            }
            H->worker[i].adm[t] = gcl_create_image(&format, desc.image_width, desc.image_height, desc.image_depth, NULL);
            if (H->worker[i].adm[t] == NULL) {
                fprintf(stderr, "%s : RS : Error creating ADM table on CL device.\n", now());
                return;
            }
            if (H->verb > 1) {
                printf("%s : RS : Copying ADM table[%d]  %p --> %p  (%u x %u)\n",
                       now(), i, H->adm_tables[t].data, H->worker[i].adm[t],
                       H->adm_tables[t].x_, H->adm_tables[t].y_);
            }
            dispatch_async(H->worker[i].que, ^{
                size_t origin[3] = {0, 0, 0};
                size_t region[3] = {H->adm_tables[t].x_, H->adm_tables[t].y_, 1};
                gcl_copy_ptr_to_image(H->worker[i].adm[t], H->adm_tables[t].data, origin, region);
                dispatch_semaphore_signal(H->worker[i].sem);
            });
        }
        
        for (i=0; i<H->num_workers; i++) {
            dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
        }

#else

#endif

    } // t = 0
}


void RS_set_adm_data_to_ADM_table(RSHandle *H, const ADMTable *adam) {
    
    int i;
    
    RSTable2D table;
    
    if (H->verb > 1) {
        printf("%s : RS : ADM @ \n", now());
    }
    
    // Set up the mapping coefficients
    // Assumptions: maps are always in beta in [-180deg, +180deg] and alpha in [0, +180deg]
    table.x_ = adam->nb;    table.xm = (float)(table.x_ - 1);    table.xs = (float)adam->nb / (2.0f * M_PI);    table.xo = -M_PI;
    table.y_ = adam->na;    table.ym = (float)(table.y_ - 1);    table.ys = (float)adam->na / M_PI;             table.yo = 0.0f;

    // Temporary buffer for passing data
    table.data = (cl_float8 *)malloc(adam->nn * sizeof(cl_float8));
    
    // Arrange ADM values into float4, getting ready for GPU's global memory
    for (i=0; i<adam->nn; i++) {
        table.data[i].x = adam->cdx[i];
        table.data[i].y = adam->cdy[i];
        table.data[i].z = adam->cdz[i];
        table.data[i].w = 1.0f;
        table.data[i].s4 = adam->cmx[i];
        table.data[i].s5 = adam->cmy[i];
        table.data[i].s6 = adam->cmz[i];
        table.data[i].s7 = 0.0f;
    }
    
    RS_set_adm_data(H, table);
    
    free(table.data);
}

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

#pragma mark -
#pragma mark Mac OS X Specific Functions

void RS_share_mem_with_vbo(RSHandle *H, unsigned int *vbo) {
	for (int i=0; i<H->num_workers; i++) {
		H->worker[i].vbo_scat_pos = vbo[0];
		H->worker[i].vbo_scat_clr = vbo[1];
		H->worker[i].vbo_scat_ori = vbo[2];
	}
}


void RS_update_colors_only(RSHandle *H) {
	
	int i;
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			scat_clr2_kernel(&H->worker[i].ndrange_scat,
							 (cl_float4 *)H->worker[i].scat_clr,
							 (cl_float4 *)H->worker[i].scat_pos,
							 (cl_float4 *)H->worker[i].scat_att,
							 (cl_float *)H->worker[i].angular_weight,
							 H->worker[i].angular_weight_desc,
							 H->beam_pos,
							 (unsigned int)H->worker[i].num_scats);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	for (i=0; i<H->num_workers; i++)
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
}


void RS_explode(RSHandle *H) {
	
	int i;
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			scat_mov_kernel(&H->worker[i].ndrange_scat,
							(cl_float4 *)H->worker[i].scat_pos,
							(cl_float4 *)H->worker[i].scat_vel,
							(cl_float4 *)H->worker[i].scat_ori,
							(cl_float4 *)H->worker[i].scat_att,
							(cl_float *)H->worker[i].angular_weight,
							H->worker[i].angular_weight_desc,
							H->beam_pos,
							(cl_float4){{10000.0f, 0.0f, 0.0f, 0.0f}});
			scat_clr_kernel(&H->worker[i].ndrange_scat,
							(cl_float4 *)H->worker[i].scat_clr,
							(cl_float4 *)H->worker[i].scat_pos,
							(cl_float4 *)H->worker[i].scat_vel,
							(cl_float4 *)H->worker[i].scat_ori,
							(cl_float4 *)H->worker[i].scat_att,
							(unsigned int)H->worker[i].num_scats * 3 / 4);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
}


#endif

#pragma mark -
#pragma mark Framework Functions

void RS_io_test(RSHandle *H) {
    
    int i;
    
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
    
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			io_kernel(&H->worker[i].ndrange_scat,
                      (cl_float4 *)H->worker[i].scat_pos,
                      (cl_float4 *)H->worker[i].scat_att);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
    
	for (i=0; i<H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
    
#else
    
	//	cl_event events[RS_MAX_GPU_DEVICE];
    
	for (i=0; i<H->num_workers; i++) {
		//clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_io, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, &events[i]);
        clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_io, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, NULL);
	}
    
    for (i=0; i<H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
	
    for (i=0; i<H->num_workers; i++) {
        clFinish(H->worker[i].que);
    }
	
	//    for (i=0; i<H->num_workers; i++) {
	//        clWaitForEvents(1, &events[i]);
	//        clReleaseEvent(events[i]);
	//    }
    
	//    for (i=0; i<H->num_workers; i++) {
	//    }
    
#endif
	
}


void RS_populate(RSHandle *H) {
	if (H->num_scats > RS_MAX_NUM_SCATS) {
		printf("%s : RS : Exceed the maximum allowed. (%ld > %d).\n", now(), (unsigned long)H->num_scats, RS_MAX_NUM_SCATS);
	}
	
	//
	// CPU memory allocation
	//
	if (H->scat_pos != NULL) {
		RS_free_scat_memory(H);
	}
	
	posix_memalign((void **)&H->scat_pos, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_vel, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_ori, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_att, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	posix_memalign((void **)&H->scat_sig, RS_ALIGN_SIZE, H->num_scats * sizeof(cl_float4));
	
	posix_memalign((void **)&H->work, RS_ALIGN_SIZE, RS_MAX_GATES * RS_CL_GROUP_ITEMS * sizeof(cl_float4));
	posix_memalign((void **)&H->pulse, RS_ALIGN_SIZE, RS_MAX_GATES * sizeof(cl_float4));
	
	if (H->scat_pos == NULL ||
		H->scat_vel == NULL ||
		H->scat_ori == NULL ||
		H->scat_att == NULL ||
		H->scat_sig == NULL ||
		H->work == NULL ||
		H->pulse == NULL) {
		fprintf(stderr, "%s : RS : Error allocating memory space for scatterers.\n", now());
		return;
	}
	
	int i;
	BOOL has_null = FALSE;
	for (i=0; i<H->num_workers; i++) {
		posix_memalign((void **)&H->pulse_tmp[i], RS_ALIGN_SIZE, RS_MAX_GATES * sizeof(cl_float4));
		has_null |= H->pulse_tmp[i] == NULL;
	}
	if (has_null) {
		fprintf(stderr, "%s : RS : Error allocating memory space for pulses.\n", now());
		return;
	}
	
	//
	// GPU memory allocation
	//
	
	size_t offset = 0;
	
	// Divide the scatter bodies into (num_workers) chunks
	size_t sub_num_scats = H->num_scats / MAX(1, H->num_workers);
	
	if (H->method == RS_METHOD_GPU) {
		for (i=0; i<H->num_workers; i++) {
			H->offset[i] = offset;
			if (H->verb > 1) {
				printf("%s : RS : worker[%d] num_scats = %s   offset = %s\n", now(), i, commaint(sub_num_scats), commaint(offset));
			}
			RS_worker_malloc(H, i, sub_num_scats);
			offset += sub_num_scats;
		}
	}
	
	// Initialize the scatter body positions on CPU, then upload
	RS_init_scat_pos(H);
	
	if (H->method == RS_METHOD_GPU) {
		RS_upload(H);
		if (H->verb) {
			printf("%s : RS : CL domain synchronized.\n", now());
		}
	}
	
#if !defined (__APPLE__) || !defined (_SHARE_OBJ_)

	cl_float8 domain_bounds = {{
		H->domain.origin.x,
		H->domain.origin.y,
		H->domain.origin.z,
		0.0f,
		H->domain.size.x,
		H->domain.size.y,
		H->domain.size.z,
		500.0f
	}};
	
	cl_float4 t4 = {{H->params.prt, H->params.prt / H->physics_table.tr, 0.0f, 0.0f}};
	
	// Update kernel arguments
	cl_int ret = CL_SUCCESS;
	for (i=0; i<H->num_workers; i++) {
		// Domain bounds for scat_chk()
		ret |= clSetKernelArg(H->worker[i].kern_scat_chk, 3, sizeof(cl_float8), &domain_bounds);
		
		// PRT for scat_mov()
		ret |= clSetKernelArg(H->worker[i].kern_scat_mov, 7, sizeof(float), &t4);
	}

	if (ret != CL_SUCCESS) {
		fprintf(stderr, "%s : RS : Error: Failed to update kernel arguments in RS_populate().\n", now());
		exit(EXIT_FAILURE);
	}

#endif

	H->status = RS_STATUS_DOMAIN_POPULATED;
	
	return;
}


void RS_download(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_vel + H->offset[i], H->worker[i].scat_vel, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_ori + H->offset[i], H->worker[i].scat_ori, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_att + H->offset[i], H->worker[i].scat_att, H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->scat_sig + H->offset[i], H->worker[i].scat_sig, H->worker[i].num_scats * sizeof(cl_float4));
		});
	}
	
#else
	
	for (i=0; i<H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_att, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_att + H->offset[i], 0, NULL, NULL);
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, NULL);
	}
	
	RS_download_pulse_only(H);
	
#endif
	
}


void RS_download_position_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->scat_pos + H->offset[i], H->worker[i].scat_pos, H->worker[i].num_scats * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	for (i=0; i<H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
	}
	
#endif
	
}

void RS_merge_pulse_tmp(RSHandle *H) {
	memcpy(H->pulse, H->pulse_tmp[0], H->params.range_count * sizeof(cl_float4));
	for (int i=1; i<H->num_workers; i++) {
		for (int k=0; k<H->params.range_count; k++) {
			H->pulse[k].s0 += H->pulse_tmp[i][k].s0;
			H->pulse[k].s1 += H->pulse_tmp[i][k].s1;
			H->pulse[k].s2 += H->pulse_tmp[i][k].s2;
			H->pulse[k].s3 += H->pulse_tmp[i][k].s3;
		}
	}
}

void RS_download_pulse_only(RSHandle *H) {
	
	int i;
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->pulse_tmp[i], H->worker[i].pulse, H->params.range_count * sizeof(cl_float4));
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	for (i=0; i<H->num_workers; i++)
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	
#else
	
    // Blocking read
	for (i=0; i<H->num_workers; i++) {
		clEnqueueReadBuffer(H->worker[i].que, H->worker[i].pulse, CL_TRUE, 0, H->params.range_count * sizeof(cl_float4), H->pulse_tmp[i], 0, NULL, NULL);
	}
	
#endif
	
	RS_merge_pulse_tmp(H);
}


void RS_upload(RSHandle *H) {
	
	int i;
	
	if (H->verb > 3) {
		for (i=0; i<H->num_workers; i++) {
			printf("%s : RS : worker[%d].scat_pos @ %p\n", now(), i, H->worker[i].scat_pos);
			printf("%s : RS : worker[%d].scat_vel @ %p\n", now(), i, H->worker[i].scat_vel);
		}
		printf("%s : RS : scat_pos @ %p\n", now(), H->scat_pos);
		printf("%s : RS : scat_vel @ %p\n", now(), H->scat_vel);
	}
	
	cl_uint4 *seeds = (cl_uint4 *)malloc(H->num_scats * sizeof(cl_uint4));
	for (i=0; i<H->num_scats; i++) {
		seeds[i] = (cl_uint4){{rand(), rand(), rand(), rand()}};
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			gcl_memcpy(H->worker[i].scat_pos, H->scat_pos + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_vel, H->scat_vel + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_ori, H->scat_ori + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_att, H->scat_att + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			gcl_memcpy(H->worker[i].scat_sig, H->scat_sig + H->offset[i], H->worker[i].num_scats * sizeof(cl_float4));
			
			gcl_memcpy(H->worker[i].scat_rnd, seeds + H->offset[i], H->worker[i].num_scats * sizeof(cl_uint4));
			
			dispatch_semaphore_signal(H->worker[i].sem);
		});
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	for (i=0; i<H->num_workers; i++) {
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_pos, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_pos + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_vel, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_vel + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_ori, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_ori + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_att, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_att + H->offset[i], 0, NULL, NULL);
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_sig, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_float4), H->scat_sig + H->offset[i], 0, NULL, NULL);
		
		clEnqueueWriteBuffer(H->worker[i].que, H->worker[i].scat_rnd, CL_TRUE, 0, H->worker[i].num_scats * sizeof(cl_uint4), seeds + H->offset[i], 0, NULL, NULL);
	}
	
#endif
	
	free(seeds);
	
}


void RS_advance_time(RSHandle *H) {
	
	int i;
	
	if (!(H->status & RS_STATUS_DOMAIN_POPULATED)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}

#if defined (__APPLE__) && defined (_SHARE_OBJ_)

	cl_float8 domain_bounds = {{
		H->domain.origin.x,
		H->domain.origin.y,
		H->domain.origin.z,
		0.0f,
		H->domain.size.x,
		H->domain.size.y,
		H->domain.size.z,
		0.0f
	}};
	
	if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(5.0f / H->params.prt);
		for (i=0; i<H->num_workers; i++) {
			dispatch_async(H->worker[i].que, ^{
				scat_physics_kernel(&H->worker[i].ndrange_scat,
									(cl_float4 *)H->worker[i].scat_pos,
									(cl_float4 *)H->worker[i].scat_vel,
									(cl_image)H->worker[i].physics,
									H->worker[i].physics_desc);
				dispatch_semaphore_signal(H->worker[i].sem);
			});
		}
		for (i=0; i<H->num_workers; i++) {
			dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
		}
	}
    
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			scat_chk_kernel(&H->worker[i].ndrange_scat,
							(cl_float4 *)H->worker[i].scat_pos,
							(cl_float4 *)H->worker[i].scat_att,
							(cl_uint4 *)H->worker[i].scat_rnd,
							domain_bounds);
			scat_mov_kernel(&H->worker[i].ndrange_scat,
							(cl_float4 *)H->worker[i].scat_pos,
							(cl_float4 *)H->worker[i].scat_vel,
							(cl_float4 *)H->worker[i].scat_ori,
							(cl_float4 *)H->worker[i].scat_att,
							(cl_float *)H->worker[i].angular_weight,
							H->worker[i].angular_weight_desc,
							H->beam_pos,
							(cl_float4){{H->params.prt, H->params.prt / H->physics_table.tr, 0.0f, 0.0f}});
			scat_clr_kernel(&H->worker[i].ndrange_scat,
							(cl_float4 *)H->worker[i].scat_clr,
							(cl_float4 *)H->worker[i].scat_pos,
							(cl_float4 *)H->worker[i].scat_vel,
							(cl_float4 *)H->worker[i].scat_ori,
							(cl_float4 *)H->worker[i].scat_att,
							(unsigned int)H->worker[i].num_scats);
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}

#else

	cl_event event1s[RS_MAX_GPU_DEVICE];
	cl_event event2s[RS_MAX_GPU_DEVICE];
	
	if (H->sim_tic >= H->sim_toc) {
		H->sim_toc = H->sim_tic + (size_t)(1.0f / H->params.prt);
		if (H->verb) {
			printf("%s : RS : Setting physics ...\n", now());
		}
		for (i=0; i<H->num_workers; i++) {
			clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_physics, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, &event1s[i]);
			clFlush(H->worker[i].que);
		}
		for (i=0; i<H->num_workers; i++) {
			clWaitForEvents(1, &event1s[i]);
			clReleaseEvent(event1s[i]);
		}
	}
	
	for (i=0; i<H->num_workers; i++) {
		// Need to refresh some parameters at each time update
		clSetKernelArg(H->worker[i].kern_scat_mov, 6, sizeof(cl_float4), &H->beam_pos);
		//clSetKernelArg(H->worker[i].kern_scat_mov, 7, sizeof(float), &H->params.prt);

		//clSetKernelArg(H->worker[i].kern_scat_chk, 3, sizeof(cl_float8), &domain_bounds);
		
		clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_chk, 1, NULL, &H->worker[i].num_scats, NULL, 0, NULL, &event1s[i]);
		clEnqueueNDRangeKernel(H->worker[i].que, H->worker[i].kern_scat_mov, 1, NULL, &H->worker[i].num_scats, NULL, 1, &event1s[i], &event2s[i]);
	}

    for (i=0; i<H->num_workers; i++) {
        clFlush(H->worker[i].que);
    }
    
    for (i=0; i<H->num_workers; i++) {
        clWaitForEvents(1, &event2s[i]);
    }
	
    for (i=0; i<H->num_workers; i++) {
		clReleaseEvent(event1s[i]);
		clReleaseEvent(event2s[i]);
    }
	
#endif
	
	H->sim_tic++;
	H->sim_time = H->sim_tic * H->params.prt;
}


void RS_advance_time_cpu(RSHandle *H) {
	for (int i=0; i<H->num_scats; i++) {
		H->scat_vel[i].x += H->scat_ori[i].x * 0.1f;
		H->scat_vel[i].y += H->scat_ori[i].y * 0.1f;
		H->scat_vel[i].z += H->scat_ori[i].z * 0.1f;
		
		H->scat_pos[i].x += H->scat_vel[i].x * H->params.prt;
		H->scat_pos[i].y += H->scat_vel[i].y * H->params.prt;
		H->scat_pos[i].z += H->scat_vel[i].z * H->params.prt;
		
		H->scat_att[i].s0 = sqrtf(H->scat_pos[i].x * H->scat_pos[i].x +
								  H->scat_pos[i].y * H->scat_pos[i].y +
								  H->scat_pos[i].z * H->scat_pos[i].z);
//		H->scat_att[i].s1 = (H->scat_pos[i].x * H->beam_pos.x +
//							 H->scat_pos[i].y * H->beam_pos.y +
//							 H->scat_pos[i].z * H->beam_pos.z) / H->scat_att[i].s0;
		H->scat_att[i].s1 += H->params.prt;
		H->scat_att[i].s2 = acosf(H->scat_att[i].s1);
		H->scat_att[i].s3 = read_table(H->angular_weight_table.data,
									   H->angular_weight_table.xm,
									   H->scat_att[i].s2 * H->angular_weight_table.dx + H->angular_weight_table.x0);
	}
	H->sim_tic++;
	H->sim_time = H->sim_tic * H->params.prt;
}


void RS_make_pulse(RSHandle *H) {
	
	int i;
	
	if (!(H->status & RS_STATUS_DOMAIN_POPULATED)) {
		fprintf(stderr, "%s : RS : Simulation domain not populated.\n", now());
		return;
	}
	
#if defined (__APPLE__) && defined (_SHARE_OBJ_)
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_async(H->worker[i].que, ^{
			
#ifdef MAKE_PULSE_PASS_1
			make_pulse_pass_1_kernel(&H->worker[i].ndrange_pulse_pass_1,
									 (cl_float4 *)H->worker[i].work,
									 (cl_float4 *)H->worker[i].scat_sig,
									 (cl_float4 *)H->worker[i].scat_att,
									 H->worker[i].make_pulse_params.local_mem_size[0],
									 (cl_float *)H->worker[i].range_weight,
									 H->range_weight_table.x0,
									 H->range_weight_table.xm,
									 H->range_weight_table.dx,
									 H->worker[i].make_pulse_params.range_start,
									 H->worker[i].make_pulse_params.range_delta,
									 H->worker[i].make_pulse_params.range_count,
									 H->worker[i].make_pulse_params.group_counts[0],
									 H->worker[i].make_pulse_params.entry_counts[0]);
#endif
			switch (H->worker[i].make_pulse_params.cl_pass_2_method) {
				case RS_CL_PASS_2_IN_LOCAL:
					make_pulse_pass_2_local_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				case RS_CL_PASS_2_IN_RANGE:
					make_pulse_pass_2_range_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
				default:
					make_pulse_pass_2_group_kernel(&H->worker[i].ndrange_pulse_pass_2,
												   (cl_float4 *)H->worker[i].pulse,
												   (cl_float4 *)H->worker[i].work,
												   H->worker[i].make_pulse_params.local_mem_size[1],
												   H->worker[i].make_pulse_params.range_count,
												   H->worker[i].make_pulse_params.entry_counts[1]);
					break;
			}
			dispatch_semaphore_signal(H->worker[i].sem);
		});
	}
	
	for (i=0; i<H->num_workers; i++) {
		dispatch_semaphore_wait(H->worker[i].sem, DISPATCH_TIME_FOREVER);
	}
	
#else
	
	cl_event pass_1_events[H->num_workers];
	cl_event pass_2_events[H->num_workers];
	for (i=0; i<H->num_workers; i++) {
		RSWorker *C = &H->worker[i];
		clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_1, 1, NULL, &C->make_pulse_params.global[0], &C->make_pulse_params.local[0], 0, NULL, &pass_1_events[i]);
		clEnqueueNDRangeKernel(C->que, C->kern_make_pulse_pass_2, 1, NULL, &C->make_pulse_params.global[1], &C->make_pulse_params.local[1], 1, &pass_1_events[i], &pass_2_events[i]);
        clFlush(C->que);
	}
	
    for (i=0; i<H->num_workers; i++) {
        clWaitForEvents(1, &pass_2_events[i]);
		clReleaseEvent(pass_1_events[i]);
		clReleaseEvent(pass_2_events[i]);
    }
	
#endif
	
}


typedef struct _cpu_worker_input {
	int name;
	int scat_start;
	int scat_end;
	RSHandle *H;
} RSCPUWorkerInput;


void *RS_make_pulse_cpu_worker(void *input) {
	
	RSCPUWorkerInput *C = (RSCPUWorkerInput *)input;
	RSHandle *H = C->H;
	
	float r;
	float w_r;
	const int w = C->name;
	const cl_float4 zero = {{0.0f, 0.0f, 0.0f, 0.0f}};
	
	for (int ir=0; ir<H->params.range_count; ir++) {
		r = (float)ir * H->params.range_delta + H->params.range_start;
		//H->pulse[ir] = zero;
		H->pulse_tmp[w][ir] = zero;
		for (int i=C->scat_start; i<C->scat_end; i++) {
			float r_a = H->scat_att[i].s0;
			float fidx = (r_a - r) * H->range_weight_table.dx + H->range_weight_table.x0;
			w_r = read_table(H->range_weight_table.data, H->range_weight_table.xm, fidx);
//			if (i < 32) {
//				printf("ir=%2u  r=%5.2f  i=%2u  r_a=%.3f  dr=%.3f  w_r=%.3f  %.2f -> %.0f/%.0f/%.2f\n",
//					   ir, r, i, r_a, r_a-r, w_r, fidx, floorf(fidx), ceilf(fidx), fidx-floorf(fidx));
//			}
			H->pulse_tmp[w][ir].s0 += (H->scat_sig[i].s0 * w_r);
			H->pulse_tmp[w][ir].s1 += (H->scat_sig[i].s1 * w_r);
			H->pulse_tmp[w][ir].s2 += (H->scat_sig[i].s2 * w_r);
			H->pulse_tmp[w][ir].s3 += (H->scat_sig[i].s3 * w_r);
		}
	}
	RS_merge_pulse_tmp(H);
	return (void *)0;
}

void RS_make_pulse_cpu(RSHandle *H) {
	
	int i;
	int offset = 0;
	int size = (int)H->num_scats / H->num_workers;
	pthread_t tid[H->num_workers];
	
	RSCPUWorkerInput W[H->num_workers];
	
	for (i=0; i<H->num_workers; i++) {
		W[i].H = H;
		W[i].name = i;
		W[i].scat_start = offset;
		W[i].scat_end = offset + size;
		pthread_create(&tid[i], NULL, RS_make_pulse_cpu_worker, &W[i]);
		offset += size;
	}
	
	for (i=0; i<H->num_workers; i++)
		pthread_join(tid[i], NULL);
}

#pragma mark -
#pragma mark Elements for table lookup

RSTable RS_table_init(size_t numel) {
    RSTable table = {0.0f, 1.0f, 1.0f, 0, NULL};
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(float))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table_free(RSTable T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


RSTable2D RS_table2d_init(size_t numel) {
    RSTable2D table;
    
    table.xs = 1.0f;      table.ys = 1.0f;
    table.xo = 0.0f;      table.yo = 0.0f;
    table.xm = 1.0f;      table.ym = 1.0f;
    
    if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
        fprintf(stderr, "%s : RS : Error allocating an RSTable2D->data.\n", now());
        return table;
    }
    
    return table;
}


void RS_table2d_free(RSTable2D T) {
    if (T.data != NULL) {
        free(T.data);
        T.data = NULL;
    }
}


RSTable3D RS_table3d_init(size_t numel) {
	RSTable3D table;
	
	table.xs = 1.0f;      table.ys = 1.0f;      table.zs = 1.0f;
	table.xo = 0.0f;      table.yo = 0.0f;      table.zo = 0.0f;
	table.xm = 1.0f;      table.ym = 1.0f;      table.zm = 1.0f;
	
	if (posix_memalign((void **)&table.data, RS_ALIGN_SIZE, numel * sizeof(cl_float4))) {
		fprintf(stderr, "%s : RS : Error allocating an RSTable3D->data.\n", now());
		return table;
	}
	
	return table;
}


void RS_table3d_free(RSTable3D T) {
	if (T.data != NULL) {
		free(T.data);
        T.data = NULL;
	}
}


#pragma mark -
#pragma mark Display

static void RS_show_scat_i(RSHandle *H, int i) {
	printf(" %7d - ( %9.2f, %9.2f, %9.2f, %9.2f )  %7.4f %7.4f %7.4f %7.4f\n", i,
		   H->scat_pos[i].x, H->scat_pos[i].y, H->scat_pos[i].z, H->scat_pos[i].w,
		   H->scat_vel[i].x, H->scat_vel[i].y, H->scat_vel[i].z, H->scat_att[i].s3);
}


void RS_show_scat_pos(RSHandle *H) {
	int i;
	for (i=0; i<H->num_scats-1; i+=H->num_scats/9) {
		//for (i=0; i<H->num_scats-1; i+=H->num_scats/100) {
		RS_show_scat_i(H, i);
	}
	i = (int)(H->num_scats - 1);
	RS_show_scat_i(H, i);
}


void RS_show_pulse(RSHandle *H) {
	unsigned int i;
	printf(" %7zu - [", H->sim_tic);
	for (i=0; i<MIN(4, H->params.range_count); i++) {
		if (i > 0) {
			printf(",");
		}
		printf(" %9.2f", H->pulse[i].s0);
	}
	if (i < H->params.range_count) {
		printf(",  . . . , %9.2f", H->pulse[H->params.range_count - 1].s0);
	}
	printf(" ] (%d)\n", H->params.range_count);
}
